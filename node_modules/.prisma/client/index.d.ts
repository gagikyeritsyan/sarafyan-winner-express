
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Body_image
 * 
 */
export type Body_image = $Result.DefaultSelection<Prisma.$Body_imagePayload>
/**
 * Model Header_main_logo
 * 
 */
export type Header_main_logo = $Result.DefaultSelection<Prisma.$Header_main_logoPayload>
/**
 * Model Header_navbar
 * 
 */
export type Header_navbar = $Result.DefaultSelection<Prisma.$Header_navbarPayload>
/**
 * Model Header_language
 * 
 */
export type Header_language = $Result.DefaultSelection<Prisma.$Header_languagePayload>
/**
 * Model Home_intro
 * 
 */
export type Home_intro = $Result.DefaultSelection<Prisma.$Home_introPayload>
/**
 * Model About_title
 * 
 */
export type About_title = $Result.DefaultSelection<Prisma.$About_titlePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Gallery_title
 * 
 */
export type Gallery_title = $Result.DefaultSelection<Prisma.$Gallery_titlePayload>
/**
 * Model Gallery_content
 * 
 */
export type Gallery_content = $Result.DefaultSelection<Prisma.$Gallery_contentPayload>
/**
 * Model Contact_title
 * 
 */
export type Contact_title = $Result.DefaultSelection<Prisma.$Contact_titlePayload>
/**
 * Model Contact_info
 * 
 */
export type Contact_info = $Result.DefaultSelection<Prisma.$Contact_infoPayload>
/**
 * Model Footer
 * 
 */
export type Footer = $Result.DefaultSelection<Prisma.$FooterPayload>
/**
 * Model Winery_info
 * 
 */
export type Winery_info = $Result.DefaultSelection<Prisma.$Winery_infoPayload>
/**
 * Model Winery_image
 * 
 */
export type Winery_image = $Result.DefaultSelection<Prisma.$Winery_imagePayload>
/**
 * Model Winery_our_story
 * 
 */
export type Winery_our_story = $Result.DefaultSelection<Prisma.$Winery_our_storyPayload>
/**
 * Model Gallery_product
 * 
 */
export type Gallery_product = $Result.DefaultSelection<Prisma.$Gallery_productPayload>
/**
 * Model Contact_us
 * 
 */
export type Contact_us = $Result.DefaultSelection<Prisma.$Contact_usPayload>
/**
 * Model Contact_message
 * 
 */
export type Contact_message = $Result.DefaultSelection<Prisma.$Contact_messagePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.body_image`: Exposes CRUD operations for the **Body_image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Body_images
    * const body_images = await prisma.body_image.findMany()
    * ```
    */
  get body_image(): Prisma.Body_imageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.header_main_logo`: Exposes CRUD operations for the **Header_main_logo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Header_main_logos
    * const header_main_logos = await prisma.header_main_logo.findMany()
    * ```
    */
  get header_main_logo(): Prisma.Header_main_logoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.header_navbar`: Exposes CRUD operations for the **Header_navbar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Header_navbars
    * const header_navbars = await prisma.header_navbar.findMany()
    * ```
    */
  get header_navbar(): Prisma.Header_navbarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.header_language`: Exposes CRUD operations for the **Header_language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Header_languages
    * const header_languages = await prisma.header_language.findMany()
    * ```
    */
  get header_language(): Prisma.Header_languageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.home_intro`: Exposes CRUD operations for the **Home_intro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Home_intros
    * const home_intros = await prisma.home_intro.findMany()
    * ```
    */
  get home_intro(): Prisma.Home_introDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.about_title`: Exposes CRUD operations for the **About_title** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more About_titles
    * const about_titles = await prisma.about_title.findMany()
    * ```
    */
  get about_title(): Prisma.About_titleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gallery_title`: Exposes CRUD operations for the **Gallery_title** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gallery_titles
    * const gallery_titles = await prisma.gallery_title.findMany()
    * ```
    */
  get gallery_title(): Prisma.Gallery_titleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gallery_content`: Exposes CRUD operations for the **Gallery_content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gallery_contents
    * const gallery_contents = await prisma.gallery_content.findMany()
    * ```
    */
  get gallery_content(): Prisma.Gallery_contentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact_title`: Exposes CRUD operations for the **Contact_title** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_titles
    * const contact_titles = await prisma.contact_title.findMany()
    * ```
    */
  get contact_title(): Prisma.Contact_titleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact_info`: Exposes CRUD operations for the **Contact_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_infos
    * const contact_infos = await prisma.contact_info.findMany()
    * ```
    */
  get contact_info(): Prisma.Contact_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.footer`: Exposes CRUD operations for the **Footer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Footers
    * const footers = await prisma.footer.findMany()
    * ```
    */
  get footer(): Prisma.FooterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.winery_info`: Exposes CRUD operations for the **Winery_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Winery_infos
    * const winery_infos = await prisma.winery_info.findMany()
    * ```
    */
  get winery_info(): Prisma.Winery_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.winery_image`: Exposes CRUD operations for the **Winery_image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Winery_images
    * const winery_images = await prisma.winery_image.findMany()
    * ```
    */
  get winery_image(): Prisma.Winery_imageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.winery_our_story`: Exposes CRUD operations for the **Winery_our_story** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Winery_our_stories
    * const winery_our_stories = await prisma.winery_our_story.findMany()
    * ```
    */
  get winery_our_story(): Prisma.Winery_our_storyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gallery_product`: Exposes CRUD operations for the **Gallery_product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gallery_products
    * const gallery_products = await prisma.gallery_product.findMany()
    * ```
    */
  get gallery_product(): Prisma.Gallery_productDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact_us`: Exposes CRUD operations for the **Contact_us** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_uses
    * const contact_uses = await prisma.contact_us.findMany()
    * ```
    */
  get contact_us(): Prisma.Contact_usDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact_message`: Exposes CRUD operations for the **Contact_message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_messages
    * const contact_messages = await prisma.contact_message.findMany()
    * ```
    */
  get contact_message(): Prisma.Contact_messageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Body_image: 'Body_image',
    Header_main_logo: 'Header_main_logo',
    Header_navbar: 'Header_navbar',
    Header_language: 'Header_language',
    Home_intro: 'Home_intro',
    About_title: 'About_title',
    Product: 'Product',
    Gallery_title: 'Gallery_title',
    Gallery_content: 'Gallery_content',
    Contact_title: 'Contact_title',
    Contact_info: 'Contact_info',
    Footer: 'Footer',
    Winery_info: 'Winery_info',
    Winery_image: 'Winery_image',
    Winery_our_story: 'Winery_our_story',
    Gallery_product: 'Gallery_product',
    Contact_us: 'Contact_us',
    Contact_message: 'Contact_message'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "body_image" | "header_main_logo" | "header_navbar" | "header_language" | "home_intro" | "about_title" | "product" | "gallery_title" | "gallery_content" | "contact_title" | "contact_info" | "footer" | "winery_info" | "winery_image" | "winery_our_story" | "gallery_product" | "contact_us" | "contact_message"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Body_image: {
        payload: Prisma.$Body_imagePayload<ExtArgs>
        fields: Prisma.Body_imageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Body_imageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Body_imageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload>
          }
          findFirst: {
            args: Prisma.Body_imageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Body_imageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload>
          }
          findMany: {
            args: Prisma.Body_imageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload>[]
          }
          create: {
            args: Prisma.Body_imageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload>
          }
          createMany: {
            args: Prisma.Body_imageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Body_imageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload>[]
          }
          delete: {
            args: Prisma.Body_imageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload>
          }
          update: {
            args: Prisma.Body_imageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload>
          }
          deleteMany: {
            args: Prisma.Body_imageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Body_imageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Body_imageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload>[]
          }
          upsert: {
            args: Prisma.Body_imageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Body_imagePayload>
          }
          aggregate: {
            args: Prisma.Body_imageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBody_image>
          }
          groupBy: {
            args: Prisma.Body_imageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Body_imageGroupByOutputType>[]
          }
          count: {
            args: Prisma.Body_imageCountArgs<ExtArgs>
            result: $Utils.Optional<Body_imageCountAggregateOutputType> | number
          }
        }
      }
      Header_main_logo: {
        payload: Prisma.$Header_main_logoPayload<ExtArgs>
        fields: Prisma.Header_main_logoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Header_main_logoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Header_main_logoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload>
          }
          findFirst: {
            args: Prisma.Header_main_logoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Header_main_logoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload>
          }
          findMany: {
            args: Prisma.Header_main_logoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload>[]
          }
          create: {
            args: Prisma.Header_main_logoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload>
          }
          createMany: {
            args: Prisma.Header_main_logoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Header_main_logoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload>[]
          }
          delete: {
            args: Prisma.Header_main_logoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload>
          }
          update: {
            args: Prisma.Header_main_logoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload>
          }
          deleteMany: {
            args: Prisma.Header_main_logoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Header_main_logoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Header_main_logoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload>[]
          }
          upsert: {
            args: Prisma.Header_main_logoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_main_logoPayload>
          }
          aggregate: {
            args: Prisma.Header_main_logoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeader_main_logo>
          }
          groupBy: {
            args: Prisma.Header_main_logoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Header_main_logoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Header_main_logoCountArgs<ExtArgs>
            result: $Utils.Optional<Header_main_logoCountAggregateOutputType> | number
          }
        }
      }
      Header_navbar: {
        payload: Prisma.$Header_navbarPayload<ExtArgs>
        fields: Prisma.Header_navbarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Header_navbarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Header_navbarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload>
          }
          findFirst: {
            args: Prisma.Header_navbarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Header_navbarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload>
          }
          findMany: {
            args: Prisma.Header_navbarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload>[]
          }
          create: {
            args: Prisma.Header_navbarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload>
          }
          createMany: {
            args: Prisma.Header_navbarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Header_navbarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload>[]
          }
          delete: {
            args: Prisma.Header_navbarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload>
          }
          update: {
            args: Prisma.Header_navbarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload>
          }
          deleteMany: {
            args: Prisma.Header_navbarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Header_navbarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Header_navbarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload>[]
          }
          upsert: {
            args: Prisma.Header_navbarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_navbarPayload>
          }
          aggregate: {
            args: Prisma.Header_navbarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeader_navbar>
          }
          groupBy: {
            args: Prisma.Header_navbarGroupByArgs<ExtArgs>
            result: $Utils.Optional<Header_navbarGroupByOutputType>[]
          }
          count: {
            args: Prisma.Header_navbarCountArgs<ExtArgs>
            result: $Utils.Optional<Header_navbarCountAggregateOutputType> | number
          }
        }
      }
      Header_language: {
        payload: Prisma.$Header_languagePayload<ExtArgs>
        fields: Prisma.Header_languageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Header_languageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Header_languageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload>
          }
          findFirst: {
            args: Prisma.Header_languageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Header_languageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload>
          }
          findMany: {
            args: Prisma.Header_languageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload>[]
          }
          create: {
            args: Prisma.Header_languageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload>
          }
          createMany: {
            args: Prisma.Header_languageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Header_languageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload>[]
          }
          delete: {
            args: Prisma.Header_languageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload>
          }
          update: {
            args: Prisma.Header_languageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload>
          }
          deleteMany: {
            args: Prisma.Header_languageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Header_languageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Header_languageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload>[]
          }
          upsert: {
            args: Prisma.Header_languageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Header_languagePayload>
          }
          aggregate: {
            args: Prisma.Header_languageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeader_language>
          }
          groupBy: {
            args: Prisma.Header_languageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Header_languageGroupByOutputType>[]
          }
          count: {
            args: Prisma.Header_languageCountArgs<ExtArgs>
            result: $Utils.Optional<Header_languageCountAggregateOutputType> | number
          }
        }
      }
      Home_intro: {
        payload: Prisma.$Home_introPayload<ExtArgs>
        fields: Prisma.Home_introFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Home_introFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Home_introFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload>
          }
          findFirst: {
            args: Prisma.Home_introFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Home_introFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload>
          }
          findMany: {
            args: Prisma.Home_introFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload>[]
          }
          create: {
            args: Prisma.Home_introCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload>
          }
          createMany: {
            args: Prisma.Home_introCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Home_introCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload>[]
          }
          delete: {
            args: Prisma.Home_introDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload>
          }
          update: {
            args: Prisma.Home_introUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload>
          }
          deleteMany: {
            args: Prisma.Home_introDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Home_introUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Home_introUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload>[]
          }
          upsert: {
            args: Prisma.Home_introUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Home_introPayload>
          }
          aggregate: {
            args: Prisma.Home_introAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHome_intro>
          }
          groupBy: {
            args: Prisma.Home_introGroupByArgs<ExtArgs>
            result: $Utils.Optional<Home_introGroupByOutputType>[]
          }
          count: {
            args: Prisma.Home_introCountArgs<ExtArgs>
            result: $Utils.Optional<Home_introCountAggregateOutputType> | number
          }
        }
      }
      About_title: {
        payload: Prisma.$About_titlePayload<ExtArgs>
        fields: Prisma.About_titleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.About_titleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.About_titleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload>
          }
          findFirst: {
            args: Prisma.About_titleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.About_titleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload>
          }
          findMany: {
            args: Prisma.About_titleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload>[]
          }
          create: {
            args: Prisma.About_titleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload>
          }
          createMany: {
            args: Prisma.About_titleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.About_titleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload>[]
          }
          delete: {
            args: Prisma.About_titleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload>
          }
          update: {
            args: Prisma.About_titleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload>
          }
          deleteMany: {
            args: Prisma.About_titleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.About_titleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.About_titleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload>[]
          }
          upsert: {
            args: Prisma.About_titleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$About_titlePayload>
          }
          aggregate: {
            args: Prisma.About_titleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbout_title>
          }
          groupBy: {
            args: Prisma.About_titleGroupByArgs<ExtArgs>
            result: $Utils.Optional<About_titleGroupByOutputType>[]
          }
          count: {
            args: Prisma.About_titleCountArgs<ExtArgs>
            result: $Utils.Optional<About_titleCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Gallery_title: {
        payload: Prisma.$Gallery_titlePayload<ExtArgs>
        fields: Prisma.Gallery_titleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Gallery_titleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Gallery_titleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload>
          }
          findFirst: {
            args: Prisma.Gallery_titleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Gallery_titleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload>
          }
          findMany: {
            args: Prisma.Gallery_titleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload>[]
          }
          create: {
            args: Prisma.Gallery_titleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload>
          }
          createMany: {
            args: Prisma.Gallery_titleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Gallery_titleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload>[]
          }
          delete: {
            args: Prisma.Gallery_titleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload>
          }
          update: {
            args: Prisma.Gallery_titleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload>
          }
          deleteMany: {
            args: Prisma.Gallery_titleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Gallery_titleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Gallery_titleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload>[]
          }
          upsert: {
            args: Prisma.Gallery_titleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_titlePayload>
          }
          aggregate: {
            args: Prisma.Gallery_titleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGallery_title>
          }
          groupBy: {
            args: Prisma.Gallery_titleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gallery_titleGroupByOutputType>[]
          }
          count: {
            args: Prisma.Gallery_titleCountArgs<ExtArgs>
            result: $Utils.Optional<Gallery_titleCountAggregateOutputType> | number
          }
        }
      }
      Gallery_content: {
        payload: Prisma.$Gallery_contentPayload<ExtArgs>
        fields: Prisma.Gallery_contentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Gallery_contentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Gallery_contentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload>
          }
          findFirst: {
            args: Prisma.Gallery_contentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Gallery_contentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload>
          }
          findMany: {
            args: Prisma.Gallery_contentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload>[]
          }
          create: {
            args: Prisma.Gallery_contentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload>
          }
          createMany: {
            args: Prisma.Gallery_contentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Gallery_contentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload>[]
          }
          delete: {
            args: Prisma.Gallery_contentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload>
          }
          update: {
            args: Prisma.Gallery_contentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload>
          }
          deleteMany: {
            args: Prisma.Gallery_contentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Gallery_contentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Gallery_contentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload>[]
          }
          upsert: {
            args: Prisma.Gallery_contentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_contentPayload>
          }
          aggregate: {
            args: Prisma.Gallery_contentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGallery_content>
          }
          groupBy: {
            args: Prisma.Gallery_contentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gallery_contentGroupByOutputType>[]
          }
          count: {
            args: Prisma.Gallery_contentCountArgs<ExtArgs>
            result: $Utils.Optional<Gallery_contentCountAggregateOutputType> | number
          }
        }
      }
      Contact_title: {
        payload: Prisma.$Contact_titlePayload<ExtArgs>
        fields: Prisma.Contact_titleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Contact_titleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Contact_titleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload>
          }
          findFirst: {
            args: Prisma.Contact_titleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Contact_titleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload>
          }
          findMany: {
            args: Prisma.Contact_titleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload>[]
          }
          create: {
            args: Prisma.Contact_titleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload>
          }
          createMany: {
            args: Prisma.Contact_titleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Contact_titleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload>[]
          }
          delete: {
            args: Prisma.Contact_titleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload>
          }
          update: {
            args: Prisma.Contact_titleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload>
          }
          deleteMany: {
            args: Prisma.Contact_titleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Contact_titleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Contact_titleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload>[]
          }
          upsert: {
            args: Prisma.Contact_titleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_titlePayload>
          }
          aggregate: {
            args: Prisma.Contact_titleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_title>
          }
          groupBy: {
            args: Prisma.Contact_titleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_titleGroupByOutputType>[]
          }
          count: {
            args: Prisma.Contact_titleCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_titleCountAggregateOutputType> | number
          }
        }
      }
      Contact_info: {
        payload: Prisma.$Contact_infoPayload<ExtArgs>
        fields: Prisma.Contact_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Contact_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Contact_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload>
          }
          findFirst: {
            args: Prisma.Contact_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Contact_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload>
          }
          findMany: {
            args: Prisma.Contact_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload>[]
          }
          create: {
            args: Prisma.Contact_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload>
          }
          createMany: {
            args: Prisma.Contact_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Contact_infoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload>[]
          }
          delete: {
            args: Prisma.Contact_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload>
          }
          update: {
            args: Prisma.Contact_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload>
          }
          deleteMany: {
            args: Prisma.Contact_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Contact_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Contact_infoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload>[]
          }
          upsert: {
            args: Prisma.Contact_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_infoPayload>
          }
          aggregate: {
            args: Prisma.Contact_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_info>
          }
          groupBy: {
            args: Prisma.Contact_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Contact_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_infoCountAggregateOutputType> | number
          }
        }
      }
      Footer: {
        payload: Prisma.$FooterPayload<ExtArgs>
        fields: Prisma.FooterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FooterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FooterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          findFirst: {
            args: Prisma.FooterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FooterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          findMany: {
            args: Prisma.FooterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>[]
          }
          create: {
            args: Prisma.FooterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          createMany: {
            args: Prisma.FooterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FooterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>[]
          }
          delete: {
            args: Prisma.FooterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          update: {
            args: Prisma.FooterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          deleteMany: {
            args: Prisma.FooterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FooterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FooterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>[]
          }
          upsert: {
            args: Prisma.FooterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterPayload>
          }
          aggregate: {
            args: Prisma.FooterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFooter>
          }
          groupBy: {
            args: Prisma.FooterGroupByArgs<ExtArgs>
            result: $Utils.Optional<FooterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FooterCountArgs<ExtArgs>
            result: $Utils.Optional<FooterCountAggregateOutputType> | number
          }
        }
      }
      Winery_info: {
        payload: Prisma.$Winery_infoPayload<ExtArgs>
        fields: Prisma.Winery_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Winery_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Winery_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload>
          }
          findFirst: {
            args: Prisma.Winery_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Winery_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload>
          }
          findMany: {
            args: Prisma.Winery_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload>[]
          }
          create: {
            args: Prisma.Winery_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload>
          }
          createMany: {
            args: Prisma.Winery_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Winery_infoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload>[]
          }
          delete: {
            args: Prisma.Winery_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload>
          }
          update: {
            args: Prisma.Winery_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload>
          }
          deleteMany: {
            args: Prisma.Winery_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Winery_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Winery_infoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload>[]
          }
          upsert: {
            args: Prisma.Winery_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_infoPayload>
          }
          aggregate: {
            args: Prisma.Winery_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWinery_info>
          }
          groupBy: {
            args: Prisma.Winery_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Winery_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Winery_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Winery_infoCountAggregateOutputType> | number
          }
        }
      }
      Winery_image: {
        payload: Prisma.$Winery_imagePayload<ExtArgs>
        fields: Prisma.Winery_imageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Winery_imageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Winery_imageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload>
          }
          findFirst: {
            args: Prisma.Winery_imageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Winery_imageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload>
          }
          findMany: {
            args: Prisma.Winery_imageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload>[]
          }
          create: {
            args: Prisma.Winery_imageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload>
          }
          createMany: {
            args: Prisma.Winery_imageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Winery_imageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload>[]
          }
          delete: {
            args: Prisma.Winery_imageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload>
          }
          update: {
            args: Prisma.Winery_imageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload>
          }
          deleteMany: {
            args: Prisma.Winery_imageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Winery_imageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Winery_imageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload>[]
          }
          upsert: {
            args: Prisma.Winery_imageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_imagePayload>
          }
          aggregate: {
            args: Prisma.Winery_imageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWinery_image>
          }
          groupBy: {
            args: Prisma.Winery_imageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Winery_imageGroupByOutputType>[]
          }
          count: {
            args: Prisma.Winery_imageCountArgs<ExtArgs>
            result: $Utils.Optional<Winery_imageCountAggregateOutputType> | number
          }
        }
      }
      Winery_our_story: {
        payload: Prisma.$Winery_our_storyPayload<ExtArgs>
        fields: Prisma.Winery_our_storyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Winery_our_storyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Winery_our_storyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload>
          }
          findFirst: {
            args: Prisma.Winery_our_storyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Winery_our_storyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload>
          }
          findMany: {
            args: Prisma.Winery_our_storyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload>[]
          }
          create: {
            args: Prisma.Winery_our_storyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload>
          }
          createMany: {
            args: Prisma.Winery_our_storyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Winery_our_storyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload>[]
          }
          delete: {
            args: Prisma.Winery_our_storyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload>
          }
          update: {
            args: Prisma.Winery_our_storyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload>
          }
          deleteMany: {
            args: Prisma.Winery_our_storyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Winery_our_storyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Winery_our_storyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload>[]
          }
          upsert: {
            args: Prisma.Winery_our_storyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Winery_our_storyPayload>
          }
          aggregate: {
            args: Prisma.Winery_our_storyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWinery_our_story>
          }
          groupBy: {
            args: Prisma.Winery_our_storyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Winery_our_storyGroupByOutputType>[]
          }
          count: {
            args: Prisma.Winery_our_storyCountArgs<ExtArgs>
            result: $Utils.Optional<Winery_our_storyCountAggregateOutputType> | number
          }
        }
      }
      Gallery_product: {
        payload: Prisma.$Gallery_productPayload<ExtArgs>
        fields: Prisma.Gallery_productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Gallery_productFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Gallery_productFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload>
          }
          findFirst: {
            args: Prisma.Gallery_productFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Gallery_productFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload>
          }
          findMany: {
            args: Prisma.Gallery_productFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload>[]
          }
          create: {
            args: Prisma.Gallery_productCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload>
          }
          createMany: {
            args: Prisma.Gallery_productCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Gallery_productCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload>[]
          }
          delete: {
            args: Prisma.Gallery_productDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload>
          }
          update: {
            args: Prisma.Gallery_productUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload>
          }
          deleteMany: {
            args: Prisma.Gallery_productDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Gallery_productUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Gallery_productUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload>[]
          }
          upsert: {
            args: Prisma.Gallery_productUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Gallery_productPayload>
          }
          aggregate: {
            args: Prisma.Gallery_productAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGallery_product>
          }
          groupBy: {
            args: Prisma.Gallery_productGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gallery_productGroupByOutputType>[]
          }
          count: {
            args: Prisma.Gallery_productCountArgs<ExtArgs>
            result: $Utils.Optional<Gallery_productCountAggregateOutputType> | number
          }
        }
      }
      Contact_us: {
        payload: Prisma.$Contact_usPayload<ExtArgs>
        fields: Prisma.Contact_usFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Contact_usFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Contact_usFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload>
          }
          findFirst: {
            args: Prisma.Contact_usFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Contact_usFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload>
          }
          findMany: {
            args: Prisma.Contact_usFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload>[]
          }
          create: {
            args: Prisma.Contact_usCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload>
          }
          createMany: {
            args: Prisma.Contact_usCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Contact_usCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload>[]
          }
          delete: {
            args: Prisma.Contact_usDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload>
          }
          update: {
            args: Prisma.Contact_usUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload>
          }
          deleteMany: {
            args: Prisma.Contact_usDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Contact_usUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Contact_usUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload>[]
          }
          upsert: {
            args: Prisma.Contact_usUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_usPayload>
          }
          aggregate: {
            args: Prisma.Contact_usAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_us>
          }
          groupBy: {
            args: Prisma.Contact_usGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_usGroupByOutputType>[]
          }
          count: {
            args: Prisma.Contact_usCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_usCountAggregateOutputType> | number
          }
        }
      }
      Contact_message: {
        payload: Prisma.$Contact_messagePayload<ExtArgs>
        fields: Prisma.Contact_messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Contact_messageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Contact_messageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload>
          }
          findFirst: {
            args: Prisma.Contact_messageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Contact_messageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload>
          }
          findMany: {
            args: Prisma.Contact_messageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload>[]
          }
          create: {
            args: Prisma.Contact_messageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload>
          }
          createMany: {
            args: Prisma.Contact_messageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Contact_messageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload>[]
          }
          delete: {
            args: Prisma.Contact_messageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload>
          }
          update: {
            args: Prisma.Contact_messageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload>
          }
          deleteMany: {
            args: Prisma.Contact_messageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Contact_messageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Contact_messageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload>[]
          }
          upsert: {
            args: Prisma.Contact_messageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_messagePayload>
          }
          aggregate: {
            args: Prisma.Contact_messageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_message>
          }
          groupBy: {
            args: Prisma.Contact_messageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_messageGroupByOutputType>[]
          }
          count: {
            args: Prisma.Contact_messageCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_messageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    body_image?: Body_imageOmit
    header_main_logo?: Header_main_logoOmit
    header_navbar?: Header_navbarOmit
    header_language?: Header_languageOmit
    home_intro?: Home_introOmit
    about_title?: About_titleOmit
    product?: ProductOmit
    gallery_title?: Gallery_titleOmit
    gallery_content?: Gallery_contentOmit
    contact_title?: Contact_titleOmit
    contact_info?: Contact_infoOmit
    footer?: FooterOmit
    winery_info?: Winery_infoOmit
    winery_image?: Winery_imageOmit
    winery_our_story?: Winery_our_storyOmit
    gallery_product?: Gallery_productOmit
    contact_us?: Contact_usOmit
    contact_message?: Contact_messageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    password: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model Body_image
   */

  export type AggregateBody_image = {
    _count: Body_imageCountAggregateOutputType | null
    _min: Body_imageMinAggregateOutputType | null
    _max: Body_imageMaxAggregateOutputType | null
  }

  export type Body_imageMinAggregateOutputType = {
    id: string | null
    background_img1: string | null
  }

  export type Body_imageMaxAggregateOutputType = {
    id: string | null
    background_img1: string | null
  }

  export type Body_imageCountAggregateOutputType = {
    id: number
    background_img1: number
    _all: number
  }


  export type Body_imageMinAggregateInputType = {
    id?: true
    background_img1?: true
  }

  export type Body_imageMaxAggregateInputType = {
    id?: true
    background_img1?: true
  }

  export type Body_imageCountAggregateInputType = {
    id?: true
    background_img1?: true
    _all?: true
  }

  export type Body_imageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Body_image to aggregate.
     */
    where?: Body_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Body_images to fetch.
     */
    orderBy?: Body_imageOrderByWithRelationInput | Body_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Body_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Body_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Body_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Body_images
    **/
    _count?: true | Body_imageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Body_imageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Body_imageMaxAggregateInputType
  }

  export type GetBody_imageAggregateType<T extends Body_imageAggregateArgs> = {
        [P in keyof T & keyof AggregateBody_image]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBody_image[P]>
      : GetScalarType<T[P], AggregateBody_image[P]>
  }




  export type Body_imageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Body_imageWhereInput
    orderBy?: Body_imageOrderByWithAggregationInput | Body_imageOrderByWithAggregationInput[]
    by: Body_imageScalarFieldEnum[] | Body_imageScalarFieldEnum
    having?: Body_imageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Body_imageCountAggregateInputType | true
    _min?: Body_imageMinAggregateInputType
    _max?: Body_imageMaxAggregateInputType
  }

  export type Body_imageGroupByOutputType = {
    id: string
    background_img1: string
    _count: Body_imageCountAggregateOutputType | null
    _min: Body_imageMinAggregateOutputType | null
    _max: Body_imageMaxAggregateOutputType | null
  }

  type GetBody_imageGroupByPayload<T extends Body_imageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Body_imageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Body_imageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Body_imageGroupByOutputType[P]>
            : GetScalarType<T[P], Body_imageGroupByOutputType[P]>
        }
      >
    >


  export type Body_imageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    background_img1?: boolean
  }, ExtArgs["result"]["body_image"]>

  export type Body_imageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    background_img1?: boolean
  }, ExtArgs["result"]["body_image"]>

  export type Body_imageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    background_img1?: boolean
  }, ExtArgs["result"]["body_image"]>

  export type Body_imageSelectScalar = {
    id?: boolean
    background_img1?: boolean
  }

  export type Body_imageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "background_img1", ExtArgs["result"]["body_image"]>

  export type $Body_imagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Body_image"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      background_img1: string
    }, ExtArgs["result"]["body_image"]>
    composites: {}
  }

  type Body_imageGetPayload<S extends boolean | null | undefined | Body_imageDefaultArgs> = $Result.GetResult<Prisma.$Body_imagePayload, S>

  type Body_imageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Body_imageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Body_imageCountAggregateInputType | true
    }

  export interface Body_imageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Body_image'], meta: { name: 'Body_image' } }
    /**
     * Find zero or one Body_image that matches the filter.
     * @param {Body_imageFindUniqueArgs} args - Arguments to find a Body_image
     * @example
     * // Get one Body_image
     * const body_image = await prisma.body_image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Body_imageFindUniqueArgs>(args: SelectSubset<T, Body_imageFindUniqueArgs<ExtArgs>>): Prisma__Body_imageClient<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Body_image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Body_imageFindUniqueOrThrowArgs} args - Arguments to find a Body_image
     * @example
     * // Get one Body_image
     * const body_image = await prisma.body_image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Body_imageFindUniqueOrThrowArgs>(args: SelectSubset<T, Body_imageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Body_imageClient<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Body_image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Body_imageFindFirstArgs} args - Arguments to find a Body_image
     * @example
     * // Get one Body_image
     * const body_image = await prisma.body_image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Body_imageFindFirstArgs>(args?: SelectSubset<T, Body_imageFindFirstArgs<ExtArgs>>): Prisma__Body_imageClient<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Body_image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Body_imageFindFirstOrThrowArgs} args - Arguments to find a Body_image
     * @example
     * // Get one Body_image
     * const body_image = await prisma.body_image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Body_imageFindFirstOrThrowArgs>(args?: SelectSubset<T, Body_imageFindFirstOrThrowArgs<ExtArgs>>): Prisma__Body_imageClient<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Body_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Body_imageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Body_images
     * const body_images = await prisma.body_image.findMany()
     * 
     * // Get first 10 Body_images
     * const body_images = await prisma.body_image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const body_imageWithIdOnly = await prisma.body_image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Body_imageFindManyArgs>(args?: SelectSubset<T, Body_imageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Body_image.
     * @param {Body_imageCreateArgs} args - Arguments to create a Body_image.
     * @example
     * // Create one Body_image
     * const Body_image = await prisma.body_image.create({
     *   data: {
     *     // ... data to create a Body_image
     *   }
     * })
     * 
     */
    create<T extends Body_imageCreateArgs>(args: SelectSubset<T, Body_imageCreateArgs<ExtArgs>>): Prisma__Body_imageClient<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Body_images.
     * @param {Body_imageCreateManyArgs} args - Arguments to create many Body_images.
     * @example
     * // Create many Body_images
     * const body_image = await prisma.body_image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Body_imageCreateManyArgs>(args?: SelectSubset<T, Body_imageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Body_images and returns the data saved in the database.
     * @param {Body_imageCreateManyAndReturnArgs} args - Arguments to create many Body_images.
     * @example
     * // Create many Body_images
     * const body_image = await prisma.body_image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Body_images and only return the `id`
     * const body_imageWithIdOnly = await prisma.body_image.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Body_imageCreateManyAndReturnArgs>(args?: SelectSubset<T, Body_imageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Body_image.
     * @param {Body_imageDeleteArgs} args - Arguments to delete one Body_image.
     * @example
     * // Delete one Body_image
     * const Body_image = await prisma.body_image.delete({
     *   where: {
     *     // ... filter to delete one Body_image
     *   }
     * })
     * 
     */
    delete<T extends Body_imageDeleteArgs>(args: SelectSubset<T, Body_imageDeleteArgs<ExtArgs>>): Prisma__Body_imageClient<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Body_image.
     * @param {Body_imageUpdateArgs} args - Arguments to update one Body_image.
     * @example
     * // Update one Body_image
     * const body_image = await prisma.body_image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Body_imageUpdateArgs>(args: SelectSubset<T, Body_imageUpdateArgs<ExtArgs>>): Prisma__Body_imageClient<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Body_images.
     * @param {Body_imageDeleteManyArgs} args - Arguments to filter Body_images to delete.
     * @example
     * // Delete a few Body_images
     * const { count } = await prisma.body_image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Body_imageDeleteManyArgs>(args?: SelectSubset<T, Body_imageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Body_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Body_imageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Body_images
     * const body_image = await prisma.body_image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Body_imageUpdateManyArgs>(args: SelectSubset<T, Body_imageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Body_images and returns the data updated in the database.
     * @param {Body_imageUpdateManyAndReturnArgs} args - Arguments to update many Body_images.
     * @example
     * // Update many Body_images
     * const body_image = await prisma.body_image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Body_images and only return the `id`
     * const body_imageWithIdOnly = await prisma.body_image.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Body_imageUpdateManyAndReturnArgs>(args: SelectSubset<T, Body_imageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Body_image.
     * @param {Body_imageUpsertArgs} args - Arguments to update or create a Body_image.
     * @example
     * // Update or create a Body_image
     * const body_image = await prisma.body_image.upsert({
     *   create: {
     *     // ... data to create a Body_image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Body_image we want to update
     *   }
     * })
     */
    upsert<T extends Body_imageUpsertArgs>(args: SelectSubset<T, Body_imageUpsertArgs<ExtArgs>>): Prisma__Body_imageClient<$Result.GetResult<Prisma.$Body_imagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Body_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Body_imageCountArgs} args - Arguments to filter Body_images to count.
     * @example
     * // Count the number of Body_images
     * const count = await prisma.body_image.count({
     *   where: {
     *     // ... the filter for the Body_images we want to count
     *   }
     * })
    **/
    count<T extends Body_imageCountArgs>(
      args?: Subset<T, Body_imageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Body_imageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Body_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Body_imageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Body_imageAggregateArgs>(args: Subset<T, Body_imageAggregateArgs>): Prisma.PrismaPromise<GetBody_imageAggregateType<T>>

    /**
     * Group by Body_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Body_imageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Body_imageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Body_imageGroupByArgs['orderBy'] }
        : { orderBy?: Body_imageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Body_imageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBody_imageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Body_image model
   */
  readonly fields: Body_imageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Body_image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Body_imageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Body_image model
   */
  interface Body_imageFieldRefs {
    readonly id: FieldRef<"Body_image", 'String'>
    readonly background_img1: FieldRef<"Body_image", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Body_image findUnique
   */
  export type Body_imageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * Filter, which Body_image to fetch.
     */
    where: Body_imageWhereUniqueInput
  }

  /**
   * Body_image findUniqueOrThrow
   */
  export type Body_imageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * Filter, which Body_image to fetch.
     */
    where: Body_imageWhereUniqueInput
  }

  /**
   * Body_image findFirst
   */
  export type Body_imageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * Filter, which Body_image to fetch.
     */
    where?: Body_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Body_images to fetch.
     */
    orderBy?: Body_imageOrderByWithRelationInput | Body_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Body_images.
     */
    cursor?: Body_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Body_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Body_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Body_images.
     */
    distinct?: Body_imageScalarFieldEnum | Body_imageScalarFieldEnum[]
  }

  /**
   * Body_image findFirstOrThrow
   */
  export type Body_imageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * Filter, which Body_image to fetch.
     */
    where?: Body_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Body_images to fetch.
     */
    orderBy?: Body_imageOrderByWithRelationInput | Body_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Body_images.
     */
    cursor?: Body_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Body_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Body_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Body_images.
     */
    distinct?: Body_imageScalarFieldEnum | Body_imageScalarFieldEnum[]
  }

  /**
   * Body_image findMany
   */
  export type Body_imageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * Filter, which Body_images to fetch.
     */
    where?: Body_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Body_images to fetch.
     */
    orderBy?: Body_imageOrderByWithRelationInput | Body_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Body_images.
     */
    cursor?: Body_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Body_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Body_images.
     */
    skip?: number
    distinct?: Body_imageScalarFieldEnum | Body_imageScalarFieldEnum[]
  }

  /**
   * Body_image create
   */
  export type Body_imageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * The data needed to create a Body_image.
     */
    data: XOR<Body_imageCreateInput, Body_imageUncheckedCreateInput>
  }

  /**
   * Body_image createMany
   */
  export type Body_imageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Body_images.
     */
    data: Body_imageCreateManyInput | Body_imageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Body_image createManyAndReturn
   */
  export type Body_imageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * The data used to create many Body_images.
     */
    data: Body_imageCreateManyInput | Body_imageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Body_image update
   */
  export type Body_imageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * The data needed to update a Body_image.
     */
    data: XOR<Body_imageUpdateInput, Body_imageUncheckedUpdateInput>
    /**
     * Choose, which Body_image to update.
     */
    where: Body_imageWhereUniqueInput
  }

  /**
   * Body_image updateMany
   */
  export type Body_imageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Body_images.
     */
    data: XOR<Body_imageUpdateManyMutationInput, Body_imageUncheckedUpdateManyInput>
    /**
     * Filter which Body_images to update
     */
    where?: Body_imageWhereInput
    /**
     * Limit how many Body_images to update.
     */
    limit?: number
  }

  /**
   * Body_image updateManyAndReturn
   */
  export type Body_imageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * The data used to update Body_images.
     */
    data: XOR<Body_imageUpdateManyMutationInput, Body_imageUncheckedUpdateManyInput>
    /**
     * Filter which Body_images to update
     */
    where?: Body_imageWhereInput
    /**
     * Limit how many Body_images to update.
     */
    limit?: number
  }

  /**
   * Body_image upsert
   */
  export type Body_imageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * The filter to search for the Body_image to update in case it exists.
     */
    where: Body_imageWhereUniqueInput
    /**
     * In case the Body_image found by the `where` argument doesn't exist, create a new Body_image with this data.
     */
    create: XOR<Body_imageCreateInput, Body_imageUncheckedCreateInput>
    /**
     * In case the Body_image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Body_imageUpdateInput, Body_imageUncheckedUpdateInput>
  }

  /**
   * Body_image delete
   */
  export type Body_imageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
    /**
     * Filter which Body_image to delete.
     */
    where: Body_imageWhereUniqueInput
  }

  /**
   * Body_image deleteMany
   */
  export type Body_imageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Body_images to delete
     */
    where?: Body_imageWhereInput
    /**
     * Limit how many Body_images to delete.
     */
    limit?: number
  }

  /**
   * Body_image without action
   */
  export type Body_imageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Body_image
     */
    select?: Body_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Body_image
     */
    omit?: Body_imageOmit<ExtArgs> | null
  }


  /**
   * Model Header_main_logo
   */

  export type AggregateHeader_main_logo = {
    _count: Header_main_logoCountAggregateOutputType | null
    _min: Header_main_logoMinAggregateOutputType | null
    _max: Header_main_logoMaxAggregateOutputType | null
  }

  export type Header_main_logoMinAggregateOutputType = {
    id: string | null
    url: string | null
    img_url: string | null
  }

  export type Header_main_logoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    img_url: string | null
  }

  export type Header_main_logoCountAggregateOutputType = {
    id: number
    url: number
    img_url: number
    _all: number
  }


  export type Header_main_logoMinAggregateInputType = {
    id?: true
    url?: true
    img_url?: true
  }

  export type Header_main_logoMaxAggregateInputType = {
    id?: true
    url?: true
    img_url?: true
  }

  export type Header_main_logoCountAggregateInputType = {
    id?: true
    url?: true
    img_url?: true
    _all?: true
  }

  export type Header_main_logoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Header_main_logo to aggregate.
     */
    where?: Header_main_logoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_main_logos to fetch.
     */
    orderBy?: Header_main_logoOrderByWithRelationInput | Header_main_logoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Header_main_logoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_main_logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_main_logos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Header_main_logos
    **/
    _count?: true | Header_main_logoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Header_main_logoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Header_main_logoMaxAggregateInputType
  }

  export type GetHeader_main_logoAggregateType<T extends Header_main_logoAggregateArgs> = {
        [P in keyof T & keyof AggregateHeader_main_logo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeader_main_logo[P]>
      : GetScalarType<T[P], AggregateHeader_main_logo[P]>
  }




  export type Header_main_logoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Header_main_logoWhereInput
    orderBy?: Header_main_logoOrderByWithAggregationInput | Header_main_logoOrderByWithAggregationInput[]
    by: Header_main_logoScalarFieldEnum[] | Header_main_logoScalarFieldEnum
    having?: Header_main_logoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Header_main_logoCountAggregateInputType | true
    _min?: Header_main_logoMinAggregateInputType
    _max?: Header_main_logoMaxAggregateInputType
  }

  export type Header_main_logoGroupByOutputType = {
    id: string
    url: string
    img_url: string
    _count: Header_main_logoCountAggregateOutputType | null
    _min: Header_main_logoMinAggregateOutputType | null
    _max: Header_main_logoMaxAggregateOutputType | null
  }

  type GetHeader_main_logoGroupByPayload<T extends Header_main_logoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Header_main_logoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Header_main_logoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Header_main_logoGroupByOutputType[P]>
            : GetScalarType<T[P], Header_main_logoGroupByOutputType[P]>
        }
      >
    >


  export type Header_main_logoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["header_main_logo"]>

  export type Header_main_logoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["header_main_logo"]>

  export type Header_main_logoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["header_main_logo"]>

  export type Header_main_logoSelectScalar = {
    id?: boolean
    url?: boolean
    img_url?: boolean
  }

  export type Header_main_logoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "img_url", ExtArgs["result"]["header_main_logo"]>

  export type $Header_main_logoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Header_main_logo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      img_url: string
    }, ExtArgs["result"]["header_main_logo"]>
    composites: {}
  }

  type Header_main_logoGetPayload<S extends boolean | null | undefined | Header_main_logoDefaultArgs> = $Result.GetResult<Prisma.$Header_main_logoPayload, S>

  type Header_main_logoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Header_main_logoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Header_main_logoCountAggregateInputType | true
    }

  export interface Header_main_logoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Header_main_logo'], meta: { name: 'Header_main_logo' } }
    /**
     * Find zero or one Header_main_logo that matches the filter.
     * @param {Header_main_logoFindUniqueArgs} args - Arguments to find a Header_main_logo
     * @example
     * // Get one Header_main_logo
     * const header_main_logo = await prisma.header_main_logo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Header_main_logoFindUniqueArgs>(args: SelectSubset<T, Header_main_logoFindUniqueArgs<ExtArgs>>): Prisma__Header_main_logoClient<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Header_main_logo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Header_main_logoFindUniqueOrThrowArgs} args - Arguments to find a Header_main_logo
     * @example
     * // Get one Header_main_logo
     * const header_main_logo = await prisma.header_main_logo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Header_main_logoFindUniqueOrThrowArgs>(args: SelectSubset<T, Header_main_logoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Header_main_logoClient<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Header_main_logo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_main_logoFindFirstArgs} args - Arguments to find a Header_main_logo
     * @example
     * // Get one Header_main_logo
     * const header_main_logo = await prisma.header_main_logo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Header_main_logoFindFirstArgs>(args?: SelectSubset<T, Header_main_logoFindFirstArgs<ExtArgs>>): Prisma__Header_main_logoClient<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Header_main_logo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_main_logoFindFirstOrThrowArgs} args - Arguments to find a Header_main_logo
     * @example
     * // Get one Header_main_logo
     * const header_main_logo = await prisma.header_main_logo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Header_main_logoFindFirstOrThrowArgs>(args?: SelectSubset<T, Header_main_logoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Header_main_logoClient<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Header_main_logos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_main_logoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Header_main_logos
     * const header_main_logos = await prisma.header_main_logo.findMany()
     * 
     * // Get first 10 Header_main_logos
     * const header_main_logos = await prisma.header_main_logo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const header_main_logoWithIdOnly = await prisma.header_main_logo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Header_main_logoFindManyArgs>(args?: SelectSubset<T, Header_main_logoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Header_main_logo.
     * @param {Header_main_logoCreateArgs} args - Arguments to create a Header_main_logo.
     * @example
     * // Create one Header_main_logo
     * const Header_main_logo = await prisma.header_main_logo.create({
     *   data: {
     *     // ... data to create a Header_main_logo
     *   }
     * })
     * 
     */
    create<T extends Header_main_logoCreateArgs>(args: SelectSubset<T, Header_main_logoCreateArgs<ExtArgs>>): Prisma__Header_main_logoClient<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Header_main_logos.
     * @param {Header_main_logoCreateManyArgs} args - Arguments to create many Header_main_logos.
     * @example
     * // Create many Header_main_logos
     * const header_main_logo = await prisma.header_main_logo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Header_main_logoCreateManyArgs>(args?: SelectSubset<T, Header_main_logoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Header_main_logos and returns the data saved in the database.
     * @param {Header_main_logoCreateManyAndReturnArgs} args - Arguments to create many Header_main_logos.
     * @example
     * // Create many Header_main_logos
     * const header_main_logo = await prisma.header_main_logo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Header_main_logos and only return the `id`
     * const header_main_logoWithIdOnly = await prisma.header_main_logo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Header_main_logoCreateManyAndReturnArgs>(args?: SelectSubset<T, Header_main_logoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Header_main_logo.
     * @param {Header_main_logoDeleteArgs} args - Arguments to delete one Header_main_logo.
     * @example
     * // Delete one Header_main_logo
     * const Header_main_logo = await prisma.header_main_logo.delete({
     *   where: {
     *     // ... filter to delete one Header_main_logo
     *   }
     * })
     * 
     */
    delete<T extends Header_main_logoDeleteArgs>(args: SelectSubset<T, Header_main_logoDeleteArgs<ExtArgs>>): Prisma__Header_main_logoClient<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Header_main_logo.
     * @param {Header_main_logoUpdateArgs} args - Arguments to update one Header_main_logo.
     * @example
     * // Update one Header_main_logo
     * const header_main_logo = await prisma.header_main_logo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Header_main_logoUpdateArgs>(args: SelectSubset<T, Header_main_logoUpdateArgs<ExtArgs>>): Prisma__Header_main_logoClient<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Header_main_logos.
     * @param {Header_main_logoDeleteManyArgs} args - Arguments to filter Header_main_logos to delete.
     * @example
     * // Delete a few Header_main_logos
     * const { count } = await prisma.header_main_logo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Header_main_logoDeleteManyArgs>(args?: SelectSubset<T, Header_main_logoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Header_main_logos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_main_logoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Header_main_logos
     * const header_main_logo = await prisma.header_main_logo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Header_main_logoUpdateManyArgs>(args: SelectSubset<T, Header_main_logoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Header_main_logos and returns the data updated in the database.
     * @param {Header_main_logoUpdateManyAndReturnArgs} args - Arguments to update many Header_main_logos.
     * @example
     * // Update many Header_main_logos
     * const header_main_logo = await prisma.header_main_logo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Header_main_logos and only return the `id`
     * const header_main_logoWithIdOnly = await prisma.header_main_logo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Header_main_logoUpdateManyAndReturnArgs>(args: SelectSubset<T, Header_main_logoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Header_main_logo.
     * @param {Header_main_logoUpsertArgs} args - Arguments to update or create a Header_main_logo.
     * @example
     * // Update or create a Header_main_logo
     * const header_main_logo = await prisma.header_main_logo.upsert({
     *   create: {
     *     // ... data to create a Header_main_logo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Header_main_logo we want to update
     *   }
     * })
     */
    upsert<T extends Header_main_logoUpsertArgs>(args: SelectSubset<T, Header_main_logoUpsertArgs<ExtArgs>>): Prisma__Header_main_logoClient<$Result.GetResult<Prisma.$Header_main_logoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Header_main_logos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_main_logoCountArgs} args - Arguments to filter Header_main_logos to count.
     * @example
     * // Count the number of Header_main_logos
     * const count = await prisma.header_main_logo.count({
     *   where: {
     *     // ... the filter for the Header_main_logos we want to count
     *   }
     * })
    **/
    count<T extends Header_main_logoCountArgs>(
      args?: Subset<T, Header_main_logoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Header_main_logoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Header_main_logo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_main_logoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Header_main_logoAggregateArgs>(args: Subset<T, Header_main_logoAggregateArgs>): Prisma.PrismaPromise<GetHeader_main_logoAggregateType<T>>

    /**
     * Group by Header_main_logo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_main_logoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Header_main_logoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Header_main_logoGroupByArgs['orderBy'] }
        : { orderBy?: Header_main_logoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Header_main_logoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeader_main_logoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Header_main_logo model
   */
  readonly fields: Header_main_logoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Header_main_logo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Header_main_logoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Header_main_logo model
   */
  interface Header_main_logoFieldRefs {
    readonly id: FieldRef<"Header_main_logo", 'String'>
    readonly url: FieldRef<"Header_main_logo", 'String'>
    readonly img_url: FieldRef<"Header_main_logo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Header_main_logo findUnique
   */
  export type Header_main_logoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * Filter, which Header_main_logo to fetch.
     */
    where: Header_main_logoWhereUniqueInput
  }

  /**
   * Header_main_logo findUniqueOrThrow
   */
  export type Header_main_logoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * Filter, which Header_main_logo to fetch.
     */
    where: Header_main_logoWhereUniqueInput
  }

  /**
   * Header_main_logo findFirst
   */
  export type Header_main_logoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * Filter, which Header_main_logo to fetch.
     */
    where?: Header_main_logoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_main_logos to fetch.
     */
    orderBy?: Header_main_logoOrderByWithRelationInput | Header_main_logoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Header_main_logos.
     */
    cursor?: Header_main_logoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_main_logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_main_logos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Header_main_logos.
     */
    distinct?: Header_main_logoScalarFieldEnum | Header_main_logoScalarFieldEnum[]
  }

  /**
   * Header_main_logo findFirstOrThrow
   */
  export type Header_main_logoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * Filter, which Header_main_logo to fetch.
     */
    where?: Header_main_logoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_main_logos to fetch.
     */
    orderBy?: Header_main_logoOrderByWithRelationInput | Header_main_logoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Header_main_logos.
     */
    cursor?: Header_main_logoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_main_logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_main_logos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Header_main_logos.
     */
    distinct?: Header_main_logoScalarFieldEnum | Header_main_logoScalarFieldEnum[]
  }

  /**
   * Header_main_logo findMany
   */
  export type Header_main_logoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * Filter, which Header_main_logos to fetch.
     */
    where?: Header_main_logoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_main_logos to fetch.
     */
    orderBy?: Header_main_logoOrderByWithRelationInput | Header_main_logoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Header_main_logos.
     */
    cursor?: Header_main_logoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_main_logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_main_logos.
     */
    skip?: number
    distinct?: Header_main_logoScalarFieldEnum | Header_main_logoScalarFieldEnum[]
  }

  /**
   * Header_main_logo create
   */
  export type Header_main_logoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * The data needed to create a Header_main_logo.
     */
    data: XOR<Header_main_logoCreateInput, Header_main_logoUncheckedCreateInput>
  }

  /**
   * Header_main_logo createMany
   */
  export type Header_main_logoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Header_main_logos.
     */
    data: Header_main_logoCreateManyInput | Header_main_logoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Header_main_logo createManyAndReturn
   */
  export type Header_main_logoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * The data used to create many Header_main_logos.
     */
    data: Header_main_logoCreateManyInput | Header_main_logoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Header_main_logo update
   */
  export type Header_main_logoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * The data needed to update a Header_main_logo.
     */
    data: XOR<Header_main_logoUpdateInput, Header_main_logoUncheckedUpdateInput>
    /**
     * Choose, which Header_main_logo to update.
     */
    where: Header_main_logoWhereUniqueInput
  }

  /**
   * Header_main_logo updateMany
   */
  export type Header_main_logoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Header_main_logos.
     */
    data: XOR<Header_main_logoUpdateManyMutationInput, Header_main_logoUncheckedUpdateManyInput>
    /**
     * Filter which Header_main_logos to update
     */
    where?: Header_main_logoWhereInput
    /**
     * Limit how many Header_main_logos to update.
     */
    limit?: number
  }

  /**
   * Header_main_logo updateManyAndReturn
   */
  export type Header_main_logoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * The data used to update Header_main_logos.
     */
    data: XOR<Header_main_logoUpdateManyMutationInput, Header_main_logoUncheckedUpdateManyInput>
    /**
     * Filter which Header_main_logos to update
     */
    where?: Header_main_logoWhereInput
    /**
     * Limit how many Header_main_logos to update.
     */
    limit?: number
  }

  /**
   * Header_main_logo upsert
   */
  export type Header_main_logoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * The filter to search for the Header_main_logo to update in case it exists.
     */
    where: Header_main_logoWhereUniqueInput
    /**
     * In case the Header_main_logo found by the `where` argument doesn't exist, create a new Header_main_logo with this data.
     */
    create: XOR<Header_main_logoCreateInput, Header_main_logoUncheckedCreateInput>
    /**
     * In case the Header_main_logo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Header_main_logoUpdateInput, Header_main_logoUncheckedUpdateInput>
  }

  /**
   * Header_main_logo delete
   */
  export type Header_main_logoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
    /**
     * Filter which Header_main_logo to delete.
     */
    where: Header_main_logoWhereUniqueInput
  }

  /**
   * Header_main_logo deleteMany
   */
  export type Header_main_logoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Header_main_logos to delete
     */
    where?: Header_main_logoWhereInput
    /**
     * Limit how many Header_main_logos to delete.
     */
    limit?: number
  }

  /**
   * Header_main_logo without action
   */
  export type Header_main_logoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_main_logo
     */
    select?: Header_main_logoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_main_logo
     */
    omit?: Header_main_logoOmit<ExtArgs> | null
  }


  /**
   * Model Header_navbar
   */

  export type AggregateHeader_navbar = {
    _count: Header_navbarCountAggregateOutputType | null
    _min: Header_navbarMinAggregateOutputType | null
    _max: Header_navbarMaxAggregateOutputType | null
  }

  export type Header_navbarMinAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    route: string | null
    url: string | null
  }

  export type Header_navbarMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    route: string | null
    url: string | null
  }

  export type Header_navbarCountAggregateOutputType = {
    id: number
    lang: number
    title: number
    route: number
    url: number
    _all: number
  }


  export type Header_navbarMinAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    route?: true
    url?: true
  }

  export type Header_navbarMaxAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    route?: true
    url?: true
  }

  export type Header_navbarCountAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    route?: true
    url?: true
    _all?: true
  }

  export type Header_navbarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Header_navbar to aggregate.
     */
    where?: Header_navbarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_navbars to fetch.
     */
    orderBy?: Header_navbarOrderByWithRelationInput | Header_navbarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Header_navbarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_navbars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_navbars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Header_navbars
    **/
    _count?: true | Header_navbarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Header_navbarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Header_navbarMaxAggregateInputType
  }

  export type GetHeader_navbarAggregateType<T extends Header_navbarAggregateArgs> = {
        [P in keyof T & keyof AggregateHeader_navbar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeader_navbar[P]>
      : GetScalarType<T[P], AggregateHeader_navbar[P]>
  }




  export type Header_navbarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Header_navbarWhereInput
    orderBy?: Header_navbarOrderByWithAggregationInput | Header_navbarOrderByWithAggregationInput[]
    by: Header_navbarScalarFieldEnum[] | Header_navbarScalarFieldEnum
    having?: Header_navbarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Header_navbarCountAggregateInputType | true
    _min?: Header_navbarMinAggregateInputType
    _max?: Header_navbarMaxAggregateInputType
  }

  export type Header_navbarGroupByOutputType = {
    id: string
    lang: string
    title: string
    route: string
    url: string
    _count: Header_navbarCountAggregateOutputType | null
    _min: Header_navbarMinAggregateOutputType | null
    _max: Header_navbarMaxAggregateOutputType | null
  }

  type GetHeader_navbarGroupByPayload<T extends Header_navbarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Header_navbarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Header_navbarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Header_navbarGroupByOutputType[P]>
            : GetScalarType<T[P], Header_navbarGroupByOutputType[P]>
        }
      >
    >


  export type Header_navbarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    route?: boolean
    url?: boolean
  }, ExtArgs["result"]["header_navbar"]>

  export type Header_navbarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    route?: boolean
    url?: boolean
  }, ExtArgs["result"]["header_navbar"]>

  export type Header_navbarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    route?: boolean
    url?: boolean
  }, ExtArgs["result"]["header_navbar"]>

  export type Header_navbarSelectScalar = {
    id?: boolean
    lang?: boolean
    title?: boolean
    route?: boolean
    url?: boolean
  }

  export type Header_navbarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "title" | "route" | "url", ExtArgs["result"]["header_navbar"]>

  export type $Header_navbarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Header_navbar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      title: string
      route: string
      url: string
    }, ExtArgs["result"]["header_navbar"]>
    composites: {}
  }

  type Header_navbarGetPayload<S extends boolean | null | undefined | Header_navbarDefaultArgs> = $Result.GetResult<Prisma.$Header_navbarPayload, S>

  type Header_navbarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Header_navbarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Header_navbarCountAggregateInputType | true
    }

  export interface Header_navbarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Header_navbar'], meta: { name: 'Header_navbar' } }
    /**
     * Find zero or one Header_navbar that matches the filter.
     * @param {Header_navbarFindUniqueArgs} args - Arguments to find a Header_navbar
     * @example
     * // Get one Header_navbar
     * const header_navbar = await prisma.header_navbar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Header_navbarFindUniqueArgs>(args: SelectSubset<T, Header_navbarFindUniqueArgs<ExtArgs>>): Prisma__Header_navbarClient<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Header_navbar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Header_navbarFindUniqueOrThrowArgs} args - Arguments to find a Header_navbar
     * @example
     * // Get one Header_navbar
     * const header_navbar = await prisma.header_navbar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Header_navbarFindUniqueOrThrowArgs>(args: SelectSubset<T, Header_navbarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Header_navbarClient<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Header_navbar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_navbarFindFirstArgs} args - Arguments to find a Header_navbar
     * @example
     * // Get one Header_navbar
     * const header_navbar = await prisma.header_navbar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Header_navbarFindFirstArgs>(args?: SelectSubset<T, Header_navbarFindFirstArgs<ExtArgs>>): Prisma__Header_navbarClient<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Header_navbar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_navbarFindFirstOrThrowArgs} args - Arguments to find a Header_navbar
     * @example
     * // Get one Header_navbar
     * const header_navbar = await prisma.header_navbar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Header_navbarFindFirstOrThrowArgs>(args?: SelectSubset<T, Header_navbarFindFirstOrThrowArgs<ExtArgs>>): Prisma__Header_navbarClient<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Header_navbars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_navbarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Header_navbars
     * const header_navbars = await prisma.header_navbar.findMany()
     * 
     * // Get first 10 Header_navbars
     * const header_navbars = await prisma.header_navbar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const header_navbarWithIdOnly = await prisma.header_navbar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Header_navbarFindManyArgs>(args?: SelectSubset<T, Header_navbarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Header_navbar.
     * @param {Header_navbarCreateArgs} args - Arguments to create a Header_navbar.
     * @example
     * // Create one Header_navbar
     * const Header_navbar = await prisma.header_navbar.create({
     *   data: {
     *     // ... data to create a Header_navbar
     *   }
     * })
     * 
     */
    create<T extends Header_navbarCreateArgs>(args: SelectSubset<T, Header_navbarCreateArgs<ExtArgs>>): Prisma__Header_navbarClient<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Header_navbars.
     * @param {Header_navbarCreateManyArgs} args - Arguments to create many Header_navbars.
     * @example
     * // Create many Header_navbars
     * const header_navbar = await prisma.header_navbar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Header_navbarCreateManyArgs>(args?: SelectSubset<T, Header_navbarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Header_navbars and returns the data saved in the database.
     * @param {Header_navbarCreateManyAndReturnArgs} args - Arguments to create many Header_navbars.
     * @example
     * // Create many Header_navbars
     * const header_navbar = await prisma.header_navbar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Header_navbars and only return the `id`
     * const header_navbarWithIdOnly = await prisma.header_navbar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Header_navbarCreateManyAndReturnArgs>(args?: SelectSubset<T, Header_navbarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Header_navbar.
     * @param {Header_navbarDeleteArgs} args - Arguments to delete one Header_navbar.
     * @example
     * // Delete one Header_navbar
     * const Header_navbar = await prisma.header_navbar.delete({
     *   where: {
     *     // ... filter to delete one Header_navbar
     *   }
     * })
     * 
     */
    delete<T extends Header_navbarDeleteArgs>(args: SelectSubset<T, Header_navbarDeleteArgs<ExtArgs>>): Prisma__Header_navbarClient<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Header_navbar.
     * @param {Header_navbarUpdateArgs} args - Arguments to update one Header_navbar.
     * @example
     * // Update one Header_navbar
     * const header_navbar = await prisma.header_navbar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Header_navbarUpdateArgs>(args: SelectSubset<T, Header_navbarUpdateArgs<ExtArgs>>): Prisma__Header_navbarClient<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Header_navbars.
     * @param {Header_navbarDeleteManyArgs} args - Arguments to filter Header_navbars to delete.
     * @example
     * // Delete a few Header_navbars
     * const { count } = await prisma.header_navbar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Header_navbarDeleteManyArgs>(args?: SelectSubset<T, Header_navbarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Header_navbars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_navbarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Header_navbars
     * const header_navbar = await prisma.header_navbar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Header_navbarUpdateManyArgs>(args: SelectSubset<T, Header_navbarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Header_navbars and returns the data updated in the database.
     * @param {Header_navbarUpdateManyAndReturnArgs} args - Arguments to update many Header_navbars.
     * @example
     * // Update many Header_navbars
     * const header_navbar = await prisma.header_navbar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Header_navbars and only return the `id`
     * const header_navbarWithIdOnly = await prisma.header_navbar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Header_navbarUpdateManyAndReturnArgs>(args: SelectSubset<T, Header_navbarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Header_navbar.
     * @param {Header_navbarUpsertArgs} args - Arguments to update or create a Header_navbar.
     * @example
     * // Update or create a Header_navbar
     * const header_navbar = await prisma.header_navbar.upsert({
     *   create: {
     *     // ... data to create a Header_navbar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Header_navbar we want to update
     *   }
     * })
     */
    upsert<T extends Header_navbarUpsertArgs>(args: SelectSubset<T, Header_navbarUpsertArgs<ExtArgs>>): Prisma__Header_navbarClient<$Result.GetResult<Prisma.$Header_navbarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Header_navbars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_navbarCountArgs} args - Arguments to filter Header_navbars to count.
     * @example
     * // Count the number of Header_navbars
     * const count = await prisma.header_navbar.count({
     *   where: {
     *     // ... the filter for the Header_navbars we want to count
     *   }
     * })
    **/
    count<T extends Header_navbarCountArgs>(
      args?: Subset<T, Header_navbarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Header_navbarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Header_navbar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_navbarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Header_navbarAggregateArgs>(args: Subset<T, Header_navbarAggregateArgs>): Prisma.PrismaPromise<GetHeader_navbarAggregateType<T>>

    /**
     * Group by Header_navbar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_navbarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Header_navbarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Header_navbarGroupByArgs['orderBy'] }
        : { orderBy?: Header_navbarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Header_navbarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeader_navbarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Header_navbar model
   */
  readonly fields: Header_navbarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Header_navbar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Header_navbarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Header_navbar model
   */
  interface Header_navbarFieldRefs {
    readonly id: FieldRef<"Header_navbar", 'String'>
    readonly lang: FieldRef<"Header_navbar", 'String'>
    readonly title: FieldRef<"Header_navbar", 'String'>
    readonly route: FieldRef<"Header_navbar", 'String'>
    readonly url: FieldRef<"Header_navbar", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Header_navbar findUnique
   */
  export type Header_navbarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * Filter, which Header_navbar to fetch.
     */
    where: Header_navbarWhereUniqueInput
  }

  /**
   * Header_navbar findUniqueOrThrow
   */
  export type Header_navbarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * Filter, which Header_navbar to fetch.
     */
    where: Header_navbarWhereUniqueInput
  }

  /**
   * Header_navbar findFirst
   */
  export type Header_navbarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * Filter, which Header_navbar to fetch.
     */
    where?: Header_navbarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_navbars to fetch.
     */
    orderBy?: Header_navbarOrderByWithRelationInput | Header_navbarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Header_navbars.
     */
    cursor?: Header_navbarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_navbars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_navbars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Header_navbars.
     */
    distinct?: Header_navbarScalarFieldEnum | Header_navbarScalarFieldEnum[]
  }

  /**
   * Header_navbar findFirstOrThrow
   */
  export type Header_navbarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * Filter, which Header_navbar to fetch.
     */
    where?: Header_navbarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_navbars to fetch.
     */
    orderBy?: Header_navbarOrderByWithRelationInput | Header_navbarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Header_navbars.
     */
    cursor?: Header_navbarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_navbars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_navbars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Header_navbars.
     */
    distinct?: Header_navbarScalarFieldEnum | Header_navbarScalarFieldEnum[]
  }

  /**
   * Header_navbar findMany
   */
  export type Header_navbarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * Filter, which Header_navbars to fetch.
     */
    where?: Header_navbarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_navbars to fetch.
     */
    orderBy?: Header_navbarOrderByWithRelationInput | Header_navbarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Header_navbars.
     */
    cursor?: Header_navbarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_navbars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_navbars.
     */
    skip?: number
    distinct?: Header_navbarScalarFieldEnum | Header_navbarScalarFieldEnum[]
  }

  /**
   * Header_navbar create
   */
  export type Header_navbarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * The data needed to create a Header_navbar.
     */
    data: XOR<Header_navbarCreateInput, Header_navbarUncheckedCreateInput>
  }

  /**
   * Header_navbar createMany
   */
  export type Header_navbarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Header_navbars.
     */
    data: Header_navbarCreateManyInput | Header_navbarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Header_navbar createManyAndReturn
   */
  export type Header_navbarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * The data used to create many Header_navbars.
     */
    data: Header_navbarCreateManyInput | Header_navbarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Header_navbar update
   */
  export type Header_navbarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * The data needed to update a Header_navbar.
     */
    data: XOR<Header_navbarUpdateInput, Header_navbarUncheckedUpdateInput>
    /**
     * Choose, which Header_navbar to update.
     */
    where: Header_navbarWhereUniqueInput
  }

  /**
   * Header_navbar updateMany
   */
  export type Header_navbarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Header_navbars.
     */
    data: XOR<Header_navbarUpdateManyMutationInput, Header_navbarUncheckedUpdateManyInput>
    /**
     * Filter which Header_navbars to update
     */
    where?: Header_navbarWhereInput
    /**
     * Limit how many Header_navbars to update.
     */
    limit?: number
  }

  /**
   * Header_navbar updateManyAndReturn
   */
  export type Header_navbarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * The data used to update Header_navbars.
     */
    data: XOR<Header_navbarUpdateManyMutationInput, Header_navbarUncheckedUpdateManyInput>
    /**
     * Filter which Header_navbars to update
     */
    where?: Header_navbarWhereInput
    /**
     * Limit how many Header_navbars to update.
     */
    limit?: number
  }

  /**
   * Header_navbar upsert
   */
  export type Header_navbarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * The filter to search for the Header_navbar to update in case it exists.
     */
    where: Header_navbarWhereUniqueInput
    /**
     * In case the Header_navbar found by the `where` argument doesn't exist, create a new Header_navbar with this data.
     */
    create: XOR<Header_navbarCreateInput, Header_navbarUncheckedCreateInput>
    /**
     * In case the Header_navbar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Header_navbarUpdateInput, Header_navbarUncheckedUpdateInput>
  }

  /**
   * Header_navbar delete
   */
  export type Header_navbarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
    /**
     * Filter which Header_navbar to delete.
     */
    where: Header_navbarWhereUniqueInput
  }

  /**
   * Header_navbar deleteMany
   */
  export type Header_navbarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Header_navbars to delete
     */
    where?: Header_navbarWhereInput
    /**
     * Limit how many Header_navbars to delete.
     */
    limit?: number
  }

  /**
   * Header_navbar without action
   */
  export type Header_navbarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_navbar
     */
    select?: Header_navbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_navbar
     */
    omit?: Header_navbarOmit<ExtArgs> | null
  }


  /**
   * Model Header_language
   */

  export type AggregateHeader_language = {
    _count: Header_languageCountAggregateOutputType | null
    _min: Header_languageMinAggregateOutputType | null
    _max: Header_languageMaxAggregateOutputType | null
  }

  export type Header_languageMinAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
  }

  export type Header_languageMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
  }

  export type Header_languageCountAggregateOutputType = {
    id: number
    lang: number
    title: number
    _all: number
  }


  export type Header_languageMinAggregateInputType = {
    id?: true
    lang?: true
    title?: true
  }

  export type Header_languageMaxAggregateInputType = {
    id?: true
    lang?: true
    title?: true
  }

  export type Header_languageCountAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    _all?: true
  }

  export type Header_languageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Header_language to aggregate.
     */
    where?: Header_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_languages to fetch.
     */
    orderBy?: Header_languageOrderByWithRelationInput | Header_languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Header_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Header_languages
    **/
    _count?: true | Header_languageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Header_languageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Header_languageMaxAggregateInputType
  }

  export type GetHeader_languageAggregateType<T extends Header_languageAggregateArgs> = {
        [P in keyof T & keyof AggregateHeader_language]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeader_language[P]>
      : GetScalarType<T[P], AggregateHeader_language[P]>
  }




  export type Header_languageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Header_languageWhereInput
    orderBy?: Header_languageOrderByWithAggregationInput | Header_languageOrderByWithAggregationInput[]
    by: Header_languageScalarFieldEnum[] | Header_languageScalarFieldEnum
    having?: Header_languageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Header_languageCountAggregateInputType | true
    _min?: Header_languageMinAggregateInputType
    _max?: Header_languageMaxAggregateInputType
  }

  export type Header_languageGroupByOutputType = {
    id: string
    lang: string
    title: string
    _count: Header_languageCountAggregateOutputType | null
    _min: Header_languageMinAggregateOutputType | null
    _max: Header_languageMaxAggregateOutputType | null
  }

  type GetHeader_languageGroupByPayload<T extends Header_languageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Header_languageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Header_languageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Header_languageGroupByOutputType[P]>
            : GetScalarType<T[P], Header_languageGroupByOutputType[P]>
        }
      >
    >


  export type Header_languageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
  }, ExtArgs["result"]["header_language"]>

  export type Header_languageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
  }, ExtArgs["result"]["header_language"]>

  export type Header_languageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
  }, ExtArgs["result"]["header_language"]>

  export type Header_languageSelectScalar = {
    id?: boolean
    lang?: boolean
    title?: boolean
  }

  export type Header_languageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "title", ExtArgs["result"]["header_language"]>

  export type $Header_languagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Header_language"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      title: string
    }, ExtArgs["result"]["header_language"]>
    composites: {}
  }

  type Header_languageGetPayload<S extends boolean | null | undefined | Header_languageDefaultArgs> = $Result.GetResult<Prisma.$Header_languagePayload, S>

  type Header_languageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Header_languageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Header_languageCountAggregateInputType | true
    }

  export interface Header_languageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Header_language'], meta: { name: 'Header_language' } }
    /**
     * Find zero or one Header_language that matches the filter.
     * @param {Header_languageFindUniqueArgs} args - Arguments to find a Header_language
     * @example
     * // Get one Header_language
     * const header_language = await prisma.header_language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Header_languageFindUniqueArgs>(args: SelectSubset<T, Header_languageFindUniqueArgs<ExtArgs>>): Prisma__Header_languageClient<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Header_language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Header_languageFindUniqueOrThrowArgs} args - Arguments to find a Header_language
     * @example
     * // Get one Header_language
     * const header_language = await prisma.header_language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Header_languageFindUniqueOrThrowArgs>(args: SelectSubset<T, Header_languageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Header_languageClient<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Header_language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_languageFindFirstArgs} args - Arguments to find a Header_language
     * @example
     * // Get one Header_language
     * const header_language = await prisma.header_language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Header_languageFindFirstArgs>(args?: SelectSubset<T, Header_languageFindFirstArgs<ExtArgs>>): Prisma__Header_languageClient<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Header_language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_languageFindFirstOrThrowArgs} args - Arguments to find a Header_language
     * @example
     * // Get one Header_language
     * const header_language = await prisma.header_language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Header_languageFindFirstOrThrowArgs>(args?: SelectSubset<T, Header_languageFindFirstOrThrowArgs<ExtArgs>>): Prisma__Header_languageClient<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Header_languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_languageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Header_languages
     * const header_languages = await prisma.header_language.findMany()
     * 
     * // Get first 10 Header_languages
     * const header_languages = await prisma.header_language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const header_languageWithIdOnly = await prisma.header_language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Header_languageFindManyArgs>(args?: SelectSubset<T, Header_languageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Header_language.
     * @param {Header_languageCreateArgs} args - Arguments to create a Header_language.
     * @example
     * // Create one Header_language
     * const Header_language = await prisma.header_language.create({
     *   data: {
     *     // ... data to create a Header_language
     *   }
     * })
     * 
     */
    create<T extends Header_languageCreateArgs>(args: SelectSubset<T, Header_languageCreateArgs<ExtArgs>>): Prisma__Header_languageClient<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Header_languages.
     * @param {Header_languageCreateManyArgs} args - Arguments to create many Header_languages.
     * @example
     * // Create many Header_languages
     * const header_language = await prisma.header_language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Header_languageCreateManyArgs>(args?: SelectSubset<T, Header_languageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Header_languages and returns the data saved in the database.
     * @param {Header_languageCreateManyAndReturnArgs} args - Arguments to create many Header_languages.
     * @example
     * // Create many Header_languages
     * const header_language = await prisma.header_language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Header_languages and only return the `id`
     * const header_languageWithIdOnly = await prisma.header_language.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Header_languageCreateManyAndReturnArgs>(args?: SelectSubset<T, Header_languageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Header_language.
     * @param {Header_languageDeleteArgs} args - Arguments to delete one Header_language.
     * @example
     * // Delete one Header_language
     * const Header_language = await prisma.header_language.delete({
     *   where: {
     *     // ... filter to delete one Header_language
     *   }
     * })
     * 
     */
    delete<T extends Header_languageDeleteArgs>(args: SelectSubset<T, Header_languageDeleteArgs<ExtArgs>>): Prisma__Header_languageClient<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Header_language.
     * @param {Header_languageUpdateArgs} args - Arguments to update one Header_language.
     * @example
     * // Update one Header_language
     * const header_language = await prisma.header_language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Header_languageUpdateArgs>(args: SelectSubset<T, Header_languageUpdateArgs<ExtArgs>>): Prisma__Header_languageClient<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Header_languages.
     * @param {Header_languageDeleteManyArgs} args - Arguments to filter Header_languages to delete.
     * @example
     * // Delete a few Header_languages
     * const { count } = await prisma.header_language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Header_languageDeleteManyArgs>(args?: SelectSubset<T, Header_languageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Header_languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_languageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Header_languages
     * const header_language = await prisma.header_language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Header_languageUpdateManyArgs>(args: SelectSubset<T, Header_languageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Header_languages and returns the data updated in the database.
     * @param {Header_languageUpdateManyAndReturnArgs} args - Arguments to update many Header_languages.
     * @example
     * // Update many Header_languages
     * const header_language = await prisma.header_language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Header_languages and only return the `id`
     * const header_languageWithIdOnly = await prisma.header_language.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Header_languageUpdateManyAndReturnArgs>(args: SelectSubset<T, Header_languageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Header_language.
     * @param {Header_languageUpsertArgs} args - Arguments to update or create a Header_language.
     * @example
     * // Update or create a Header_language
     * const header_language = await prisma.header_language.upsert({
     *   create: {
     *     // ... data to create a Header_language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Header_language we want to update
     *   }
     * })
     */
    upsert<T extends Header_languageUpsertArgs>(args: SelectSubset<T, Header_languageUpsertArgs<ExtArgs>>): Prisma__Header_languageClient<$Result.GetResult<Prisma.$Header_languagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Header_languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_languageCountArgs} args - Arguments to filter Header_languages to count.
     * @example
     * // Count the number of Header_languages
     * const count = await prisma.header_language.count({
     *   where: {
     *     // ... the filter for the Header_languages we want to count
     *   }
     * })
    **/
    count<T extends Header_languageCountArgs>(
      args?: Subset<T, Header_languageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Header_languageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Header_language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_languageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Header_languageAggregateArgs>(args: Subset<T, Header_languageAggregateArgs>): Prisma.PrismaPromise<GetHeader_languageAggregateType<T>>

    /**
     * Group by Header_language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Header_languageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Header_languageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Header_languageGroupByArgs['orderBy'] }
        : { orderBy?: Header_languageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Header_languageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeader_languageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Header_language model
   */
  readonly fields: Header_languageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Header_language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Header_languageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Header_language model
   */
  interface Header_languageFieldRefs {
    readonly id: FieldRef<"Header_language", 'String'>
    readonly lang: FieldRef<"Header_language", 'String'>
    readonly title: FieldRef<"Header_language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Header_language findUnique
   */
  export type Header_languageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * Filter, which Header_language to fetch.
     */
    where: Header_languageWhereUniqueInput
  }

  /**
   * Header_language findUniqueOrThrow
   */
  export type Header_languageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * Filter, which Header_language to fetch.
     */
    where: Header_languageWhereUniqueInput
  }

  /**
   * Header_language findFirst
   */
  export type Header_languageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * Filter, which Header_language to fetch.
     */
    where?: Header_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_languages to fetch.
     */
    orderBy?: Header_languageOrderByWithRelationInput | Header_languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Header_languages.
     */
    cursor?: Header_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Header_languages.
     */
    distinct?: Header_languageScalarFieldEnum | Header_languageScalarFieldEnum[]
  }

  /**
   * Header_language findFirstOrThrow
   */
  export type Header_languageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * Filter, which Header_language to fetch.
     */
    where?: Header_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_languages to fetch.
     */
    orderBy?: Header_languageOrderByWithRelationInput | Header_languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Header_languages.
     */
    cursor?: Header_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Header_languages.
     */
    distinct?: Header_languageScalarFieldEnum | Header_languageScalarFieldEnum[]
  }

  /**
   * Header_language findMany
   */
  export type Header_languageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * Filter, which Header_languages to fetch.
     */
    where?: Header_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Header_languages to fetch.
     */
    orderBy?: Header_languageOrderByWithRelationInput | Header_languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Header_languages.
     */
    cursor?: Header_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Header_languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Header_languages.
     */
    skip?: number
    distinct?: Header_languageScalarFieldEnum | Header_languageScalarFieldEnum[]
  }

  /**
   * Header_language create
   */
  export type Header_languageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * The data needed to create a Header_language.
     */
    data: XOR<Header_languageCreateInput, Header_languageUncheckedCreateInput>
  }

  /**
   * Header_language createMany
   */
  export type Header_languageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Header_languages.
     */
    data: Header_languageCreateManyInput | Header_languageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Header_language createManyAndReturn
   */
  export type Header_languageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * The data used to create many Header_languages.
     */
    data: Header_languageCreateManyInput | Header_languageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Header_language update
   */
  export type Header_languageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * The data needed to update a Header_language.
     */
    data: XOR<Header_languageUpdateInput, Header_languageUncheckedUpdateInput>
    /**
     * Choose, which Header_language to update.
     */
    where: Header_languageWhereUniqueInput
  }

  /**
   * Header_language updateMany
   */
  export type Header_languageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Header_languages.
     */
    data: XOR<Header_languageUpdateManyMutationInput, Header_languageUncheckedUpdateManyInput>
    /**
     * Filter which Header_languages to update
     */
    where?: Header_languageWhereInput
    /**
     * Limit how many Header_languages to update.
     */
    limit?: number
  }

  /**
   * Header_language updateManyAndReturn
   */
  export type Header_languageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * The data used to update Header_languages.
     */
    data: XOR<Header_languageUpdateManyMutationInput, Header_languageUncheckedUpdateManyInput>
    /**
     * Filter which Header_languages to update
     */
    where?: Header_languageWhereInput
    /**
     * Limit how many Header_languages to update.
     */
    limit?: number
  }

  /**
   * Header_language upsert
   */
  export type Header_languageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * The filter to search for the Header_language to update in case it exists.
     */
    where: Header_languageWhereUniqueInput
    /**
     * In case the Header_language found by the `where` argument doesn't exist, create a new Header_language with this data.
     */
    create: XOR<Header_languageCreateInput, Header_languageUncheckedCreateInput>
    /**
     * In case the Header_language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Header_languageUpdateInput, Header_languageUncheckedUpdateInput>
  }

  /**
   * Header_language delete
   */
  export type Header_languageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
    /**
     * Filter which Header_language to delete.
     */
    where: Header_languageWhereUniqueInput
  }

  /**
   * Header_language deleteMany
   */
  export type Header_languageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Header_languages to delete
     */
    where?: Header_languageWhereInput
    /**
     * Limit how many Header_languages to delete.
     */
    limit?: number
  }

  /**
   * Header_language without action
   */
  export type Header_languageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Header_language
     */
    select?: Header_languageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Header_language
     */
    omit?: Header_languageOmit<ExtArgs> | null
  }


  /**
   * Model Home_intro
   */

  export type AggregateHome_intro = {
    _count: Home_introCountAggregateOutputType | null
    _min: Home_introMinAggregateOutputType | null
    _max: Home_introMaxAggregateOutputType | null
  }

  export type Home_introMinAggregateOutputType = {
    id: string | null
    lang: string | null
    videoUrl: string | null
    mainHeading: string | null
    subHeading: string | null
  }

  export type Home_introMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    videoUrl: string | null
    mainHeading: string | null
    subHeading: string | null
  }

  export type Home_introCountAggregateOutputType = {
    id: number
    lang: number
    videoUrl: number
    mainHeading: number
    subHeading: number
    _all: number
  }


  export type Home_introMinAggregateInputType = {
    id?: true
    lang?: true
    videoUrl?: true
    mainHeading?: true
    subHeading?: true
  }

  export type Home_introMaxAggregateInputType = {
    id?: true
    lang?: true
    videoUrl?: true
    mainHeading?: true
    subHeading?: true
  }

  export type Home_introCountAggregateInputType = {
    id?: true
    lang?: true
    videoUrl?: true
    mainHeading?: true
    subHeading?: true
    _all?: true
  }

  export type Home_introAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Home_intro to aggregate.
     */
    where?: Home_introWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Home_intros to fetch.
     */
    orderBy?: Home_introOrderByWithRelationInput | Home_introOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Home_introWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Home_intros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Home_intros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Home_intros
    **/
    _count?: true | Home_introCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Home_introMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Home_introMaxAggregateInputType
  }

  export type GetHome_introAggregateType<T extends Home_introAggregateArgs> = {
        [P in keyof T & keyof AggregateHome_intro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHome_intro[P]>
      : GetScalarType<T[P], AggregateHome_intro[P]>
  }




  export type Home_introGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Home_introWhereInput
    orderBy?: Home_introOrderByWithAggregationInput | Home_introOrderByWithAggregationInput[]
    by: Home_introScalarFieldEnum[] | Home_introScalarFieldEnum
    having?: Home_introScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Home_introCountAggregateInputType | true
    _min?: Home_introMinAggregateInputType
    _max?: Home_introMaxAggregateInputType
  }

  export type Home_introGroupByOutputType = {
    id: string
    lang: string
    videoUrl: string
    mainHeading: string
    subHeading: string
    _count: Home_introCountAggregateOutputType | null
    _min: Home_introMinAggregateOutputType | null
    _max: Home_introMaxAggregateOutputType | null
  }

  type GetHome_introGroupByPayload<T extends Home_introGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Home_introGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Home_introGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Home_introGroupByOutputType[P]>
            : GetScalarType<T[P], Home_introGroupByOutputType[P]>
        }
      >
    >


  export type Home_introSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    videoUrl?: boolean
    mainHeading?: boolean
    subHeading?: boolean
  }, ExtArgs["result"]["home_intro"]>

  export type Home_introSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    videoUrl?: boolean
    mainHeading?: boolean
    subHeading?: boolean
  }, ExtArgs["result"]["home_intro"]>

  export type Home_introSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    videoUrl?: boolean
    mainHeading?: boolean
    subHeading?: boolean
  }, ExtArgs["result"]["home_intro"]>

  export type Home_introSelectScalar = {
    id?: boolean
    lang?: boolean
    videoUrl?: boolean
    mainHeading?: boolean
    subHeading?: boolean
  }

  export type Home_introOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "videoUrl" | "mainHeading" | "subHeading", ExtArgs["result"]["home_intro"]>

  export type $Home_introPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Home_intro"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      videoUrl: string
      mainHeading: string
      subHeading: string
    }, ExtArgs["result"]["home_intro"]>
    composites: {}
  }

  type Home_introGetPayload<S extends boolean | null | undefined | Home_introDefaultArgs> = $Result.GetResult<Prisma.$Home_introPayload, S>

  type Home_introCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Home_introFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Home_introCountAggregateInputType | true
    }

  export interface Home_introDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Home_intro'], meta: { name: 'Home_intro' } }
    /**
     * Find zero or one Home_intro that matches the filter.
     * @param {Home_introFindUniqueArgs} args - Arguments to find a Home_intro
     * @example
     * // Get one Home_intro
     * const home_intro = await prisma.home_intro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Home_introFindUniqueArgs>(args: SelectSubset<T, Home_introFindUniqueArgs<ExtArgs>>): Prisma__Home_introClient<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Home_intro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Home_introFindUniqueOrThrowArgs} args - Arguments to find a Home_intro
     * @example
     * // Get one Home_intro
     * const home_intro = await prisma.home_intro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Home_introFindUniqueOrThrowArgs>(args: SelectSubset<T, Home_introFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Home_introClient<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Home_intro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Home_introFindFirstArgs} args - Arguments to find a Home_intro
     * @example
     * // Get one Home_intro
     * const home_intro = await prisma.home_intro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Home_introFindFirstArgs>(args?: SelectSubset<T, Home_introFindFirstArgs<ExtArgs>>): Prisma__Home_introClient<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Home_intro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Home_introFindFirstOrThrowArgs} args - Arguments to find a Home_intro
     * @example
     * // Get one Home_intro
     * const home_intro = await prisma.home_intro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Home_introFindFirstOrThrowArgs>(args?: SelectSubset<T, Home_introFindFirstOrThrowArgs<ExtArgs>>): Prisma__Home_introClient<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Home_intros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Home_introFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Home_intros
     * const home_intros = await prisma.home_intro.findMany()
     * 
     * // Get first 10 Home_intros
     * const home_intros = await prisma.home_intro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const home_introWithIdOnly = await prisma.home_intro.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Home_introFindManyArgs>(args?: SelectSubset<T, Home_introFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Home_intro.
     * @param {Home_introCreateArgs} args - Arguments to create a Home_intro.
     * @example
     * // Create one Home_intro
     * const Home_intro = await prisma.home_intro.create({
     *   data: {
     *     // ... data to create a Home_intro
     *   }
     * })
     * 
     */
    create<T extends Home_introCreateArgs>(args: SelectSubset<T, Home_introCreateArgs<ExtArgs>>): Prisma__Home_introClient<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Home_intros.
     * @param {Home_introCreateManyArgs} args - Arguments to create many Home_intros.
     * @example
     * // Create many Home_intros
     * const home_intro = await prisma.home_intro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Home_introCreateManyArgs>(args?: SelectSubset<T, Home_introCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Home_intros and returns the data saved in the database.
     * @param {Home_introCreateManyAndReturnArgs} args - Arguments to create many Home_intros.
     * @example
     * // Create many Home_intros
     * const home_intro = await prisma.home_intro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Home_intros and only return the `id`
     * const home_introWithIdOnly = await prisma.home_intro.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Home_introCreateManyAndReturnArgs>(args?: SelectSubset<T, Home_introCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Home_intro.
     * @param {Home_introDeleteArgs} args - Arguments to delete one Home_intro.
     * @example
     * // Delete one Home_intro
     * const Home_intro = await prisma.home_intro.delete({
     *   where: {
     *     // ... filter to delete one Home_intro
     *   }
     * })
     * 
     */
    delete<T extends Home_introDeleteArgs>(args: SelectSubset<T, Home_introDeleteArgs<ExtArgs>>): Prisma__Home_introClient<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Home_intro.
     * @param {Home_introUpdateArgs} args - Arguments to update one Home_intro.
     * @example
     * // Update one Home_intro
     * const home_intro = await prisma.home_intro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Home_introUpdateArgs>(args: SelectSubset<T, Home_introUpdateArgs<ExtArgs>>): Prisma__Home_introClient<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Home_intros.
     * @param {Home_introDeleteManyArgs} args - Arguments to filter Home_intros to delete.
     * @example
     * // Delete a few Home_intros
     * const { count } = await prisma.home_intro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Home_introDeleteManyArgs>(args?: SelectSubset<T, Home_introDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Home_intros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Home_introUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Home_intros
     * const home_intro = await prisma.home_intro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Home_introUpdateManyArgs>(args: SelectSubset<T, Home_introUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Home_intros and returns the data updated in the database.
     * @param {Home_introUpdateManyAndReturnArgs} args - Arguments to update many Home_intros.
     * @example
     * // Update many Home_intros
     * const home_intro = await prisma.home_intro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Home_intros and only return the `id`
     * const home_introWithIdOnly = await prisma.home_intro.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Home_introUpdateManyAndReturnArgs>(args: SelectSubset<T, Home_introUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Home_intro.
     * @param {Home_introUpsertArgs} args - Arguments to update or create a Home_intro.
     * @example
     * // Update or create a Home_intro
     * const home_intro = await prisma.home_intro.upsert({
     *   create: {
     *     // ... data to create a Home_intro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Home_intro we want to update
     *   }
     * })
     */
    upsert<T extends Home_introUpsertArgs>(args: SelectSubset<T, Home_introUpsertArgs<ExtArgs>>): Prisma__Home_introClient<$Result.GetResult<Prisma.$Home_introPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Home_intros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Home_introCountArgs} args - Arguments to filter Home_intros to count.
     * @example
     * // Count the number of Home_intros
     * const count = await prisma.home_intro.count({
     *   where: {
     *     // ... the filter for the Home_intros we want to count
     *   }
     * })
    **/
    count<T extends Home_introCountArgs>(
      args?: Subset<T, Home_introCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Home_introCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Home_intro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Home_introAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Home_introAggregateArgs>(args: Subset<T, Home_introAggregateArgs>): Prisma.PrismaPromise<GetHome_introAggregateType<T>>

    /**
     * Group by Home_intro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Home_introGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Home_introGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Home_introGroupByArgs['orderBy'] }
        : { orderBy?: Home_introGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Home_introGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHome_introGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Home_intro model
   */
  readonly fields: Home_introFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Home_intro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Home_introClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Home_intro model
   */
  interface Home_introFieldRefs {
    readonly id: FieldRef<"Home_intro", 'String'>
    readonly lang: FieldRef<"Home_intro", 'String'>
    readonly videoUrl: FieldRef<"Home_intro", 'String'>
    readonly mainHeading: FieldRef<"Home_intro", 'String'>
    readonly subHeading: FieldRef<"Home_intro", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Home_intro findUnique
   */
  export type Home_introFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * Filter, which Home_intro to fetch.
     */
    where: Home_introWhereUniqueInput
  }

  /**
   * Home_intro findUniqueOrThrow
   */
  export type Home_introFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * Filter, which Home_intro to fetch.
     */
    where: Home_introWhereUniqueInput
  }

  /**
   * Home_intro findFirst
   */
  export type Home_introFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * Filter, which Home_intro to fetch.
     */
    where?: Home_introWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Home_intros to fetch.
     */
    orderBy?: Home_introOrderByWithRelationInput | Home_introOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Home_intros.
     */
    cursor?: Home_introWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Home_intros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Home_intros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Home_intros.
     */
    distinct?: Home_introScalarFieldEnum | Home_introScalarFieldEnum[]
  }

  /**
   * Home_intro findFirstOrThrow
   */
  export type Home_introFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * Filter, which Home_intro to fetch.
     */
    where?: Home_introWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Home_intros to fetch.
     */
    orderBy?: Home_introOrderByWithRelationInput | Home_introOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Home_intros.
     */
    cursor?: Home_introWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Home_intros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Home_intros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Home_intros.
     */
    distinct?: Home_introScalarFieldEnum | Home_introScalarFieldEnum[]
  }

  /**
   * Home_intro findMany
   */
  export type Home_introFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * Filter, which Home_intros to fetch.
     */
    where?: Home_introWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Home_intros to fetch.
     */
    orderBy?: Home_introOrderByWithRelationInput | Home_introOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Home_intros.
     */
    cursor?: Home_introWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Home_intros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Home_intros.
     */
    skip?: number
    distinct?: Home_introScalarFieldEnum | Home_introScalarFieldEnum[]
  }

  /**
   * Home_intro create
   */
  export type Home_introCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * The data needed to create a Home_intro.
     */
    data: XOR<Home_introCreateInput, Home_introUncheckedCreateInput>
  }

  /**
   * Home_intro createMany
   */
  export type Home_introCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Home_intros.
     */
    data: Home_introCreateManyInput | Home_introCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Home_intro createManyAndReturn
   */
  export type Home_introCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * The data used to create many Home_intros.
     */
    data: Home_introCreateManyInput | Home_introCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Home_intro update
   */
  export type Home_introUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * The data needed to update a Home_intro.
     */
    data: XOR<Home_introUpdateInput, Home_introUncheckedUpdateInput>
    /**
     * Choose, which Home_intro to update.
     */
    where: Home_introWhereUniqueInput
  }

  /**
   * Home_intro updateMany
   */
  export type Home_introUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Home_intros.
     */
    data: XOR<Home_introUpdateManyMutationInput, Home_introUncheckedUpdateManyInput>
    /**
     * Filter which Home_intros to update
     */
    where?: Home_introWhereInput
    /**
     * Limit how many Home_intros to update.
     */
    limit?: number
  }

  /**
   * Home_intro updateManyAndReturn
   */
  export type Home_introUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * The data used to update Home_intros.
     */
    data: XOR<Home_introUpdateManyMutationInput, Home_introUncheckedUpdateManyInput>
    /**
     * Filter which Home_intros to update
     */
    where?: Home_introWhereInput
    /**
     * Limit how many Home_intros to update.
     */
    limit?: number
  }

  /**
   * Home_intro upsert
   */
  export type Home_introUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * The filter to search for the Home_intro to update in case it exists.
     */
    where: Home_introWhereUniqueInput
    /**
     * In case the Home_intro found by the `where` argument doesn't exist, create a new Home_intro with this data.
     */
    create: XOR<Home_introCreateInput, Home_introUncheckedCreateInput>
    /**
     * In case the Home_intro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Home_introUpdateInput, Home_introUncheckedUpdateInput>
  }

  /**
   * Home_intro delete
   */
  export type Home_introDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
    /**
     * Filter which Home_intro to delete.
     */
    where: Home_introWhereUniqueInput
  }

  /**
   * Home_intro deleteMany
   */
  export type Home_introDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Home_intros to delete
     */
    where?: Home_introWhereInput
    /**
     * Limit how many Home_intros to delete.
     */
    limit?: number
  }

  /**
   * Home_intro without action
   */
  export type Home_introDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Home_intro
     */
    select?: Home_introSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Home_intro
     */
    omit?: Home_introOmit<ExtArgs> | null
  }


  /**
   * Model About_title
   */

  export type AggregateAbout_title = {
    _count: About_titleCountAggregateOutputType | null
    _min: About_titleMinAggregateOutputType | null
    _max: About_titleMaxAggregateOutputType | null
  }

  export type About_titleMinAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
  }

  export type About_titleMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
  }

  export type About_titleCountAggregateOutputType = {
    id: number
    lang: number
    title: number
    _all: number
  }


  export type About_titleMinAggregateInputType = {
    id?: true
    lang?: true
    title?: true
  }

  export type About_titleMaxAggregateInputType = {
    id?: true
    lang?: true
    title?: true
  }

  export type About_titleCountAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    _all?: true
  }

  export type About_titleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which About_title to aggregate.
     */
    where?: About_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of About_titles to fetch.
     */
    orderBy?: About_titleOrderByWithRelationInput | About_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: About_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` About_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` About_titles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned About_titles
    **/
    _count?: true | About_titleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: About_titleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: About_titleMaxAggregateInputType
  }

  export type GetAbout_titleAggregateType<T extends About_titleAggregateArgs> = {
        [P in keyof T & keyof AggregateAbout_title]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbout_title[P]>
      : GetScalarType<T[P], AggregateAbout_title[P]>
  }




  export type About_titleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: About_titleWhereInput
    orderBy?: About_titleOrderByWithAggregationInput | About_titleOrderByWithAggregationInput[]
    by: About_titleScalarFieldEnum[] | About_titleScalarFieldEnum
    having?: About_titleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: About_titleCountAggregateInputType | true
    _min?: About_titleMinAggregateInputType
    _max?: About_titleMaxAggregateInputType
  }

  export type About_titleGroupByOutputType = {
    id: string
    lang: string
    title: string
    _count: About_titleCountAggregateOutputType | null
    _min: About_titleMinAggregateOutputType | null
    _max: About_titleMaxAggregateOutputType | null
  }

  type GetAbout_titleGroupByPayload<T extends About_titleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<About_titleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof About_titleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], About_titleGroupByOutputType[P]>
            : GetScalarType<T[P], About_titleGroupByOutputType[P]>
        }
      >
    >


  export type About_titleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
  }, ExtArgs["result"]["about_title"]>

  export type About_titleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
  }, ExtArgs["result"]["about_title"]>

  export type About_titleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
  }, ExtArgs["result"]["about_title"]>

  export type About_titleSelectScalar = {
    id?: boolean
    lang?: boolean
    title?: boolean
  }

  export type About_titleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "title", ExtArgs["result"]["about_title"]>

  export type $About_titlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "About_title"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      title: string
    }, ExtArgs["result"]["about_title"]>
    composites: {}
  }

  type About_titleGetPayload<S extends boolean | null | undefined | About_titleDefaultArgs> = $Result.GetResult<Prisma.$About_titlePayload, S>

  type About_titleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<About_titleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: About_titleCountAggregateInputType | true
    }

  export interface About_titleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['About_title'], meta: { name: 'About_title' } }
    /**
     * Find zero or one About_title that matches the filter.
     * @param {About_titleFindUniqueArgs} args - Arguments to find a About_title
     * @example
     * // Get one About_title
     * const about_title = await prisma.about_title.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends About_titleFindUniqueArgs>(args: SelectSubset<T, About_titleFindUniqueArgs<ExtArgs>>): Prisma__About_titleClient<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one About_title that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {About_titleFindUniqueOrThrowArgs} args - Arguments to find a About_title
     * @example
     * // Get one About_title
     * const about_title = await prisma.about_title.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends About_titleFindUniqueOrThrowArgs>(args: SelectSubset<T, About_titleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__About_titleClient<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first About_title that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {About_titleFindFirstArgs} args - Arguments to find a About_title
     * @example
     * // Get one About_title
     * const about_title = await prisma.about_title.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends About_titleFindFirstArgs>(args?: SelectSubset<T, About_titleFindFirstArgs<ExtArgs>>): Prisma__About_titleClient<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first About_title that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {About_titleFindFirstOrThrowArgs} args - Arguments to find a About_title
     * @example
     * // Get one About_title
     * const about_title = await prisma.about_title.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends About_titleFindFirstOrThrowArgs>(args?: SelectSubset<T, About_titleFindFirstOrThrowArgs<ExtArgs>>): Prisma__About_titleClient<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more About_titles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {About_titleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all About_titles
     * const about_titles = await prisma.about_title.findMany()
     * 
     * // Get first 10 About_titles
     * const about_titles = await prisma.about_title.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const about_titleWithIdOnly = await prisma.about_title.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends About_titleFindManyArgs>(args?: SelectSubset<T, About_titleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a About_title.
     * @param {About_titleCreateArgs} args - Arguments to create a About_title.
     * @example
     * // Create one About_title
     * const About_title = await prisma.about_title.create({
     *   data: {
     *     // ... data to create a About_title
     *   }
     * })
     * 
     */
    create<T extends About_titleCreateArgs>(args: SelectSubset<T, About_titleCreateArgs<ExtArgs>>): Prisma__About_titleClient<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many About_titles.
     * @param {About_titleCreateManyArgs} args - Arguments to create many About_titles.
     * @example
     * // Create many About_titles
     * const about_title = await prisma.about_title.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends About_titleCreateManyArgs>(args?: SelectSubset<T, About_titleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many About_titles and returns the data saved in the database.
     * @param {About_titleCreateManyAndReturnArgs} args - Arguments to create many About_titles.
     * @example
     * // Create many About_titles
     * const about_title = await prisma.about_title.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many About_titles and only return the `id`
     * const about_titleWithIdOnly = await prisma.about_title.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends About_titleCreateManyAndReturnArgs>(args?: SelectSubset<T, About_titleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a About_title.
     * @param {About_titleDeleteArgs} args - Arguments to delete one About_title.
     * @example
     * // Delete one About_title
     * const About_title = await prisma.about_title.delete({
     *   where: {
     *     // ... filter to delete one About_title
     *   }
     * })
     * 
     */
    delete<T extends About_titleDeleteArgs>(args: SelectSubset<T, About_titleDeleteArgs<ExtArgs>>): Prisma__About_titleClient<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one About_title.
     * @param {About_titleUpdateArgs} args - Arguments to update one About_title.
     * @example
     * // Update one About_title
     * const about_title = await prisma.about_title.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends About_titleUpdateArgs>(args: SelectSubset<T, About_titleUpdateArgs<ExtArgs>>): Prisma__About_titleClient<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more About_titles.
     * @param {About_titleDeleteManyArgs} args - Arguments to filter About_titles to delete.
     * @example
     * // Delete a few About_titles
     * const { count } = await prisma.about_title.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends About_titleDeleteManyArgs>(args?: SelectSubset<T, About_titleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more About_titles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {About_titleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many About_titles
     * const about_title = await prisma.about_title.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends About_titleUpdateManyArgs>(args: SelectSubset<T, About_titleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more About_titles and returns the data updated in the database.
     * @param {About_titleUpdateManyAndReturnArgs} args - Arguments to update many About_titles.
     * @example
     * // Update many About_titles
     * const about_title = await prisma.about_title.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more About_titles and only return the `id`
     * const about_titleWithIdOnly = await prisma.about_title.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends About_titleUpdateManyAndReturnArgs>(args: SelectSubset<T, About_titleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one About_title.
     * @param {About_titleUpsertArgs} args - Arguments to update or create a About_title.
     * @example
     * // Update or create a About_title
     * const about_title = await prisma.about_title.upsert({
     *   create: {
     *     // ... data to create a About_title
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the About_title we want to update
     *   }
     * })
     */
    upsert<T extends About_titleUpsertArgs>(args: SelectSubset<T, About_titleUpsertArgs<ExtArgs>>): Prisma__About_titleClient<$Result.GetResult<Prisma.$About_titlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of About_titles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {About_titleCountArgs} args - Arguments to filter About_titles to count.
     * @example
     * // Count the number of About_titles
     * const count = await prisma.about_title.count({
     *   where: {
     *     // ... the filter for the About_titles we want to count
     *   }
     * })
    **/
    count<T extends About_titleCountArgs>(
      args?: Subset<T, About_titleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], About_titleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a About_title.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {About_titleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends About_titleAggregateArgs>(args: Subset<T, About_titleAggregateArgs>): Prisma.PrismaPromise<GetAbout_titleAggregateType<T>>

    /**
     * Group by About_title.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {About_titleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends About_titleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: About_titleGroupByArgs['orderBy'] }
        : { orderBy?: About_titleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, About_titleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbout_titleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the About_title model
   */
  readonly fields: About_titleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for About_title.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__About_titleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the About_title model
   */
  interface About_titleFieldRefs {
    readonly id: FieldRef<"About_title", 'String'>
    readonly lang: FieldRef<"About_title", 'String'>
    readonly title: FieldRef<"About_title", 'String'>
  }
    

  // Custom InputTypes
  /**
   * About_title findUnique
   */
  export type About_titleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * Filter, which About_title to fetch.
     */
    where: About_titleWhereUniqueInput
  }

  /**
   * About_title findUniqueOrThrow
   */
  export type About_titleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * Filter, which About_title to fetch.
     */
    where: About_titleWhereUniqueInput
  }

  /**
   * About_title findFirst
   */
  export type About_titleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * Filter, which About_title to fetch.
     */
    where?: About_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of About_titles to fetch.
     */
    orderBy?: About_titleOrderByWithRelationInput | About_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for About_titles.
     */
    cursor?: About_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` About_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` About_titles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of About_titles.
     */
    distinct?: About_titleScalarFieldEnum | About_titleScalarFieldEnum[]
  }

  /**
   * About_title findFirstOrThrow
   */
  export type About_titleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * Filter, which About_title to fetch.
     */
    where?: About_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of About_titles to fetch.
     */
    orderBy?: About_titleOrderByWithRelationInput | About_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for About_titles.
     */
    cursor?: About_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` About_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` About_titles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of About_titles.
     */
    distinct?: About_titleScalarFieldEnum | About_titleScalarFieldEnum[]
  }

  /**
   * About_title findMany
   */
  export type About_titleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * Filter, which About_titles to fetch.
     */
    where?: About_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of About_titles to fetch.
     */
    orderBy?: About_titleOrderByWithRelationInput | About_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing About_titles.
     */
    cursor?: About_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` About_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` About_titles.
     */
    skip?: number
    distinct?: About_titleScalarFieldEnum | About_titleScalarFieldEnum[]
  }

  /**
   * About_title create
   */
  export type About_titleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * The data needed to create a About_title.
     */
    data: XOR<About_titleCreateInput, About_titleUncheckedCreateInput>
  }

  /**
   * About_title createMany
   */
  export type About_titleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many About_titles.
     */
    data: About_titleCreateManyInput | About_titleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * About_title createManyAndReturn
   */
  export type About_titleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * The data used to create many About_titles.
     */
    data: About_titleCreateManyInput | About_titleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * About_title update
   */
  export type About_titleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * The data needed to update a About_title.
     */
    data: XOR<About_titleUpdateInput, About_titleUncheckedUpdateInput>
    /**
     * Choose, which About_title to update.
     */
    where: About_titleWhereUniqueInput
  }

  /**
   * About_title updateMany
   */
  export type About_titleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update About_titles.
     */
    data: XOR<About_titleUpdateManyMutationInput, About_titleUncheckedUpdateManyInput>
    /**
     * Filter which About_titles to update
     */
    where?: About_titleWhereInput
    /**
     * Limit how many About_titles to update.
     */
    limit?: number
  }

  /**
   * About_title updateManyAndReturn
   */
  export type About_titleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * The data used to update About_titles.
     */
    data: XOR<About_titleUpdateManyMutationInput, About_titleUncheckedUpdateManyInput>
    /**
     * Filter which About_titles to update
     */
    where?: About_titleWhereInput
    /**
     * Limit how many About_titles to update.
     */
    limit?: number
  }

  /**
   * About_title upsert
   */
  export type About_titleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * The filter to search for the About_title to update in case it exists.
     */
    where: About_titleWhereUniqueInput
    /**
     * In case the About_title found by the `where` argument doesn't exist, create a new About_title with this data.
     */
    create: XOR<About_titleCreateInput, About_titleUncheckedCreateInput>
    /**
     * In case the About_title was found with the provided `where` argument, update it with this data.
     */
    update: XOR<About_titleUpdateInput, About_titleUncheckedUpdateInput>
  }

  /**
   * About_title delete
   */
  export type About_titleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
    /**
     * Filter which About_title to delete.
     */
    where: About_titleWhereUniqueInput
  }

  /**
   * About_title deleteMany
   */
  export type About_titleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which About_titles to delete
     */
    where?: About_titleWhereInput
    /**
     * Limit how many About_titles to delete.
     */
    limit?: number
  }

  /**
   * About_title without action
   */
  export type About_titleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the About_title
     */
    select?: About_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the About_title
     */
    omit?: About_titleOmit<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    lang: string | null
    image: string | null
    btn_text: string | null
    title: string | null
    description: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    image: string | null
    btn_text: string | null
    title: string | null
    description: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    lang: number
    image: number
    btn_text: number
    title: number
    description: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    lang?: true
    image?: true
    btn_text?: true
    title?: true
    description?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    lang?: true
    image?: true
    btn_text?: true
    title?: true
    description?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    lang?: true
    image?: true
    btn_text?: true
    title?: true
    description?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    lang: string
    image: string
    btn_text: string
    title: string
    description: string
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    image?: boolean
    btn_text?: boolean
    title?: boolean
    description?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    image?: boolean
    btn_text?: boolean
    title?: boolean
    description?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    image?: boolean
    btn_text?: boolean
    title?: boolean
    description?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    lang?: boolean
    image?: boolean
    btn_text?: boolean
    title?: boolean
    description?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "image" | "btn_text" | "title" | "description", ExtArgs["result"]["product"]>

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      image: string
      btn_text: string
      title: string
      description: string
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly lang: FieldRef<"Product", 'String'>
    readonly image: FieldRef<"Product", 'String'>
    readonly btn_text: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
  }


  /**
   * Model Gallery_title
   */

  export type AggregateGallery_title = {
    _count: Gallery_titleCountAggregateOutputType | null
    _min: Gallery_titleMinAggregateOutputType | null
    _max: Gallery_titleMaxAggregateOutputType | null
  }

  export type Gallery_titleMinAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    subTitle: string | null
  }

  export type Gallery_titleMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    subTitle: string | null
  }

  export type Gallery_titleCountAggregateOutputType = {
    id: number
    lang: number
    title: number
    subTitle: number
    _all: number
  }


  export type Gallery_titleMinAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    subTitle?: true
  }

  export type Gallery_titleMaxAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    subTitle?: true
  }

  export type Gallery_titleCountAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    subTitle?: true
    _all?: true
  }

  export type Gallery_titleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gallery_title to aggregate.
     */
    where?: Gallery_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_titles to fetch.
     */
    orderBy?: Gallery_titleOrderByWithRelationInput | Gallery_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Gallery_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_titles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gallery_titles
    **/
    _count?: true | Gallery_titleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gallery_titleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gallery_titleMaxAggregateInputType
  }

  export type GetGallery_titleAggregateType<T extends Gallery_titleAggregateArgs> = {
        [P in keyof T & keyof AggregateGallery_title]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGallery_title[P]>
      : GetScalarType<T[P], AggregateGallery_title[P]>
  }




  export type Gallery_titleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Gallery_titleWhereInput
    orderBy?: Gallery_titleOrderByWithAggregationInput | Gallery_titleOrderByWithAggregationInput[]
    by: Gallery_titleScalarFieldEnum[] | Gallery_titleScalarFieldEnum
    having?: Gallery_titleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gallery_titleCountAggregateInputType | true
    _min?: Gallery_titleMinAggregateInputType
    _max?: Gallery_titleMaxAggregateInputType
  }

  export type Gallery_titleGroupByOutputType = {
    id: string
    lang: string
    title: string
    subTitle: string
    _count: Gallery_titleCountAggregateOutputType | null
    _min: Gallery_titleMinAggregateOutputType | null
    _max: Gallery_titleMaxAggregateOutputType | null
  }

  type GetGallery_titleGroupByPayload<T extends Gallery_titleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gallery_titleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gallery_titleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gallery_titleGroupByOutputType[P]>
            : GetScalarType<T[P], Gallery_titleGroupByOutputType[P]>
        }
      >
    >


  export type Gallery_titleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    subTitle?: boolean
  }, ExtArgs["result"]["gallery_title"]>

  export type Gallery_titleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    subTitle?: boolean
  }, ExtArgs["result"]["gallery_title"]>

  export type Gallery_titleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    subTitle?: boolean
  }, ExtArgs["result"]["gallery_title"]>

  export type Gallery_titleSelectScalar = {
    id?: boolean
    lang?: boolean
    title?: boolean
    subTitle?: boolean
  }

  export type Gallery_titleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "title" | "subTitle", ExtArgs["result"]["gallery_title"]>

  export type $Gallery_titlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gallery_title"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      title: string
      subTitle: string
    }, ExtArgs["result"]["gallery_title"]>
    composites: {}
  }

  type Gallery_titleGetPayload<S extends boolean | null | undefined | Gallery_titleDefaultArgs> = $Result.GetResult<Prisma.$Gallery_titlePayload, S>

  type Gallery_titleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Gallery_titleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Gallery_titleCountAggregateInputType | true
    }

  export interface Gallery_titleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gallery_title'], meta: { name: 'Gallery_title' } }
    /**
     * Find zero or one Gallery_title that matches the filter.
     * @param {Gallery_titleFindUniqueArgs} args - Arguments to find a Gallery_title
     * @example
     * // Get one Gallery_title
     * const gallery_title = await prisma.gallery_title.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Gallery_titleFindUniqueArgs>(args: SelectSubset<T, Gallery_titleFindUniqueArgs<ExtArgs>>): Prisma__Gallery_titleClient<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gallery_title that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Gallery_titleFindUniqueOrThrowArgs} args - Arguments to find a Gallery_title
     * @example
     * // Get one Gallery_title
     * const gallery_title = await prisma.gallery_title.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Gallery_titleFindUniqueOrThrowArgs>(args: SelectSubset<T, Gallery_titleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Gallery_titleClient<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gallery_title that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_titleFindFirstArgs} args - Arguments to find a Gallery_title
     * @example
     * // Get one Gallery_title
     * const gallery_title = await prisma.gallery_title.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Gallery_titleFindFirstArgs>(args?: SelectSubset<T, Gallery_titleFindFirstArgs<ExtArgs>>): Prisma__Gallery_titleClient<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gallery_title that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_titleFindFirstOrThrowArgs} args - Arguments to find a Gallery_title
     * @example
     * // Get one Gallery_title
     * const gallery_title = await prisma.gallery_title.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Gallery_titleFindFirstOrThrowArgs>(args?: SelectSubset<T, Gallery_titleFindFirstOrThrowArgs<ExtArgs>>): Prisma__Gallery_titleClient<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gallery_titles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_titleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gallery_titles
     * const gallery_titles = await prisma.gallery_title.findMany()
     * 
     * // Get first 10 Gallery_titles
     * const gallery_titles = await prisma.gallery_title.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gallery_titleWithIdOnly = await prisma.gallery_title.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Gallery_titleFindManyArgs>(args?: SelectSubset<T, Gallery_titleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gallery_title.
     * @param {Gallery_titleCreateArgs} args - Arguments to create a Gallery_title.
     * @example
     * // Create one Gallery_title
     * const Gallery_title = await prisma.gallery_title.create({
     *   data: {
     *     // ... data to create a Gallery_title
     *   }
     * })
     * 
     */
    create<T extends Gallery_titleCreateArgs>(args: SelectSubset<T, Gallery_titleCreateArgs<ExtArgs>>): Prisma__Gallery_titleClient<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gallery_titles.
     * @param {Gallery_titleCreateManyArgs} args - Arguments to create many Gallery_titles.
     * @example
     * // Create many Gallery_titles
     * const gallery_title = await prisma.gallery_title.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Gallery_titleCreateManyArgs>(args?: SelectSubset<T, Gallery_titleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gallery_titles and returns the data saved in the database.
     * @param {Gallery_titleCreateManyAndReturnArgs} args - Arguments to create many Gallery_titles.
     * @example
     * // Create many Gallery_titles
     * const gallery_title = await prisma.gallery_title.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gallery_titles and only return the `id`
     * const gallery_titleWithIdOnly = await prisma.gallery_title.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Gallery_titleCreateManyAndReturnArgs>(args?: SelectSubset<T, Gallery_titleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gallery_title.
     * @param {Gallery_titleDeleteArgs} args - Arguments to delete one Gallery_title.
     * @example
     * // Delete one Gallery_title
     * const Gallery_title = await prisma.gallery_title.delete({
     *   where: {
     *     // ... filter to delete one Gallery_title
     *   }
     * })
     * 
     */
    delete<T extends Gallery_titleDeleteArgs>(args: SelectSubset<T, Gallery_titleDeleteArgs<ExtArgs>>): Prisma__Gallery_titleClient<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gallery_title.
     * @param {Gallery_titleUpdateArgs} args - Arguments to update one Gallery_title.
     * @example
     * // Update one Gallery_title
     * const gallery_title = await prisma.gallery_title.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Gallery_titleUpdateArgs>(args: SelectSubset<T, Gallery_titleUpdateArgs<ExtArgs>>): Prisma__Gallery_titleClient<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gallery_titles.
     * @param {Gallery_titleDeleteManyArgs} args - Arguments to filter Gallery_titles to delete.
     * @example
     * // Delete a few Gallery_titles
     * const { count } = await prisma.gallery_title.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Gallery_titleDeleteManyArgs>(args?: SelectSubset<T, Gallery_titleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gallery_titles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_titleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gallery_titles
     * const gallery_title = await prisma.gallery_title.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Gallery_titleUpdateManyArgs>(args: SelectSubset<T, Gallery_titleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gallery_titles and returns the data updated in the database.
     * @param {Gallery_titleUpdateManyAndReturnArgs} args - Arguments to update many Gallery_titles.
     * @example
     * // Update many Gallery_titles
     * const gallery_title = await prisma.gallery_title.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gallery_titles and only return the `id`
     * const gallery_titleWithIdOnly = await prisma.gallery_title.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Gallery_titleUpdateManyAndReturnArgs>(args: SelectSubset<T, Gallery_titleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gallery_title.
     * @param {Gallery_titleUpsertArgs} args - Arguments to update or create a Gallery_title.
     * @example
     * // Update or create a Gallery_title
     * const gallery_title = await prisma.gallery_title.upsert({
     *   create: {
     *     // ... data to create a Gallery_title
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gallery_title we want to update
     *   }
     * })
     */
    upsert<T extends Gallery_titleUpsertArgs>(args: SelectSubset<T, Gallery_titleUpsertArgs<ExtArgs>>): Prisma__Gallery_titleClient<$Result.GetResult<Prisma.$Gallery_titlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gallery_titles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_titleCountArgs} args - Arguments to filter Gallery_titles to count.
     * @example
     * // Count the number of Gallery_titles
     * const count = await prisma.gallery_title.count({
     *   where: {
     *     // ... the filter for the Gallery_titles we want to count
     *   }
     * })
    **/
    count<T extends Gallery_titleCountArgs>(
      args?: Subset<T, Gallery_titleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gallery_titleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gallery_title.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_titleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gallery_titleAggregateArgs>(args: Subset<T, Gallery_titleAggregateArgs>): Prisma.PrismaPromise<GetGallery_titleAggregateType<T>>

    /**
     * Group by Gallery_title.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_titleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gallery_titleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gallery_titleGroupByArgs['orderBy'] }
        : { orderBy?: Gallery_titleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gallery_titleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGallery_titleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gallery_title model
   */
  readonly fields: Gallery_titleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gallery_title.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Gallery_titleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gallery_title model
   */
  interface Gallery_titleFieldRefs {
    readonly id: FieldRef<"Gallery_title", 'String'>
    readonly lang: FieldRef<"Gallery_title", 'String'>
    readonly title: FieldRef<"Gallery_title", 'String'>
    readonly subTitle: FieldRef<"Gallery_title", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Gallery_title findUnique
   */
  export type Gallery_titleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_title to fetch.
     */
    where: Gallery_titleWhereUniqueInput
  }

  /**
   * Gallery_title findUniqueOrThrow
   */
  export type Gallery_titleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_title to fetch.
     */
    where: Gallery_titleWhereUniqueInput
  }

  /**
   * Gallery_title findFirst
   */
  export type Gallery_titleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_title to fetch.
     */
    where?: Gallery_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_titles to fetch.
     */
    orderBy?: Gallery_titleOrderByWithRelationInput | Gallery_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gallery_titles.
     */
    cursor?: Gallery_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_titles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gallery_titles.
     */
    distinct?: Gallery_titleScalarFieldEnum | Gallery_titleScalarFieldEnum[]
  }

  /**
   * Gallery_title findFirstOrThrow
   */
  export type Gallery_titleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_title to fetch.
     */
    where?: Gallery_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_titles to fetch.
     */
    orderBy?: Gallery_titleOrderByWithRelationInput | Gallery_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gallery_titles.
     */
    cursor?: Gallery_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_titles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gallery_titles.
     */
    distinct?: Gallery_titleScalarFieldEnum | Gallery_titleScalarFieldEnum[]
  }

  /**
   * Gallery_title findMany
   */
  export type Gallery_titleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_titles to fetch.
     */
    where?: Gallery_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_titles to fetch.
     */
    orderBy?: Gallery_titleOrderByWithRelationInput | Gallery_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gallery_titles.
     */
    cursor?: Gallery_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_titles.
     */
    skip?: number
    distinct?: Gallery_titleScalarFieldEnum | Gallery_titleScalarFieldEnum[]
  }

  /**
   * Gallery_title create
   */
  export type Gallery_titleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * The data needed to create a Gallery_title.
     */
    data: XOR<Gallery_titleCreateInput, Gallery_titleUncheckedCreateInput>
  }

  /**
   * Gallery_title createMany
   */
  export type Gallery_titleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gallery_titles.
     */
    data: Gallery_titleCreateManyInput | Gallery_titleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gallery_title createManyAndReturn
   */
  export type Gallery_titleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * The data used to create many Gallery_titles.
     */
    data: Gallery_titleCreateManyInput | Gallery_titleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gallery_title update
   */
  export type Gallery_titleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * The data needed to update a Gallery_title.
     */
    data: XOR<Gallery_titleUpdateInput, Gallery_titleUncheckedUpdateInput>
    /**
     * Choose, which Gallery_title to update.
     */
    where: Gallery_titleWhereUniqueInput
  }

  /**
   * Gallery_title updateMany
   */
  export type Gallery_titleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gallery_titles.
     */
    data: XOR<Gallery_titleUpdateManyMutationInput, Gallery_titleUncheckedUpdateManyInput>
    /**
     * Filter which Gallery_titles to update
     */
    where?: Gallery_titleWhereInput
    /**
     * Limit how many Gallery_titles to update.
     */
    limit?: number
  }

  /**
   * Gallery_title updateManyAndReturn
   */
  export type Gallery_titleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * The data used to update Gallery_titles.
     */
    data: XOR<Gallery_titleUpdateManyMutationInput, Gallery_titleUncheckedUpdateManyInput>
    /**
     * Filter which Gallery_titles to update
     */
    where?: Gallery_titleWhereInput
    /**
     * Limit how many Gallery_titles to update.
     */
    limit?: number
  }

  /**
   * Gallery_title upsert
   */
  export type Gallery_titleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * The filter to search for the Gallery_title to update in case it exists.
     */
    where: Gallery_titleWhereUniqueInput
    /**
     * In case the Gallery_title found by the `where` argument doesn't exist, create a new Gallery_title with this data.
     */
    create: XOR<Gallery_titleCreateInput, Gallery_titleUncheckedCreateInput>
    /**
     * In case the Gallery_title was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Gallery_titleUpdateInput, Gallery_titleUncheckedUpdateInput>
  }

  /**
   * Gallery_title delete
   */
  export type Gallery_titleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
    /**
     * Filter which Gallery_title to delete.
     */
    where: Gallery_titleWhereUniqueInput
  }

  /**
   * Gallery_title deleteMany
   */
  export type Gallery_titleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gallery_titles to delete
     */
    where?: Gallery_titleWhereInput
    /**
     * Limit how many Gallery_titles to delete.
     */
    limit?: number
  }

  /**
   * Gallery_title without action
   */
  export type Gallery_titleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_title
     */
    select?: Gallery_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_title
     */
    omit?: Gallery_titleOmit<ExtArgs> | null
  }


  /**
   * Model Gallery_content
   */

  export type AggregateGallery_content = {
    _count: Gallery_contentCountAggregateOutputType | null
    _min: Gallery_contentMinAggregateOutputType | null
    _max: Gallery_contentMaxAggregateOutputType | null
  }

  export type Gallery_contentMinAggregateOutputType = {
    id: string | null
    img_url: string | null
  }

  export type Gallery_contentMaxAggregateOutputType = {
    id: string | null
    img_url: string | null
  }

  export type Gallery_contentCountAggregateOutputType = {
    id: number
    img_url: number
    _all: number
  }


  export type Gallery_contentMinAggregateInputType = {
    id?: true
    img_url?: true
  }

  export type Gallery_contentMaxAggregateInputType = {
    id?: true
    img_url?: true
  }

  export type Gallery_contentCountAggregateInputType = {
    id?: true
    img_url?: true
    _all?: true
  }

  export type Gallery_contentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gallery_content to aggregate.
     */
    where?: Gallery_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_contents to fetch.
     */
    orderBy?: Gallery_contentOrderByWithRelationInput | Gallery_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Gallery_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gallery_contents
    **/
    _count?: true | Gallery_contentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gallery_contentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gallery_contentMaxAggregateInputType
  }

  export type GetGallery_contentAggregateType<T extends Gallery_contentAggregateArgs> = {
        [P in keyof T & keyof AggregateGallery_content]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGallery_content[P]>
      : GetScalarType<T[P], AggregateGallery_content[P]>
  }




  export type Gallery_contentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Gallery_contentWhereInput
    orderBy?: Gallery_contentOrderByWithAggregationInput | Gallery_contentOrderByWithAggregationInput[]
    by: Gallery_contentScalarFieldEnum[] | Gallery_contentScalarFieldEnum
    having?: Gallery_contentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gallery_contentCountAggregateInputType | true
    _min?: Gallery_contentMinAggregateInputType
    _max?: Gallery_contentMaxAggregateInputType
  }

  export type Gallery_contentGroupByOutputType = {
    id: string
    img_url: string
    _count: Gallery_contentCountAggregateOutputType | null
    _min: Gallery_contentMinAggregateOutputType | null
    _max: Gallery_contentMaxAggregateOutputType | null
  }

  type GetGallery_contentGroupByPayload<T extends Gallery_contentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gallery_contentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gallery_contentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gallery_contentGroupByOutputType[P]>
            : GetScalarType<T[P], Gallery_contentGroupByOutputType[P]>
        }
      >
    >


  export type Gallery_contentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["gallery_content"]>

  export type Gallery_contentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["gallery_content"]>

  export type Gallery_contentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["gallery_content"]>

  export type Gallery_contentSelectScalar = {
    id?: boolean
    img_url?: boolean
  }

  export type Gallery_contentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "img_url", ExtArgs["result"]["gallery_content"]>

  export type $Gallery_contentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gallery_content"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      img_url: string
    }, ExtArgs["result"]["gallery_content"]>
    composites: {}
  }

  type Gallery_contentGetPayload<S extends boolean | null | undefined | Gallery_contentDefaultArgs> = $Result.GetResult<Prisma.$Gallery_contentPayload, S>

  type Gallery_contentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Gallery_contentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Gallery_contentCountAggregateInputType | true
    }

  export interface Gallery_contentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gallery_content'], meta: { name: 'Gallery_content' } }
    /**
     * Find zero or one Gallery_content that matches the filter.
     * @param {Gallery_contentFindUniqueArgs} args - Arguments to find a Gallery_content
     * @example
     * // Get one Gallery_content
     * const gallery_content = await prisma.gallery_content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Gallery_contentFindUniqueArgs>(args: SelectSubset<T, Gallery_contentFindUniqueArgs<ExtArgs>>): Prisma__Gallery_contentClient<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gallery_content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Gallery_contentFindUniqueOrThrowArgs} args - Arguments to find a Gallery_content
     * @example
     * // Get one Gallery_content
     * const gallery_content = await prisma.gallery_content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Gallery_contentFindUniqueOrThrowArgs>(args: SelectSubset<T, Gallery_contentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Gallery_contentClient<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gallery_content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_contentFindFirstArgs} args - Arguments to find a Gallery_content
     * @example
     * // Get one Gallery_content
     * const gallery_content = await prisma.gallery_content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Gallery_contentFindFirstArgs>(args?: SelectSubset<T, Gallery_contentFindFirstArgs<ExtArgs>>): Prisma__Gallery_contentClient<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gallery_content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_contentFindFirstOrThrowArgs} args - Arguments to find a Gallery_content
     * @example
     * // Get one Gallery_content
     * const gallery_content = await prisma.gallery_content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Gallery_contentFindFirstOrThrowArgs>(args?: SelectSubset<T, Gallery_contentFindFirstOrThrowArgs<ExtArgs>>): Prisma__Gallery_contentClient<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gallery_contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_contentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gallery_contents
     * const gallery_contents = await prisma.gallery_content.findMany()
     * 
     * // Get first 10 Gallery_contents
     * const gallery_contents = await prisma.gallery_content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gallery_contentWithIdOnly = await prisma.gallery_content.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Gallery_contentFindManyArgs>(args?: SelectSubset<T, Gallery_contentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gallery_content.
     * @param {Gallery_contentCreateArgs} args - Arguments to create a Gallery_content.
     * @example
     * // Create one Gallery_content
     * const Gallery_content = await prisma.gallery_content.create({
     *   data: {
     *     // ... data to create a Gallery_content
     *   }
     * })
     * 
     */
    create<T extends Gallery_contentCreateArgs>(args: SelectSubset<T, Gallery_contentCreateArgs<ExtArgs>>): Prisma__Gallery_contentClient<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gallery_contents.
     * @param {Gallery_contentCreateManyArgs} args - Arguments to create many Gallery_contents.
     * @example
     * // Create many Gallery_contents
     * const gallery_content = await prisma.gallery_content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Gallery_contentCreateManyArgs>(args?: SelectSubset<T, Gallery_contentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gallery_contents and returns the data saved in the database.
     * @param {Gallery_contentCreateManyAndReturnArgs} args - Arguments to create many Gallery_contents.
     * @example
     * // Create many Gallery_contents
     * const gallery_content = await prisma.gallery_content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gallery_contents and only return the `id`
     * const gallery_contentWithIdOnly = await prisma.gallery_content.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Gallery_contentCreateManyAndReturnArgs>(args?: SelectSubset<T, Gallery_contentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gallery_content.
     * @param {Gallery_contentDeleteArgs} args - Arguments to delete one Gallery_content.
     * @example
     * // Delete one Gallery_content
     * const Gallery_content = await prisma.gallery_content.delete({
     *   where: {
     *     // ... filter to delete one Gallery_content
     *   }
     * })
     * 
     */
    delete<T extends Gallery_contentDeleteArgs>(args: SelectSubset<T, Gallery_contentDeleteArgs<ExtArgs>>): Prisma__Gallery_contentClient<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gallery_content.
     * @param {Gallery_contentUpdateArgs} args - Arguments to update one Gallery_content.
     * @example
     * // Update one Gallery_content
     * const gallery_content = await prisma.gallery_content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Gallery_contentUpdateArgs>(args: SelectSubset<T, Gallery_contentUpdateArgs<ExtArgs>>): Prisma__Gallery_contentClient<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gallery_contents.
     * @param {Gallery_contentDeleteManyArgs} args - Arguments to filter Gallery_contents to delete.
     * @example
     * // Delete a few Gallery_contents
     * const { count } = await prisma.gallery_content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Gallery_contentDeleteManyArgs>(args?: SelectSubset<T, Gallery_contentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gallery_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_contentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gallery_contents
     * const gallery_content = await prisma.gallery_content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Gallery_contentUpdateManyArgs>(args: SelectSubset<T, Gallery_contentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gallery_contents and returns the data updated in the database.
     * @param {Gallery_contentUpdateManyAndReturnArgs} args - Arguments to update many Gallery_contents.
     * @example
     * // Update many Gallery_contents
     * const gallery_content = await prisma.gallery_content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gallery_contents and only return the `id`
     * const gallery_contentWithIdOnly = await prisma.gallery_content.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Gallery_contentUpdateManyAndReturnArgs>(args: SelectSubset<T, Gallery_contentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gallery_content.
     * @param {Gallery_contentUpsertArgs} args - Arguments to update or create a Gallery_content.
     * @example
     * // Update or create a Gallery_content
     * const gallery_content = await prisma.gallery_content.upsert({
     *   create: {
     *     // ... data to create a Gallery_content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gallery_content we want to update
     *   }
     * })
     */
    upsert<T extends Gallery_contentUpsertArgs>(args: SelectSubset<T, Gallery_contentUpsertArgs<ExtArgs>>): Prisma__Gallery_contentClient<$Result.GetResult<Prisma.$Gallery_contentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gallery_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_contentCountArgs} args - Arguments to filter Gallery_contents to count.
     * @example
     * // Count the number of Gallery_contents
     * const count = await prisma.gallery_content.count({
     *   where: {
     *     // ... the filter for the Gallery_contents we want to count
     *   }
     * })
    **/
    count<T extends Gallery_contentCountArgs>(
      args?: Subset<T, Gallery_contentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gallery_contentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gallery_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_contentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gallery_contentAggregateArgs>(args: Subset<T, Gallery_contentAggregateArgs>): Prisma.PrismaPromise<GetGallery_contentAggregateType<T>>

    /**
     * Group by Gallery_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_contentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gallery_contentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gallery_contentGroupByArgs['orderBy'] }
        : { orderBy?: Gallery_contentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gallery_contentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGallery_contentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gallery_content model
   */
  readonly fields: Gallery_contentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gallery_content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Gallery_contentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gallery_content model
   */
  interface Gallery_contentFieldRefs {
    readonly id: FieldRef<"Gallery_content", 'String'>
    readonly img_url: FieldRef<"Gallery_content", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Gallery_content findUnique
   */
  export type Gallery_contentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_content to fetch.
     */
    where: Gallery_contentWhereUniqueInput
  }

  /**
   * Gallery_content findUniqueOrThrow
   */
  export type Gallery_contentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_content to fetch.
     */
    where: Gallery_contentWhereUniqueInput
  }

  /**
   * Gallery_content findFirst
   */
  export type Gallery_contentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_content to fetch.
     */
    where?: Gallery_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_contents to fetch.
     */
    orderBy?: Gallery_contentOrderByWithRelationInput | Gallery_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gallery_contents.
     */
    cursor?: Gallery_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gallery_contents.
     */
    distinct?: Gallery_contentScalarFieldEnum | Gallery_contentScalarFieldEnum[]
  }

  /**
   * Gallery_content findFirstOrThrow
   */
  export type Gallery_contentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_content to fetch.
     */
    where?: Gallery_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_contents to fetch.
     */
    orderBy?: Gallery_contentOrderByWithRelationInput | Gallery_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gallery_contents.
     */
    cursor?: Gallery_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gallery_contents.
     */
    distinct?: Gallery_contentScalarFieldEnum | Gallery_contentScalarFieldEnum[]
  }

  /**
   * Gallery_content findMany
   */
  export type Gallery_contentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_contents to fetch.
     */
    where?: Gallery_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_contents to fetch.
     */
    orderBy?: Gallery_contentOrderByWithRelationInput | Gallery_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gallery_contents.
     */
    cursor?: Gallery_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_contents.
     */
    skip?: number
    distinct?: Gallery_contentScalarFieldEnum | Gallery_contentScalarFieldEnum[]
  }

  /**
   * Gallery_content create
   */
  export type Gallery_contentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * The data needed to create a Gallery_content.
     */
    data: XOR<Gallery_contentCreateInput, Gallery_contentUncheckedCreateInput>
  }

  /**
   * Gallery_content createMany
   */
  export type Gallery_contentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gallery_contents.
     */
    data: Gallery_contentCreateManyInput | Gallery_contentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gallery_content createManyAndReturn
   */
  export type Gallery_contentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * The data used to create many Gallery_contents.
     */
    data: Gallery_contentCreateManyInput | Gallery_contentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gallery_content update
   */
  export type Gallery_contentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * The data needed to update a Gallery_content.
     */
    data: XOR<Gallery_contentUpdateInput, Gallery_contentUncheckedUpdateInput>
    /**
     * Choose, which Gallery_content to update.
     */
    where: Gallery_contentWhereUniqueInput
  }

  /**
   * Gallery_content updateMany
   */
  export type Gallery_contentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gallery_contents.
     */
    data: XOR<Gallery_contentUpdateManyMutationInput, Gallery_contentUncheckedUpdateManyInput>
    /**
     * Filter which Gallery_contents to update
     */
    where?: Gallery_contentWhereInput
    /**
     * Limit how many Gallery_contents to update.
     */
    limit?: number
  }

  /**
   * Gallery_content updateManyAndReturn
   */
  export type Gallery_contentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * The data used to update Gallery_contents.
     */
    data: XOR<Gallery_contentUpdateManyMutationInput, Gallery_contentUncheckedUpdateManyInput>
    /**
     * Filter which Gallery_contents to update
     */
    where?: Gallery_contentWhereInput
    /**
     * Limit how many Gallery_contents to update.
     */
    limit?: number
  }

  /**
   * Gallery_content upsert
   */
  export type Gallery_contentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * The filter to search for the Gallery_content to update in case it exists.
     */
    where: Gallery_contentWhereUniqueInput
    /**
     * In case the Gallery_content found by the `where` argument doesn't exist, create a new Gallery_content with this data.
     */
    create: XOR<Gallery_contentCreateInput, Gallery_contentUncheckedCreateInput>
    /**
     * In case the Gallery_content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Gallery_contentUpdateInput, Gallery_contentUncheckedUpdateInput>
  }

  /**
   * Gallery_content delete
   */
  export type Gallery_contentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
    /**
     * Filter which Gallery_content to delete.
     */
    where: Gallery_contentWhereUniqueInput
  }

  /**
   * Gallery_content deleteMany
   */
  export type Gallery_contentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gallery_contents to delete
     */
    where?: Gallery_contentWhereInput
    /**
     * Limit how many Gallery_contents to delete.
     */
    limit?: number
  }

  /**
   * Gallery_content without action
   */
  export type Gallery_contentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_content
     */
    select?: Gallery_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_content
     */
    omit?: Gallery_contentOmit<ExtArgs> | null
  }


  /**
   * Model Contact_title
   */

  export type AggregateContact_title = {
    _count: Contact_titleCountAggregateOutputType | null
    _min: Contact_titleMinAggregateOutputType | null
    _max: Contact_titleMaxAggregateOutputType | null
  }

  export type Contact_titleMinAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    img_url: string | null
  }

  export type Contact_titleMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    img_url: string | null
  }

  export type Contact_titleCountAggregateOutputType = {
    id: number
    lang: number
    title: number
    img_url: number
    _all: number
  }


  export type Contact_titleMinAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    img_url?: true
  }

  export type Contact_titleMaxAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    img_url?: true
  }

  export type Contact_titleCountAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    img_url?: true
    _all?: true
  }

  export type Contact_titleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_title to aggregate.
     */
    where?: Contact_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_titles to fetch.
     */
    orderBy?: Contact_titleOrderByWithRelationInput | Contact_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Contact_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_titles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contact_titles
    **/
    _count?: true | Contact_titleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_titleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_titleMaxAggregateInputType
  }

  export type GetContact_titleAggregateType<T extends Contact_titleAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_title]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_title[P]>
      : GetScalarType<T[P], AggregateContact_title[P]>
  }




  export type Contact_titleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Contact_titleWhereInput
    orderBy?: Contact_titleOrderByWithAggregationInput | Contact_titleOrderByWithAggregationInput[]
    by: Contact_titleScalarFieldEnum[] | Contact_titleScalarFieldEnum
    having?: Contact_titleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_titleCountAggregateInputType | true
    _min?: Contact_titleMinAggregateInputType
    _max?: Contact_titleMaxAggregateInputType
  }

  export type Contact_titleGroupByOutputType = {
    id: string
    lang: string
    title: string
    img_url: string
    _count: Contact_titleCountAggregateOutputType | null
    _min: Contact_titleMinAggregateOutputType | null
    _max: Contact_titleMaxAggregateOutputType | null
  }

  type GetContact_titleGroupByPayload<T extends Contact_titleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_titleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_titleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_titleGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_titleGroupByOutputType[P]>
        }
      >
    >


  export type Contact_titleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["contact_title"]>

  export type Contact_titleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["contact_title"]>

  export type Contact_titleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["contact_title"]>

  export type Contact_titleSelectScalar = {
    id?: boolean
    lang?: boolean
    title?: boolean
    img_url?: boolean
  }

  export type Contact_titleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "title" | "img_url", ExtArgs["result"]["contact_title"]>

  export type $Contact_titlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact_title"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      title: string
      img_url: string
    }, ExtArgs["result"]["contact_title"]>
    composites: {}
  }

  type Contact_titleGetPayload<S extends boolean | null | undefined | Contact_titleDefaultArgs> = $Result.GetResult<Prisma.$Contact_titlePayload, S>

  type Contact_titleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Contact_titleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Contact_titleCountAggregateInputType | true
    }

  export interface Contact_titleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact_title'], meta: { name: 'Contact_title' } }
    /**
     * Find zero or one Contact_title that matches the filter.
     * @param {Contact_titleFindUniqueArgs} args - Arguments to find a Contact_title
     * @example
     * // Get one Contact_title
     * const contact_title = await prisma.contact_title.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Contact_titleFindUniqueArgs>(args: SelectSubset<T, Contact_titleFindUniqueArgs<ExtArgs>>): Prisma__Contact_titleClient<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact_title that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Contact_titleFindUniqueOrThrowArgs} args - Arguments to find a Contact_title
     * @example
     * // Get one Contact_title
     * const contact_title = await prisma.contact_title.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Contact_titleFindUniqueOrThrowArgs>(args: SelectSubset<T, Contact_titleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Contact_titleClient<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_title that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_titleFindFirstArgs} args - Arguments to find a Contact_title
     * @example
     * // Get one Contact_title
     * const contact_title = await prisma.contact_title.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Contact_titleFindFirstArgs>(args?: SelectSubset<T, Contact_titleFindFirstArgs<ExtArgs>>): Prisma__Contact_titleClient<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_title that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_titleFindFirstOrThrowArgs} args - Arguments to find a Contact_title
     * @example
     * // Get one Contact_title
     * const contact_title = await prisma.contact_title.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Contact_titleFindFirstOrThrowArgs>(args?: SelectSubset<T, Contact_titleFindFirstOrThrowArgs<ExtArgs>>): Prisma__Contact_titleClient<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contact_titles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_titleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_titles
     * const contact_titles = await prisma.contact_title.findMany()
     * 
     * // Get first 10 Contact_titles
     * const contact_titles = await prisma.contact_title.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_titleWithIdOnly = await prisma.contact_title.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Contact_titleFindManyArgs>(args?: SelectSubset<T, Contact_titleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact_title.
     * @param {Contact_titleCreateArgs} args - Arguments to create a Contact_title.
     * @example
     * // Create one Contact_title
     * const Contact_title = await prisma.contact_title.create({
     *   data: {
     *     // ... data to create a Contact_title
     *   }
     * })
     * 
     */
    create<T extends Contact_titleCreateArgs>(args: SelectSubset<T, Contact_titleCreateArgs<ExtArgs>>): Prisma__Contact_titleClient<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contact_titles.
     * @param {Contact_titleCreateManyArgs} args - Arguments to create many Contact_titles.
     * @example
     * // Create many Contact_titles
     * const contact_title = await prisma.contact_title.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Contact_titleCreateManyArgs>(args?: SelectSubset<T, Contact_titleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_titles and returns the data saved in the database.
     * @param {Contact_titleCreateManyAndReturnArgs} args - Arguments to create many Contact_titles.
     * @example
     * // Create many Contact_titles
     * const contact_title = await prisma.contact_title.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_titles and only return the `id`
     * const contact_titleWithIdOnly = await prisma.contact_title.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Contact_titleCreateManyAndReturnArgs>(args?: SelectSubset<T, Contact_titleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact_title.
     * @param {Contact_titleDeleteArgs} args - Arguments to delete one Contact_title.
     * @example
     * // Delete one Contact_title
     * const Contact_title = await prisma.contact_title.delete({
     *   where: {
     *     // ... filter to delete one Contact_title
     *   }
     * })
     * 
     */
    delete<T extends Contact_titleDeleteArgs>(args: SelectSubset<T, Contact_titleDeleteArgs<ExtArgs>>): Prisma__Contact_titleClient<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact_title.
     * @param {Contact_titleUpdateArgs} args - Arguments to update one Contact_title.
     * @example
     * // Update one Contact_title
     * const contact_title = await prisma.contact_title.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Contact_titleUpdateArgs>(args: SelectSubset<T, Contact_titleUpdateArgs<ExtArgs>>): Prisma__Contact_titleClient<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contact_titles.
     * @param {Contact_titleDeleteManyArgs} args - Arguments to filter Contact_titles to delete.
     * @example
     * // Delete a few Contact_titles
     * const { count } = await prisma.contact_title.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Contact_titleDeleteManyArgs>(args?: SelectSubset<T, Contact_titleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_titles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_titleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_titles
     * const contact_title = await prisma.contact_title.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Contact_titleUpdateManyArgs>(args: SelectSubset<T, Contact_titleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_titles and returns the data updated in the database.
     * @param {Contact_titleUpdateManyAndReturnArgs} args - Arguments to update many Contact_titles.
     * @example
     * // Update many Contact_titles
     * const contact_title = await prisma.contact_title.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contact_titles and only return the `id`
     * const contact_titleWithIdOnly = await prisma.contact_title.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Contact_titleUpdateManyAndReturnArgs>(args: SelectSubset<T, Contact_titleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact_title.
     * @param {Contact_titleUpsertArgs} args - Arguments to update or create a Contact_title.
     * @example
     * // Update or create a Contact_title
     * const contact_title = await prisma.contact_title.upsert({
     *   create: {
     *     // ... data to create a Contact_title
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_title we want to update
     *   }
     * })
     */
    upsert<T extends Contact_titleUpsertArgs>(args: SelectSubset<T, Contact_titleUpsertArgs<ExtArgs>>): Prisma__Contact_titleClient<$Result.GetResult<Prisma.$Contact_titlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contact_titles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_titleCountArgs} args - Arguments to filter Contact_titles to count.
     * @example
     * // Count the number of Contact_titles
     * const count = await prisma.contact_title.count({
     *   where: {
     *     // ... the filter for the Contact_titles we want to count
     *   }
     * })
    **/
    count<T extends Contact_titleCountArgs>(
      args?: Subset<T, Contact_titleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_titleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_title.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_titleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_titleAggregateArgs>(args: Subset<T, Contact_titleAggregateArgs>): Prisma.PrismaPromise<GetContact_titleAggregateType<T>>

    /**
     * Group by Contact_title.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_titleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_titleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_titleGroupByArgs['orderBy'] }
        : { orderBy?: Contact_titleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_titleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_titleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact_title model
   */
  readonly fields: Contact_titleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact_title.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Contact_titleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact_title model
   */
  interface Contact_titleFieldRefs {
    readonly id: FieldRef<"Contact_title", 'String'>
    readonly lang: FieldRef<"Contact_title", 'String'>
    readonly title: FieldRef<"Contact_title", 'String'>
    readonly img_url: FieldRef<"Contact_title", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact_title findUnique
   */
  export type Contact_titleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * Filter, which Contact_title to fetch.
     */
    where: Contact_titleWhereUniqueInput
  }

  /**
   * Contact_title findUniqueOrThrow
   */
  export type Contact_titleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * Filter, which Contact_title to fetch.
     */
    where: Contact_titleWhereUniqueInput
  }

  /**
   * Contact_title findFirst
   */
  export type Contact_titleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * Filter, which Contact_title to fetch.
     */
    where?: Contact_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_titles to fetch.
     */
    orderBy?: Contact_titleOrderByWithRelationInput | Contact_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_titles.
     */
    cursor?: Contact_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_titles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_titles.
     */
    distinct?: Contact_titleScalarFieldEnum | Contact_titleScalarFieldEnum[]
  }

  /**
   * Contact_title findFirstOrThrow
   */
  export type Contact_titleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * Filter, which Contact_title to fetch.
     */
    where?: Contact_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_titles to fetch.
     */
    orderBy?: Contact_titleOrderByWithRelationInput | Contact_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_titles.
     */
    cursor?: Contact_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_titles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_titles.
     */
    distinct?: Contact_titleScalarFieldEnum | Contact_titleScalarFieldEnum[]
  }

  /**
   * Contact_title findMany
   */
  export type Contact_titleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * Filter, which Contact_titles to fetch.
     */
    where?: Contact_titleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_titles to fetch.
     */
    orderBy?: Contact_titleOrderByWithRelationInput | Contact_titleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contact_titles.
     */
    cursor?: Contact_titleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_titles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_titles.
     */
    skip?: number
    distinct?: Contact_titleScalarFieldEnum | Contact_titleScalarFieldEnum[]
  }

  /**
   * Contact_title create
   */
  export type Contact_titleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * The data needed to create a Contact_title.
     */
    data: XOR<Contact_titleCreateInput, Contact_titleUncheckedCreateInput>
  }

  /**
   * Contact_title createMany
   */
  export type Contact_titleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contact_titles.
     */
    data: Contact_titleCreateManyInput | Contact_titleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_title createManyAndReturn
   */
  export type Contact_titleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * The data used to create many Contact_titles.
     */
    data: Contact_titleCreateManyInput | Contact_titleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_title update
   */
  export type Contact_titleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * The data needed to update a Contact_title.
     */
    data: XOR<Contact_titleUpdateInput, Contact_titleUncheckedUpdateInput>
    /**
     * Choose, which Contact_title to update.
     */
    where: Contact_titleWhereUniqueInput
  }

  /**
   * Contact_title updateMany
   */
  export type Contact_titleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contact_titles.
     */
    data: XOR<Contact_titleUpdateManyMutationInput, Contact_titleUncheckedUpdateManyInput>
    /**
     * Filter which Contact_titles to update
     */
    where?: Contact_titleWhereInput
    /**
     * Limit how many Contact_titles to update.
     */
    limit?: number
  }

  /**
   * Contact_title updateManyAndReturn
   */
  export type Contact_titleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * The data used to update Contact_titles.
     */
    data: XOR<Contact_titleUpdateManyMutationInput, Contact_titleUncheckedUpdateManyInput>
    /**
     * Filter which Contact_titles to update
     */
    where?: Contact_titleWhereInput
    /**
     * Limit how many Contact_titles to update.
     */
    limit?: number
  }

  /**
   * Contact_title upsert
   */
  export type Contact_titleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * The filter to search for the Contact_title to update in case it exists.
     */
    where: Contact_titleWhereUniqueInput
    /**
     * In case the Contact_title found by the `where` argument doesn't exist, create a new Contact_title with this data.
     */
    create: XOR<Contact_titleCreateInput, Contact_titleUncheckedCreateInput>
    /**
     * In case the Contact_title was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Contact_titleUpdateInput, Contact_titleUncheckedUpdateInput>
  }

  /**
   * Contact_title delete
   */
  export type Contact_titleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
    /**
     * Filter which Contact_title to delete.
     */
    where: Contact_titleWhereUniqueInput
  }

  /**
   * Contact_title deleteMany
   */
  export type Contact_titleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_titles to delete
     */
    where?: Contact_titleWhereInput
    /**
     * Limit how many Contact_titles to delete.
     */
    limit?: number
  }

  /**
   * Contact_title without action
   */
  export type Contact_titleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_title
     */
    select?: Contact_titleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_title
     */
    omit?: Contact_titleOmit<ExtArgs> | null
  }


  /**
   * Model Contact_info
   */

  export type AggregateContact_info = {
    _count: Contact_infoCountAggregateOutputType | null
    _min: Contact_infoMinAggregateOutputType | null
    _max: Contact_infoMaxAggregateOutputType | null
  }

  export type Contact_infoMinAggregateOutputType = {
    id: string | null
    lang: string | null
    name: string | null
    icons1: string | null
    href1: string | null
    icons2: string | null
    phone1: string | null
    phone2: string | null
    icons3: string | null
    mail1: string | null
    mail2: string | null
  }

  export type Contact_infoMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    name: string | null
    icons1: string | null
    href1: string | null
    icons2: string | null
    phone1: string | null
    phone2: string | null
    icons3: string | null
    mail1: string | null
    mail2: string | null
  }

  export type Contact_infoCountAggregateOutputType = {
    id: number
    lang: number
    name: number
    icons1: number
    href1: number
    icons2: number
    phone1: number
    phone2: number
    icons3: number
    mail1: number
    mail2: number
    _all: number
  }


  export type Contact_infoMinAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    icons1?: true
    href1?: true
    icons2?: true
    phone1?: true
    phone2?: true
    icons3?: true
    mail1?: true
    mail2?: true
  }

  export type Contact_infoMaxAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    icons1?: true
    href1?: true
    icons2?: true
    phone1?: true
    phone2?: true
    icons3?: true
    mail1?: true
    mail2?: true
  }

  export type Contact_infoCountAggregateInputType = {
    id?: true
    lang?: true
    name?: true
    icons1?: true
    href1?: true
    icons2?: true
    phone1?: true
    phone2?: true
    icons3?: true
    mail1?: true
    mail2?: true
    _all?: true
  }

  export type Contact_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_info to aggregate.
     */
    where?: Contact_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_infos to fetch.
     */
    orderBy?: Contact_infoOrderByWithRelationInput | Contact_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Contact_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contact_infos
    **/
    _count?: true | Contact_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_infoMaxAggregateInputType
  }

  export type GetContact_infoAggregateType<T extends Contact_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_info[P]>
      : GetScalarType<T[P], AggregateContact_info[P]>
  }




  export type Contact_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Contact_infoWhereInput
    orderBy?: Contact_infoOrderByWithAggregationInput | Contact_infoOrderByWithAggregationInput[]
    by: Contact_infoScalarFieldEnum[] | Contact_infoScalarFieldEnum
    having?: Contact_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_infoCountAggregateInputType | true
    _min?: Contact_infoMinAggregateInputType
    _max?: Contact_infoMaxAggregateInputType
  }

  export type Contact_infoGroupByOutputType = {
    id: string
    lang: string
    name: string
    icons1: string
    href1: string
    icons2: string
    phone1: string
    phone2: string
    icons3: string
    mail1: string
    mail2: string
    _count: Contact_infoCountAggregateOutputType | null
    _min: Contact_infoMinAggregateOutputType | null
    _max: Contact_infoMaxAggregateOutputType | null
  }

  type GetContact_infoGroupByPayload<T extends Contact_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_infoGroupByOutputType[P]>
        }
      >
    >


  export type Contact_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    name?: boolean
    icons1?: boolean
    href1?: boolean
    icons2?: boolean
    phone1?: boolean
    phone2?: boolean
    icons3?: boolean
    mail1?: boolean
    mail2?: boolean
  }, ExtArgs["result"]["contact_info"]>

  export type Contact_infoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    name?: boolean
    icons1?: boolean
    href1?: boolean
    icons2?: boolean
    phone1?: boolean
    phone2?: boolean
    icons3?: boolean
    mail1?: boolean
    mail2?: boolean
  }, ExtArgs["result"]["contact_info"]>

  export type Contact_infoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    name?: boolean
    icons1?: boolean
    href1?: boolean
    icons2?: boolean
    phone1?: boolean
    phone2?: boolean
    icons3?: boolean
    mail1?: boolean
    mail2?: boolean
  }, ExtArgs["result"]["contact_info"]>

  export type Contact_infoSelectScalar = {
    id?: boolean
    lang?: boolean
    name?: boolean
    icons1?: boolean
    href1?: boolean
    icons2?: boolean
    phone1?: boolean
    phone2?: boolean
    icons3?: boolean
    mail1?: boolean
    mail2?: boolean
  }

  export type Contact_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "name" | "icons1" | "href1" | "icons2" | "phone1" | "phone2" | "icons3" | "mail1" | "mail2", ExtArgs["result"]["contact_info"]>

  export type $Contact_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact_info"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      name: string
      icons1: string
      href1: string
      icons2: string
      phone1: string
      phone2: string
      icons3: string
      mail1: string
      mail2: string
    }, ExtArgs["result"]["contact_info"]>
    composites: {}
  }

  type Contact_infoGetPayload<S extends boolean | null | undefined | Contact_infoDefaultArgs> = $Result.GetResult<Prisma.$Contact_infoPayload, S>

  type Contact_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Contact_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Contact_infoCountAggregateInputType | true
    }

  export interface Contact_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact_info'], meta: { name: 'Contact_info' } }
    /**
     * Find zero or one Contact_info that matches the filter.
     * @param {Contact_infoFindUniqueArgs} args - Arguments to find a Contact_info
     * @example
     * // Get one Contact_info
     * const contact_info = await prisma.contact_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Contact_infoFindUniqueArgs>(args: SelectSubset<T, Contact_infoFindUniqueArgs<ExtArgs>>): Prisma__Contact_infoClient<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Contact_infoFindUniqueOrThrowArgs} args - Arguments to find a Contact_info
     * @example
     * // Get one Contact_info
     * const contact_info = await prisma.contact_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Contact_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, Contact_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Contact_infoClient<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_infoFindFirstArgs} args - Arguments to find a Contact_info
     * @example
     * // Get one Contact_info
     * const contact_info = await prisma.contact_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Contact_infoFindFirstArgs>(args?: SelectSubset<T, Contact_infoFindFirstArgs<ExtArgs>>): Prisma__Contact_infoClient<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_infoFindFirstOrThrowArgs} args - Arguments to find a Contact_info
     * @example
     * // Get one Contact_info
     * const contact_info = await prisma.contact_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Contact_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, Contact_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Contact_infoClient<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contact_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_infos
     * const contact_infos = await prisma.contact_info.findMany()
     * 
     * // Get first 10 Contact_infos
     * const contact_infos = await prisma.contact_info.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_infoWithIdOnly = await prisma.contact_info.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Contact_infoFindManyArgs>(args?: SelectSubset<T, Contact_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact_info.
     * @param {Contact_infoCreateArgs} args - Arguments to create a Contact_info.
     * @example
     * // Create one Contact_info
     * const Contact_info = await prisma.contact_info.create({
     *   data: {
     *     // ... data to create a Contact_info
     *   }
     * })
     * 
     */
    create<T extends Contact_infoCreateArgs>(args: SelectSubset<T, Contact_infoCreateArgs<ExtArgs>>): Prisma__Contact_infoClient<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contact_infos.
     * @param {Contact_infoCreateManyArgs} args - Arguments to create many Contact_infos.
     * @example
     * // Create many Contact_infos
     * const contact_info = await prisma.contact_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Contact_infoCreateManyArgs>(args?: SelectSubset<T, Contact_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_infos and returns the data saved in the database.
     * @param {Contact_infoCreateManyAndReturnArgs} args - Arguments to create many Contact_infos.
     * @example
     * // Create many Contact_infos
     * const contact_info = await prisma.contact_info.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_infos and only return the `id`
     * const contact_infoWithIdOnly = await prisma.contact_info.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Contact_infoCreateManyAndReturnArgs>(args?: SelectSubset<T, Contact_infoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact_info.
     * @param {Contact_infoDeleteArgs} args - Arguments to delete one Contact_info.
     * @example
     * // Delete one Contact_info
     * const Contact_info = await prisma.contact_info.delete({
     *   where: {
     *     // ... filter to delete one Contact_info
     *   }
     * })
     * 
     */
    delete<T extends Contact_infoDeleteArgs>(args: SelectSubset<T, Contact_infoDeleteArgs<ExtArgs>>): Prisma__Contact_infoClient<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact_info.
     * @param {Contact_infoUpdateArgs} args - Arguments to update one Contact_info.
     * @example
     * // Update one Contact_info
     * const contact_info = await prisma.contact_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Contact_infoUpdateArgs>(args: SelectSubset<T, Contact_infoUpdateArgs<ExtArgs>>): Prisma__Contact_infoClient<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contact_infos.
     * @param {Contact_infoDeleteManyArgs} args - Arguments to filter Contact_infos to delete.
     * @example
     * // Delete a few Contact_infos
     * const { count } = await prisma.contact_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Contact_infoDeleteManyArgs>(args?: SelectSubset<T, Contact_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_infos
     * const contact_info = await prisma.contact_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Contact_infoUpdateManyArgs>(args: SelectSubset<T, Contact_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_infos and returns the data updated in the database.
     * @param {Contact_infoUpdateManyAndReturnArgs} args - Arguments to update many Contact_infos.
     * @example
     * // Update many Contact_infos
     * const contact_info = await prisma.contact_info.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contact_infos and only return the `id`
     * const contact_infoWithIdOnly = await prisma.contact_info.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Contact_infoUpdateManyAndReturnArgs>(args: SelectSubset<T, Contact_infoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact_info.
     * @param {Contact_infoUpsertArgs} args - Arguments to update or create a Contact_info.
     * @example
     * // Update or create a Contact_info
     * const contact_info = await prisma.contact_info.upsert({
     *   create: {
     *     // ... data to create a Contact_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_info we want to update
     *   }
     * })
     */
    upsert<T extends Contact_infoUpsertArgs>(args: SelectSubset<T, Contact_infoUpsertArgs<ExtArgs>>): Prisma__Contact_infoClient<$Result.GetResult<Prisma.$Contact_infoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contact_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_infoCountArgs} args - Arguments to filter Contact_infos to count.
     * @example
     * // Count the number of Contact_infos
     * const count = await prisma.contact_info.count({
     *   where: {
     *     // ... the filter for the Contact_infos we want to count
     *   }
     * })
    **/
    count<T extends Contact_infoCountArgs>(
      args?: Subset<T, Contact_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_infoAggregateArgs>(args: Subset<T, Contact_infoAggregateArgs>): Prisma.PrismaPromise<GetContact_infoAggregateType<T>>

    /**
     * Group by Contact_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_infoGroupByArgs['orderBy'] }
        : { orderBy?: Contact_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact_info model
   */
  readonly fields: Contact_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Contact_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact_info model
   */
  interface Contact_infoFieldRefs {
    readonly id: FieldRef<"Contact_info", 'String'>
    readonly lang: FieldRef<"Contact_info", 'String'>
    readonly name: FieldRef<"Contact_info", 'String'>
    readonly icons1: FieldRef<"Contact_info", 'String'>
    readonly href1: FieldRef<"Contact_info", 'String'>
    readonly icons2: FieldRef<"Contact_info", 'String'>
    readonly phone1: FieldRef<"Contact_info", 'String'>
    readonly phone2: FieldRef<"Contact_info", 'String'>
    readonly icons3: FieldRef<"Contact_info", 'String'>
    readonly mail1: FieldRef<"Contact_info", 'String'>
    readonly mail2: FieldRef<"Contact_info", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact_info findUnique
   */
  export type Contact_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * Filter, which Contact_info to fetch.
     */
    where: Contact_infoWhereUniqueInput
  }

  /**
   * Contact_info findUniqueOrThrow
   */
  export type Contact_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * Filter, which Contact_info to fetch.
     */
    where: Contact_infoWhereUniqueInput
  }

  /**
   * Contact_info findFirst
   */
  export type Contact_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * Filter, which Contact_info to fetch.
     */
    where?: Contact_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_infos to fetch.
     */
    orderBy?: Contact_infoOrderByWithRelationInput | Contact_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_infos.
     */
    cursor?: Contact_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_infos.
     */
    distinct?: Contact_infoScalarFieldEnum | Contact_infoScalarFieldEnum[]
  }

  /**
   * Contact_info findFirstOrThrow
   */
  export type Contact_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * Filter, which Contact_info to fetch.
     */
    where?: Contact_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_infos to fetch.
     */
    orderBy?: Contact_infoOrderByWithRelationInput | Contact_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_infos.
     */
    cursor?: Contact_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_infos.
     */
    distinct?: Contact_infoScalarFieldEnum | Contact_infoScalarFieldEnum[]
  }

  /**
   * Contact_info findMany
   */
  export type Contact_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * Filter, which Contact_infos to fetch.
     */
    where?: Contact_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_infos to fetch.
     */
    orderBy?: Contact_infoOrderByWithRelationInput | Contact_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contact_infos.
     */
    cursor?: Contact_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_infos.
     */
    skip?: number
    distinct?: Contact_infoScalarFieldEnum | Contact_infoScalarFieldEnum[]
  }

  /**
   * Contact_info create
   */
  export type Contact_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * The data needed to create a Contact_info.
     */
    data: XOR<Contact_infoCreateInput, Contact_infoUncheckedCreateInput>
  }

  /**
   * Contact_info createMany
   */
  export type Contact_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contact_infos.
     */
    data: Contact_infoCreateManyInput | Contact_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_info createManyAndReturn
   */
  export type Contact_infoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * The data used to create many Contact_infos.
     */
    data: Contact_infoCreateManyInput | Contact_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_info update
   */
  export type Contact_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * The data needed to update a Contact_info.
     */
    data: XOR<Contact_infoUpdateInput, Contact_infoUncheckedUpdateInput>
    /**
     * Choose, which Contact_info to update.
     */
    where: Contact_infoWhereUniqueInput
  }

  /**
   * Contact_info updateMany
   */
  export type Contact_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contact_infos.
     */
    data: XOR<Contact_infoUpdateManyMutationInput, Contact_infoUncheckedUpdateManyInput>
    /**
     * Filter which Contact_infos to update
     */
    where?: Contact_infoWhereInput
    /**
     * Limit how many Contact_infos to update.
     */
    limit?: number
  }

  /**
   * Contact_info updateManyAndReturn
   */
  export type Contact_infoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * The data used to update Contact_infos.
     */
    data: XOR<Contact_infoUpdateManyMutationInput, Contact_infoUncheckedUpdateManyInput>
    /**
     * Filter which Contact_infos to update
     */
    where?: Contact_infoWhereInput
    /**
     * Limit how many Contact_infos to update.
     */
    limit?: number
  }

  /**
   * Contact_info upsert
   */
  export type Contact_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * The filter to search for the Contact_info to update in case it exists.
     */
    where: Contact_infoWhereUniqueInput
    /**
     * In case the Contact_info found by the `where` argument doesn't exist, create a new Contact_info with this data.
     */
    create: XOR<Contact_infoCreateInput, Contact_infoUncheckedCreateInput>
    /**
     * In case the Contact_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Contact_infoUpdateInput, Contact_infoUncheckedUpdateInput>
  }

  /**
   * Contact_info delete
   */
  export type Contact_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
    /**
     * Filter which Contact_info to delete.
     */
    where: Contact_infoWhereUniqueInput
  }

  /**
   * Contact_info deleteMany
   */
  export type Contact_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_infos to delete
     */
    where?: Contact_infoWhereInput
    /**
     * Limit how many Contact_infos to delete.
     */
    limit?: number
  }

  /**
   * Contact_info without action
   */
  export type Contact_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_info
     */
    select?: Contact_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_info
     */
    omit?: Contact_infoOmit<ExtArgs> | null
  }


  /**
   * Model Footer
   */

  export type AggregateFooter = {
    _count: FooterCountAggregateOutputType | null
    _min: FooterMinAggregateOutputType | null
    _max: FooterMaxAggregateOutputType | null
  }

  export type FooterMinAggregateOutputType = {
    id: string | null
    lang: string | null
    background_img: string | null
    logo_img: string | null
    title: string | null
    address: string | null
    email: string | null
    phone1: string | null
    phone2: string | null
  }

  export type FooterMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    background_img: string | null
    logo_img: string | null
    title: string | null
    address: string | null
    email: string | null
    phone1: string | null
    phone2: string | null
  }

  export type FooterCountAggregateOutputType = {
    id: number
    lang: number
    background_img: number
    logo_img: number
    title: number
    address: number
    email: number
    phone1: number
    phone2: number
    _all: number
  }


  export type FooterMinAggregateInputType = {
    id?: true
    lang?: true
    background_img?: true
    logo_img?: true
    title?: true
    address?: true
    email?: true
    phone1?: true
    phone2?: true
  }

  export type FooterMaxAggregateInputType = {
    id?: true
    lang?: true
    background_img?: true
    logo_img?: true
    title?: true
    address?: true
    email?: true
    phone1?: true
    phone2?: true
  }

  export type FooterCountAggregateInputType = {
    id?: true
    lang?: true
    background_img?: true
    logo_img?: true
    title?: true
    address?: true
    email?: true
    phone1?: true
    phone2?: true
    _all?: true
  }

  export type FooterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Footer to aggregate.
     */
    where?: FooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Footers to fetch.
     */
    orderBy?: FooterOrderByWithRelationInput | FooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Footers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Footers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Footers
    **/
    _count?: true | FooterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FooterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FooterMaxAggregateInputType
  }

  export type GetFooterAggregateType<T extends FooterAggregateArgs> = {
        [P in keyof T & keyof AggregateFooter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFooter[P]>
      : GetScalarType<T[P], AggregateFooter[P]>
  }




  export type FooterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FooterWhereInput
    orderBy?: FooterOrderByWithAggregationInput | FooterOrderByWithAggregationInput[]
    by: FooterScalarFieldEnum[] | FooterScalarFieldEnum
    having?: FooterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FooterCountAggregateInputType | true
    _min?: FooterMinAggregateInputType
    _max?: FooterMaxAggregateInputType
  }

  export type FooterGroupByOutputType = {
    id: string
    lang: string
    background_img: string
    logo_img: string
    title: string
    address: string
    email: string
    phone1: string
    phone2: string
    _count: FooterCountAggregateOutputType | null
    _min: FooterMinAggregateOutputType | null
    _max: FooterMaxAggregateOutputType | null
  }

  type GetFooterGroupByPayload<T extends FooterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FooterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FooterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FooterGroupByOutputType[P]>
            : GetScalarType<T[P], FooterGroupByOutputType[P]>
        }
      >
    >


  export type FooterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    background_img?: boolean
    logo_img?: boolean
    title?: boolean
    address?: boolean
    email?: boolean
    phone1?: boolean
    phone2?: boolean
  }, ExtArgs["result"]["footer"]>

  export type FooterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    background_img?: boolean
    logo_img?: boolean
    title?: boolean
    address?: boolean
    email?: boolean
    phone1?: boolean
    phone2?: boolean
  }, ExtArgs["result"]["footer"]>

  export type FooterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    background_img?: boolean
    logo_img?: boolean
    title?: boolean
    address?: boolean
    email?: boolean
    phone1?: boolean
    phone2?: boolean
  }, ExtArgs["result"]["footer"]>

  export type FooterSelectScalar = {
    id?: boolean
    lang?: boolean
    background_img?: boolean
    logo_img?: boolean
    title?: boolean
    address?: boolean
    email?: boolean
    phone1?: boolean
    phone2?: boolean
  }

  export type FooterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "background_img" | "logo_img" | "title" | "address" | "email" | "phone1" | "phone2", ExtArgs["result"]["footer"]>

  export type $FooterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Footer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      background_img: string
      logo_img: string
      title: string
      address: string
      email: string
      phone1: string
      phone2: string
    }, ExtArgs["result"]["footer"]>
    composites: {}
  }

  type FooterGetPayload<S extends boolean | null | undefined | FooterDefaultArgs> = $Result.GetResult<Prisma.$FooterPayload, S>

  type FooterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FooterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FooterCountAggregateInputType | true
    }

  export interface FooterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Footer'], meta: { name: 'Footer' } }
    /**
     * Find zero or one Footer that matches the filter.
     * @param {FooterFindUniqueArgs} args - Arguments to find a Footer
     * @example
     * // Get one Footer
     * const footer = await prisma.footer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FooterFindUniqueArgs>(args: SelectSubset<T, FooterFindUniqueArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Footer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FooterFindUniqueOrThrowArgs} args - Arguments to find a Footer
     * @example
     * // Get one Footer
     * const footer = await prisma.footer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FooterFindUniqueOrThrowArgs>(args: SelectSubset<T, FooterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Footer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterFindFirstArgs} args - Arguments to find a Footer
     * @example
     * // Get one Footer
     * const footer = await prisma.footer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FooterFindFirstArgs>(args?: SelectSubset<T, FooterFindFirstArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Footer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterFindFirstOrThrowArgs} args - Arguments to find a Footer
     * @example
     * // Get one Footer
     * const footer = await prisma.footer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FooterFindFirstOrThrowArgs>(args?: SelectSubset<T, FooterFindFirstOrThrowArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Footers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Footers
     * const footers = await prisma.footer.findMany()
     * 
     * // Get first 10 Footers
     * const footers = await prisma.footer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const footerWithIdOnly = await prisma.footer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FooterFindManyArgs>(args?: SelectSubset<T, FooterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Footer.
     * @param {FooterCreateArgs} args - Arguments to create a Footer.
     * @example
     * // Create one Footer
     * const Footer = await prisma.footer.create({
     *   data: {
     *     // ... data to create a Footer
     *   }
     * })
     * 
     */
    create<T extends FooterCreateArgs>(args: SelectSubset<T, FooterCreateArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Footers.
     * @param {FooterCreateManyArgs} args - Arguments to create many Footers.
     * @example
     * // Create many Footers
     * const footer = await prisma.footer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FooterCreateManyArgs>(args?: SelectSubset<T, FooterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Footers and returns the data saved in the database.
     * @param {FooterCreateManyAndReturnArgs} args - Arguments to create many Footers.
     * @example
     * // Create many Footers
     * const footer = await prisma.footer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Footers and only return the `id`
     * const footerWithIdOnly = await prisma.footer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FooterCreateManyAndReturnArgs>(args?: SelectSubset<T, FooterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Footer.
     * @param {FooterDeleteArgs} args - Arguments to delete one Footer.
     * @example
     * // Delete one Footer
     * const Footer = await prisma.footer.delete({
     *   where: {
     *     // ... filter to delete one Footer
     *   }
     * })
     * 
     */
    delete<T extends FooterDeleteArgs>(args: SelectSubset<T, FooterDeleteArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Footer.
     * @param {FooterUpdateArgs} args - Arguments to update one Footer.
     * @example
     * // Update one Footer
     * const footer = await prisma.footer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FooterUpdateArgs>(args: SelectSubset<T, FooterUpdateArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Footers.
     * @param {FooterDeleteManyArgs} args - Arguments to filter Footers to delete.
     * @example
     * // Delete a few Footers
     * const { count } = await prisma.footer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FooterDeleteManyArgs>(args?: SelectSubset<T, FooterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Footers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Footers
     * const footer = await prisma.footer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FooterUpdateManyArgs>(args: SelectSubset<T, FooterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Footers and returns the data updated in the database.
     * @param {FooterUpdateManyAndReturnArgs} args - Arguments to update many Footers.
     * @example
     * // Update many Footers
     * const footer = await prisma.footer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Footers and only return the `id`
     * const footerWithIdOnly = await prisma.footer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FooterUpdateManyAndReturnArgs>(args: SelectSubset<T, FooterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Footer.
     * @param {FooterUpsertArgs} args - Arguments to update or create a Footer.
     * @example
     * // Update or create a Footer
     * const footer = await prisma.footer.upsert({
     *   create: {
     *     // ... data to create a Footer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Footer we want to update
     *   }
     * })
     */
    upsert<T extends FooterUpsertArgs>(args: SelectSubset<T, FooterUpsertArgs<ExtArgs>>): Prisma__FooterClient<$Result.GetResult<Prisma.$FooterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Footers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterCountArgs} args - Arguments to filter Footers to count.
     * @example
     * // Count the number of Footers
     * const count = await prisma.footer.count({
     *   where: {
     *     // ... the filter for the Footers we want to count
     *   }
     * })
    **/
    count<T extends FooterCountArgs>(
      args?: Subset<T, FooterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FooterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Footer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FooterAggregateArgs>(args: Subset<T, FooterAggregateArgs>): Prisma.PrismaPromise<GetFooterAggregateType<T>>

    /**
     * Group by Footer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FooterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FooterGroupByArgs['orderBy'] }
        : { orderBy?: FooterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FooterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFooterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Footer model
   */
  readonly fields: FooterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Footer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FooterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Footer model
   */
  interface FooterFieldRefs {
    readonly id: FieldRef<"Footer", 'String'>
    readonly lang: FieldRef<"Footer", 'String'>
    readonly background_img: FieldRef<"Footer", 'String'>
    readonly logo_img: FieldRef<"Footer", 'String'>
    readonly title: FieldRef<"Footer", 'String'>
    readonly address: FieldRef<"Footer", 'String'>
    readonly email: FieldRef<"Footer", 'String'>
    readonly phone1: FieldRef<"Footer", 'String'>
    readonly phone2: FieldRef<"Footer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Footer findUnique
   */
  export type FooterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * Filter, which Footer to fetch.
     */
    where: FooterWhereUniqueInput
  }

  /**
   * Footer findUniqueOrThrow
   */
  export type FooterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * Filter, which Footer to fetch.
     */
    where: FooterWhereUniqueInput
  }

  /**
   * Footer findFirst
   */
  export type FooterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * Filter, which Footer to fetch.
     */
    where?: FooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Footers to fetch.
     */
    orderBy?: FooterOrderByWithRelationInput | FooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Footers.
     */
    cursor?: FooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Footers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Footers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Footers.
     */
    distinct?: FooterScalarFieldEnum | FooterScalarFieldEnum[]
  }

  /**
   * Footer findFirstOrThrow
   */
  export type FooterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * Filter, which Footer to fetch.
     */
    where?: FooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Footers to fetch.
     */
    orderBy?: FooterOrderByWithRelationInput | FooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Footers.
     */
    cursor?: FooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Footers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Footers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Footers.
     */
    distinct?: FooterScalarFieldEnum | FooterScalarFieldEnum[]
  }

  /**
   * Footer findMany
   */
  export type FooterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * Filter, which Footers to fetch.
     */
    where?: FooterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Footers to fetch.
     */
    orderBy?: FooterOrderByWithRelationInput | FooterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Footers.
     */
    cursor?: FooterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Footers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Footers.
     */
    skip?: number
    distinct?: FooterScalarFieldEnum | FooterScalarFieldEnum[]
  }

  /**
   * Footer create
   */
  export type FooterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * The data needed to create a Footer.
     */
    data: XOR<FooterCreateInput, FooterUncheckedCreateInput>
  }

  /**
   * Footer createMany
   */
  export type FooterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Footers.
     */
    data: FooterCreateManyInput | FooterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Footer createManyAndReturn
   */
  export type FooterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * The data used to create many Footers.
     */
    data: FooterCreateManyInput | FooterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Footer update
   */
  export type FooterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * The data needed to update a Footer.
     */
    data: XOR<FooterUpdateInput, FooterUncheckedUpdateInput>
    /**
     * Choose, which Footer to update.
     */
    where: FooterWhereUniqueInput
  }

  /**
   * Footer updateMany
   */
  export type FooterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Footers.
     */
    data: XOR<FooterUpdateManyMutationInput, FooterUncheckedUpdateManyInput>
    /**
     * Filter which Footers to update
     */
    where?: FooterWhereInput
    /**
     * Limit how many Footers to update.
     */
    limit?: number
  }

  /**
   * Footer updateManyAndReturn
   */
  export type FooterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * The data used to update Footers.
     */
    data: XOR<FooterUpdateManyMutationInput, FooterUncheckedUpdateManyInput>
    /**
     * Filter which Footers to update
     */
    where?: FooterWhereInput
    /**
     * Limit how many Footers to update.
     */
    limit?: number
  }

  /**
   * Footer upsert
   */
  export type FooterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * The filter to search for the Footer to update in case it exists.
     */
    where: FooterWhereUniqueInput
    /**
     * In case the Footer found by the `where` argument doesn't exist, create a new Footer with this data.
     */
    create: XOR<FooterCreateInput, FooterUncheckedCreateInput>
    /**
     * In case the Footer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FooterUpdateInput, FooterUncheckedUpdateInput>
  }

  /**
   * Footer delete
   */
  export type FooterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
    /**
     * Filter which Footer to delete.
     */
    where: FooterWhereUniqueInput
  }

  /**
   * Footer deleteMany
   */
  export type FooterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Footers to delete
     */
    where?: FooterWhereInput
    /**
     * Limit how many Footers to delete.
     */
    limit?: number
  }

  /**
   * Footer without action
   */
  export type FooterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Footer
     */
    select?: FooterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Footer
     */
    omit?: FooterOmit<ExtArgs> | null
  }


  /**
   * Model Winery_info
   */

  export type AggregateWinery_info = {
    _count: Winery_infoCountAggregateOutputType | null
    _min: Winery_infoMinAggregateOutputType | null
    _max: Winery_infoMaxAggregateOutputType | null
  }

  export type Winery_infoMinAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    description: string | null
  }

  export type Winery_infoMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    description: string | null
  }

  export type Winery_infoCountAggregateOutputType = {
    id: number
    lang: number
    title: number
    description: number
    _all: number
  }


  export type Winery_infoMinAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    description?: true
  }

  export type Winery_infoMaxAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    description?: true
  }

  export type Winery_infoCountAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    description?: true
    _all?: true
  }

  export type Winery_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Winery_info to aggregate.
     */
    where?: Winery_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_infos to fetch.
     */
    orderBy?: Winery_infoOrderByWithRelationInput | Winery_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Winery_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Winery_infos
    **/
    _count?: true | Winery_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Winery_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Winery_infoMaxAggregateInputType
  }

  export type GetWinery_infoAggregateType<T extends Winery_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateWinery_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWinery_info[P]>
      : GetScalarType<T[P], AggregateWinery_info[P]>
  }




  export type Winery_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Winery_infoWhereInput
    orderBy?: Winery_infoOrderByWithAggregationInput | Winery_infoOrderByWithAggregationInput[]
    by: Winery_infoScalarFieldEnum[] | Winery_infoScalarFieldEnum
    having?: Winery_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Winery_infoCountAggregateInputType | true
    _min?: Winery_infoMinAggregateInputType
    _max?: Winery_infoMaxAggregateInputType
  }

  export type Winery_infoGroupByOutputType = {
    id: string
    lang: string
    title: string
    description: string
    _count: Winery_infoCountAggregateOutputType | null
    _min: Winery_infoMinAggregateOutputType | null
    _max: Winery_infoMaxAggregateOutputType | null
  }

  type GetWinery_infoGroupByPayload<T extends Winery_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Winery_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Winery_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Winery_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Winery_infoGroupByOutputType[P]>
        }
      >
    >


  export type Winery_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    description?: boolean
  }, ExtArgs["result"]["winery_info"]>

  export type Winery_infoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    description?: boolean
  }, ExtArgs["result"]["winery_info"]>

  export type Winery_infoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    description?: boolean
  }, ExtArgs["result"]["winery_info"]>

  export type Winery_infoSelectScalar = {
    id?: boolean
    lang?: boolean
    title?: boolean
    description?: boolean
  }

  export type Winery_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "title" | "description", ExtArgs["result"]["winery_info"]>

  export type $Winery_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Winery_info"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      title: string
      description: string
    }, ExtArgs["result"]["winery_info"]>
    composites: {}
  }

  type Winery_infoGetPayload<S extends boolean | null | undefined | Winery_infoDefaultArgs> = $Result.GetResult<Prisma.$Winery_infoPayload, S>

  type Winery_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Winery_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Winery_infoCountAggregateInputType | true
    }

  export interface Winery_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Winery_info'], meta: { name: 'Winery_info' } }
    /**
     * Find zero or one Winery_info that matches the filter.
     * @param {Winery_infoFindUniqueArgs} args - Arguments to find a Winery_info
     * @example
     * // Get one Winery_info
     * const winery_info = await prisma.winery_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Winery_infoFindUniqueArgs>(args: SelectSubset<T, Winery_infoFindUniqueArgs<ExtArgs>>): Prisma__Winery_infoClient<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Winery_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Winery_infoFindUniqueOrThrowArgs} args - Arguments to find a Winery_info
     * @example
     * // Get one Winery_info
     * const winery_info = await prisma.winery_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Winery_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, Winery_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Winery_infoClient<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Winery_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_infoFindFirstArgs} args - Arguments to find a Winery_info
     * @example
     * // Get one Winery_info
     * const winery_info = await prisma.winery_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Winery_infoFindFirstArgs>(args?: SelectSubset<T, Winery_infoFindFirstArgs<ExtArgs>>): Prisma__Winery_infoClient<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Winery_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_infoFindFirstOrThrowArgs} args - Arguments to find a Winery_info
     * @example
     * // Get one Winery_info
     * const winery_info = await prisma.winery_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Winery_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, Winery_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Winery_infoClient<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Winery_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Winery_infos
     * const winery_infos = await prisma.winery_info.findMany()
     * 
     * // Get first 10 Winery_infos
     * const winery_infos = await prisma.winery_info.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const winery_infoWithIdOnly = await prisma.winery_info.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Winery_infoFindManyArgs>(args?: SelectSubset<T, Winery_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Winery_info.
     * @param {Winery_infoCreateArgs} args - Arguments to create a Winery_info.
     * @example
     * // Create one Winery_info
     * const Winery_info = await prisma.winery_info.create({
     *   data: {
     *     // ... data to create a Winery_info
     *   }
     * })
     * 
     */
    create<T extends Winery_infoCreateArgs>(args: SelectSubset<T, Winery_infoCreateArgs<ExtArgs>>): Prisma__Winery_infoClient<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Winery_infos.
     * @param {Winery_infoCreateManyArgs} args - Arguments to create many Winery_infos.
     * @example
     * // Create many Winery_infos
     * const winery_info = await prisma.winery_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Winery_infoCreateManyArgs>(args?: SelectSubset<T, Winery_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Winery_infos and returns the data saved in the database.
     * @param {Winery_infoCreateManyAndReturnArgs} args - Arguments to create many Winery_infos.
     * @example
     * // Create many Winery_infos
     * const winery_info = await prisma.winery_info.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Winery_infos and only return the `id`
     * const winery_infoWithIdOnly = await prisma.winery_info.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Winery_infoCreateManyAndReturnArgs>(args?: SelectSubset<T, Winery_infoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Winery_info.
     * @param {Winery_infoDeleteArgs} args - Arguments to delete one Winery_info.
     * @example
     * // Delete one Winery_info
     * const Winery_info = await prisma.winery_info.delete({
     *   where: {
     *     // ... filter to delete one Winery_info
     *   }
     * })
     * 
     */
    delete<T extends Winery_infoDeleteArgs>(args: SelectSubset<T, Winery_infoDeleteArgs<ExtArgs>>): Prisma__Winery_infoClient<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Winery_info.
     * @param {Winery_infoUpdateArgs} args - Arguments to update one Winery_info.
     * @example
     * // Update one Winery_info
     * const winery_info = await prisma.winery_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Winery_infoUpdateArgs>(args: SelectSubset<T, Winery_infoUpdateArgs<ExtArgs>>): Prisma__Winery_infoClient<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Winery_infos.
     * @param {Winery_infoDeleteManyArgs} args - Arguments to filter Winery_infos to delete.
     * @example
     * // Delete a few Winery_infos
     * const { count } = await prisma.winery_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Winery_infoDeleteManyArgs>(args?: SelectSubset<T, Winery_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Winery_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Winery_infos
     * const winery_info = await prisma.winery_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Winery_infoUpdateManyArgs>(args: SelectSubset<T, Winery_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Winery_infos and returns the data updated in the database.
     * @param {Winery_infoUpdateManyAndReturnArgs} args - Arguments to update many Winery_infos.
     * @example
     * // Update many Winery_infos
     * const winery_info = await prisma.winery_info.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Winery_infos and only return the `id`
     * const winery_infoWithIdOnly = await prisma.winery_info.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Winery_infoUpdateManyAndReturnArgs>(args: SelectSubset<T, Winery_infoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Winery_info.
     * @param {Winery_infoUpsertArgs} args - Arguments to update or create a Winery_info.
     * @example
     * // Update or create a Winery_info
     * const winery_info = await prisma.winery_info.upsert({
     *   create: {
     *     // ... data to create a Winery_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Winery_info we want to update
     *   }
     * })
     */
    upsert<T extends Winery_infoUpsertArgs>(args: SelectSubset<T, Winery_infoUpsertArgs<ExtArgs>>): Prisma__Winery_infoClient<$Result.GetResult<Prisma.$Winery_infoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Winery_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_infoCountArgs} args - Arguments to filter Winery_infos to count.
     * @example
     * // Count the number of Winery_infos
     * const count = await prisma.winery_info.count({
     *   where: {
     *     // ... the filter for the Winery_infos we want to count
     *   }
     * })
    **/
    count<T extends Winery_infoCountArgs>(
      args?: Subset<T, Winery_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Winery_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Winery_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Winery_infoAggregateArgs>(args: Subset<T, Winery_infoAggregateArgs>): Prisma.PrismaPromise<GetWinery_infoAggregateType<T>>

    /**
     * Group by Winery_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Winery_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Winery_infoGroupByArgs['orderBy'] }
        : { orderBy?: Winery_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Winery_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWinery_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Winery_info model
   */
  readonly fields: Winery_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Winery_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Winery_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Winery_info model
   */
  interface Winery_infoFieldRefs {
    readonly id: FieldRef<"Winery_info", 'String'>
    readonly lang: FieldRef<"Winery_info", 'String'>
    readonly title: FieldRef<"Winery_info", 'String'>
    readonly description: FieldRef<"Winery_info", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Winery_info findUnique
   */
  export type Winery_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * Filter, which Winery_info to fetch.
     */
    where: Winery_infoWhereUniqueInput
  }

  /**
   * Winery_info findUniqueOrThrow
   */
  export type Winery_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * Filter, which Winery_info to fetch.
     */
    where: Winery_infoWhereUniqueInput
  }

  /**
   * Winery_info findFirst
   */
  export type Winery_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * Filter, which Winery_info to fetch.
     */
    where?: Winery_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_infos to fetch.
     */
    orderBy?: Winery_infoOrderByWithRelationInput | Winery_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Winery_infos.
     */
    cursor?: Winery_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Winery_infos.
     */
    distinct?: Winery_infoScalarFieldEnum | Winery_infoScalarFieldEnum[]
  }

  /**
   * Winery_info findFirstOrThrow
   */
  export type Winery_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * Filter, which Winery_info to fetch.
     */
    where?: Winery_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_infos to fetch.
     */
    orderBy?: Winery_infoOrderByWithRelationInput | Winery_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Winery_infos.
     */
    cursor?: Winery_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Winery_infos.
     */
    distinct?: Winery_infoScalarFieldEnum | Winery_infoScalarFieldEnum[]
  }

  /**
   * Winery_info findMany
   */
  export type Winery_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * Filter, which Winery_infos to fetch.
     */
    where?: Winery_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_infos to fetch.
     */
    orderBy?: Winery_infoOrderByWithRelationInput | Winery_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Winery_infos.
     */
    cursor?: Winery_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_infos.
     */
    skip?: number
    distinct?: Winery_infoScalarFieldEnum | Winery_infoScalarFieldEnum[]
  }

  /**
   * Winery_info create
   */
  export type Winery_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * The data needed to create a Winery_info.
     */
    data: XOR<Winery_infoCreateInput, Winery_infoUncheckedCreateInput>
  }

  /**
   * Winery_info createMany
   */
  export type Winery_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Winery_infos.
     */
    data: Winery_infoCreateManyInput | Winery_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Winery_info createManyAndReturn
   */
  export type Winery_infoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * The data used to create many Winery_infos.
     */
    data: Winery_infoCreateManyInput | Winery_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Winery_info update
   */
  export type Winery_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * The data needed to update a Winery_info.
     */
    data: XOR<Winery_infoUpdateInput, Winery_infoUncheckedUpdateInput>
    /**
     * Choose, which Winery_info to update.
     */
    where: Winery_infoWhereUniqueInput
  }

  /**
   * Winery_info updateMany
   */
  export type Winery_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Winery_infos.
     */
    data: XOR<Winery_infoUpdateManyMutationInput, Winery_infoUncheckedUpdateManyInput>
    /**
     * Filter which Winery_infos to update
     */
    where?: Winery_infoWhereInput
    /**
     * Limit how many Winery_infos to update.
     */
    limit?: number
  }

  /**
   * Winery_info updateManyAndReturn
   */
  export type Winery_infoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * The data used to update Winery_infos.
     */
    data: XOR<Winery_infoUpdateManyMutationInput, Winery_infoUncheckedUpdateManyInput>
    /**
     * Filter which Winery_infos to update
     */
    where?: Winery_infoWhereInput
    /**
     * Limit how many Winery_infos to update.
     */
    limit?: number
  }

  /**
   * Winery_info upsert
   */
  export type Winery_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * The filter to search for the Winery_info to update in case it exists.
     */
    where: Winery_infoWhereUniqueInput
    /**
     * In case the Winery_info found by the `where` argument doesn't exist, create a new Winery_info with this data.
     */
    create: XOR<Winery_infoCreateInput, Winery_infoUncheckedCreateInput>
    /**
     * In case the Winery_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Winery_infoUpdateInput, Winery_infoUncheckedUpdateInput>
  }

  /**
   * Winery_info delete
   */
  export type Winery_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
    /**
     * Filter which Winery_info to delete.
     */
    where: Winery_infoWhereUniqueInput
  }

  /**
   * Winery_info deleteMany
   */
  export type Winery_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Winery_infos to delete
     */
    where?: Winery_infoWhereInput
    /**
     * Limit how many Winery_infos to delete.
     */
    limit?: number
  }

  /**
   * Winery_info without action
   */
  export type Winery_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_info
     */
    select?: Winery_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_info
     */
    omit?: Winery_infoOmit<ExtArgs> | null
  }


  /**
   * Model Winery_image
   */

  export type AggregateWinery_image = {
    _count: Winery_imageCountAggregateOutputType | null
    _min: Winery_imageMinAggregateOutputType | null
    _max: Winery_imageMaxAggregateOutputType | null
  }

  export type Winery_imageMinAggregateOutputType = {
    id: string | null
    background_image: string | null
    img_url1: string | null
    img_url2: string | null
    img_url3: string | null
  }

  export type Winery_imageMaxAggregateOutputType = {
    id: string | null
    background_image: string | null
    img_url1: string | null
    img_url2: string | null
    img_url3: string | null
  }

  export type Winery_imageCountAggregateOutputType = {
    id: number
    background_image: number
    img_url1: number
    img_url2: number
    img_url3: number
    _all: number
  }


  export type Winery_imageMinAggregateInputType = {
    id?: true
    background_image?: true
    img_url1?: true
    img_url2?: true
    img_url3?: true
  }

  export type Winery_imageMaxAggregateInputType = {
    id?: true
    background_image?: true
    img_url1?: true
    img_url2?: true
    img_url3?: true
  }

  export type Winery_imageCountAggregateInputType = {
    id?: true
    background_image?: true
    img_url1?: true
    img_url2?: true
    img_url3?: true
    _all?: true
  }

  export type Winery_imageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Winery_image to aggregate.
     */
    where?: Winery_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_images to fetch.
     */
    orderBy?: Winery_imageOrderByWithRelationInput | Winery_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Winery_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Winery_images
    **/
    _count?: true | Winery_imageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Winery_imageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Winery_imageMaxAggregateInputType
  }

  export type GetWinery_imageAggregateType<T extends Winery_imageAggregateArgs> = {
        [P in keyof T & keyof AggregateWinery_image]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWinery_image[P]>
      : GetScalarType<T[P], AggregateWinery_image[P]>
  }




  export type Winery_imageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Winery_imageWhereInput
    orderBy?: Winery_imageOrderByWithAggregationInput | Winery_imageOrderByWithAggregationInput[]
    by: Winery_imageScalarFieldEnum[] | Winery_imageScalarFieldEnum
    having?: Winery_imageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Winery_imageCountAggregateInputType | true
    _min?: Winery_imageMinAggregateInputType
    _max?: Winery_imageMaxAggregateInputType
  }

  export type Winery_imageGroupByOutputType = {
    id: string
    background_image: string
    img_url1: string
    img_url2: string
    img_url3: string
    _count: Winery_imageCountAggregateOutputType | null
    _min: Winery_imageMinAggregateOutputType | null
    _max: Winery_imageMaxAggregateOutputType | null
  }

  type GetWinery_imageGroupByPayload<T extends Winery_imageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Winery_imageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Winery_imageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Winery_imageGroupByOutputType[P]>
            : GetScalarType<T[P], Winery_imageGroupByOutputType[P]>
        }
      >
    >


  export type Winery_imageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    background_image?: boolean
    img_url1?: boolean
    img_url2?: boolean
    img_url3?: boolean
  }, ExtArgs["result"]["winery_image"]>

  export type Winery_imageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    background_image?: boolean
    img_url1?: boolean
    img_url2?: boolean
    img_url3?: boolean
  }, ExtArgs["result"]["winery_image"]>

  export type Winery_imageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    background_image?: boolean
    img_url1?: boolean
    img_url2?: boolean
    img_url3?: boolean
  }, ExtArgs["result"]["winery_image"]>

  export type Winery_imageSelectScalar = {
    id?: boolean
    background_image?: boolean
    img_url1?: boolean
    img_url2?: boolean
    img_url3?: boolean
  }

  export type Winery_imageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "background_image" | "img_url1" | "img_url2" | "img_url3", ExtArgs["result"]["winery_image"]>

  export type $Winery_imagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Winery_image"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      background_image: string
      img_url1: string
      img_url2: string
      img_url3: string
    }, ExtArgs["result"]["winery_image"]>
    composites: {}
  }

  type Winery_imageGetPayload<S extends boolean | null | undefined | Winery_imageDefaultArgs> = $Result.GetResult<Prisma.$Winery_imagePayload, S>

  type Winery_imageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Winery_imageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Winery_imageCountAggregateInputType | true
    }

  export interface Winery_imageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Winery_image'], meta: { name: 'Winery_image' } }
    /**
     * Find zero or one Winery_image that matches the filter.
     * @param {Winery_imageFindUniqueArgs} args - Arguments to find a Winery_image
     * @example
     * // Get one Winery_image
     * const winery_image = await prisma.winery_image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Winery_imageFindUniqueArgs>(args: SelectSubset<T, Winery_imageFindUniqueArgs<ExtArgs>>): Prisma__Winery_imageClient<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Winery_image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Winery_imageFindUniqueOrThrowArgs} args - Arguments to find a Winery_image
     * @example
     * // Get one Winery_image
     * const winery_image = await prisma.winery_image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Winery_imageFindUniqueOrThrowArgs>(args: SelectSubset<T, Winery_imageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Winery_imageClient<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Winery_image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_imageFindFirstArgs} args - Arguments to find a Winery_image
     * @example
     * // Get one Winery_image
     * const winery_image = await prisma.winery_image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Winery_imageFindFirstArgs>(args?: SelectSubset<T, Winery_imageFindFirstArgs<ExtArgs>>): Prisma__Winery_imageClient<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Winery_image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_imageFindFirstOrThrowArgs} args - Arguments to find a Winery_image
     * @example
     * // Get one Winery_image
     * const winery_image = await prisma.winery_image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Winery_imageFindFirstOrThrowArgs>(args?: SelectSubset<T, Winery_imageFindFirstOrThrowArgs<ExtArgs>>): Prisma__Winery_imageClient<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Winery_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_imageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Winery_images
     * const winery_images = await prisma.winery_image.findMany()
     * 
     * // Get first 10 Winery_images
     * const winery_images = await prisma.winery_image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const winery_imageWithIdOnly = await prisma.winery_image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Winery_imageFindManyArgs>(args?: SelectSubset<T, Winery_imageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Winery_image.
     * @param {Winery_imageCreateArgs} args - Arguments to create a Winery_image.
     * @example
     * // Create one Winery_image
     * const Winery_image = await prisma.winery_image.create({
     *   data: {
     *     // ... data to create a Winery_image
     *   }
     * })
     * 
     */
    create<T extends Winery_imageCreateArgs>(args: SelectSubset<T, Winery_imageCreateArgs<ExtArgs>>): Prisma__Winery_imageClient<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Winery_images.
     * @param {Winery_imageCreateManyArgs} args - Arguments to create many Winery_images.
     * @example
     * // Create many Winery_images
     * const winery_image = await prisma.winery_image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Winery_imageCreateManyArgs>(args?: SelectSubset<T, Winery_imageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Winery_images and returns the data saved in the database.
     * @param {Winery_imageCreateManyAndReturnArgs} args - Arguments to create many Winery_images.
     * @example
     * // Create many Winery_images
     * const winery_image = await prisma.winery_image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Winery_images and only return the `id`
     * const winery_imageWithIdOnly = await prisma.winery_image.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Winery_imageCreateManyAndReturnArgs>(args?: SelectSubset<T, Winery_imageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Winery_image.
     * @param {Winery_imageDeleteArgs} args - Arguments to delete one Winery_image.
     * @example
     * // Delete one Winery_image
     * const Winery_image = await prisma.winery_image.delete({
     *   where: {
     *     // ... filter to delete one Winery_image
     *   }
     * })
     * 
     */
    delete<T extends Winery_imageDeleteArgs>(args: SelectSubset<T, Winery_imageDeleteArgs<ExtArgs>>): Prisma__Winery_imageClient<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Winery_image.
     * @param {Winery_imageUpdateArgs} args - Arguments to update one Winery_image.
     * @example
     * // Update one Winery_image
     * const winery_image = await prisma.winery_image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Winery_imageUpdateArgs>(args: SelectSubset<T, Winery_imageUpdateArgs<ExtArgs>>): Prisma__Winery_imageClient<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Winery_images.
     * @param {Winery_imageDeleteManyArgs} args - Arguments to filter Winery_images to delete.
     * @example
     * // Delete a few Winery_images
     * const { count } = await prisma.winery_image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Winery_imageDeleteManyArgs>(args?: SelectSubset<T, Winery_imageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Winery_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_imageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Winery_images
     * const winery_image = await prisma.winery_image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Winery_imageUpdateManyArgs>(args: SelectSubset<T, Winery_imageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Winery_images and returns the data updated in the database.
     * @param {Winery_imageUpdateManyAndReturnArgs} args - Arguments to update many Winery_images.
     * @example
     * // Update many Winery_images
     * const winery_image = await prisma.winery_image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Winery_images and only return the `id`
     * const winery_imageWithIdOnly = await prisma.winery_image.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Winery_imageUpdateManyAndReturnArgs>(args: SelectSubset<T, Winery_imageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Winery_image.
     * @param {Winery_imageUpsertArgs} args - Arguments to update or create a Winery_image.
     * @example
     * // Update or create a Winery_image
     * const winery_image = await prisma.winery_image.upsert({
     *   create: {
     *     // ... data to create a Winery_image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Winery_image we want to update
     *   }
     * })
     */
    upsert<T extends Winery_imageUpsertArgs>(args: SelectSubset<T, Winery_imageUpsertArgs<ExtArgs>>): Prisma__Winery_imageClient<$Result.GetResult<Prisma.$Winery_imagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Winery_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_imageCountArgs} args - Arguments to filter Winery_images to count.
     * @example
     * // Count the number of Winery_images
     * const count = await prisma.winery_image.count({
     *   where: {
     *     // ... the filter for the Winery_images we want to count
     *   }
     * })
    **/
    count<T extends Winery_imageCountArgs>(
      args?: Subset<T, Winery_imageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Winery_imageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Winery_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_imageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Winery_imageAggregateArgs>(args: Subset<T, Winery_imageAggregateArgs>): Prisma.PrismaPromise<GetWinery_imageAggregateType<T>>

    /**
     * Group by Winery_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_imageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Winery_imageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Winery_imageGroupByArgs['orderBy'] }
        : { orderBy?: Winery_imageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Winery_imageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWinery_imageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Winery_image model
   */
  readonly fields: Winery_imageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Winery_image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Winery_imageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Winery_image model
   */
  interface Winery_imageFieldRefs {
    readonly id: FieldRef<"Winery_image", 'String'>
    readonly background_image: FieldRef<"Winery_image", 'String'>
    readonly img_url1: FieldRef<"Winery_image", 'String'>
    readonly img_url2: FieldRef<"Winery_image", 'String'>
    readonly img_url3: FieldRef<"Winery_image", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Winery_image findUnique
   */
  export type Winery_imageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * Filter, which Winery_image to fetch.
     */
    where: Winery_imageWhereUniqueInput
  }

  /**
   * Winery_image findUniqueOrThrow
   */
  export type Winery_imageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * Filter, which Winery_image to fetch.
     */
    where: Winery_imageWhereUniqueInput
  }

  /**
   * Winery_image findFirst
   */
  export type Winery_imageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * Filter, which Winery_image to fetch.
     */
    where?: Winery_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_images to fetch.
     */
    orderBy?: Winery_imageOrderByWithRelationInput | Winery_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Winery_images.
     */
    cursor?: Winery_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Winery_images.
     */
    distinct?: Winery_imageScalarFieldEnum | Winery_imageScalarFieldEnum[]
  }

  /**
   * Winery_image findFirstOrThrow
   */
  export type Winery_imageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * Filter, which Winery_image to fetch.
     */
    where?: Winery_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_images to fetch.
     */
    orderBy?: Winery_imageOrderByWithRelationInput | Winery_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Winery_images.
     */
    cursor?: Winery_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Winery_images.
     */
    distinct?: Winery_imageScalarFieldEnum | Winery_imageScalarFieldEnum[]
  }

  /**
   * Winery_image findMany
   */
  export type Winery_imageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * Filter, which Winery_images to fetch.
     */
    where?: Winery_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_images to fetch.
     */
    orderBy?: Winery_imageOrderByWithRelationInput | Winery_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Winery_images.
     */
    cursor?: Winery_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_images.
     */
    skip?: number
    distinct?: Winery_imageScalarFieldEnum | Winery_imageScalarFieldEnum[]
  }

  /**
   * Winery_image create
   */
  export type Winery_imageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * The data needed to create a Winery_image.
     */
    data: XOR<Winery_imageCreateInput, Winery_imageUncheckedCreateInput>
  }

  /**
   * Winery_image createMany
   */
  export type Winery_imageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Winery_images.
     */
    data: Winery_imageCreateManyInput | Winery_imageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Winery_image createManyAndReturn
   */
  export type Winery_imageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * The data used to create many Winery_images.
     */
    data: Winery_imageCreateManyInput | Winery_imageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Winery_image update
   */
  export type Winery_imageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * The data needed to update a Winery_image.
     */
    data: XOR<Winery_imageUpdateInput, Winery_imageUncheckedUpdateInput>
    /**
     * Choose, which Winery_image to update.
     */
    where: Winery_imageWhereUniqueInput
  }

  /**
   * Winery_image updateMany
   */
  export type Winery_imageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Winery_images.
     */
    data: XOR<Winery_imageUpdateManyMutationInput, Winery_imageUncheckedUpdateManyInput>
    /**
     * Filter which Winery_images to update
     */
    where?: Winery_imageWhereInput
    /**
     * Limit how many Winery_images to update.
     */
    limit?: number
  }

  /**
   * Winery_image updateManyAndReturn
   */
  export type Winery_imageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * The data used to update Winery_images.
     */
    data: XOR<Winery_imageUpdateManyMutationInput, Winery_imageUncheckedUpdateManyInput>
    /**
     * Filter which Winery_images to update
     */
    where?: Winery_imageWhereInput
    /**
     * Limit how many Winery_images to update.
     */
    limit?: number
  }

  /**
   * Winery_image upsert
   */
  export type Winery_imageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * The filter to search for the Winery_image to update in case it exists.
     */
    where: Winery_imageWhereUniqueInput
    /**
     * In case the Winery_image found by the `where` argument doesn't exist, create a new Winery_image with this data.
     */
    create: XOR<Winery_imageCreateInput, Winery_imageUncheckedCreateInput>
    /**
     * In case the Winery_image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Winery_imageUpdateInput, Winery_imageUncheckedUpdateInput>
  }

  /**
   * Winery_image delete
   */
  export type Winery_imageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
    /**
     * Filter which Winery_image to delete.
     */
    where: Winery_imageWhereUniqueInput
  }

  /**
   * Winery_image deleteMany
   */
  export type Winery_imageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Winery_images to delete
     */
    where?: Winery_imageWhereInput
    /**
     * Limit how many Winery_images to delete.
     */
    limit?: number
  }

  /**
   * Winery_image without action
   */
  export type Winery_imageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_image
     */
    select?: Winery_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_image
     */
    omit?: Winery_imageOmit<ExtArgs> | null
  }


  /**
   * Model Winery_our_story
   */

  export type AggregateWinery_our_story = {
    _count: Winery_our_storyCountAggregateOutputType | null
    _min: Winery_our_storyMinAggregateOutputType | null
    _max: Winery_our_storyMaxAggregateOutputType | null
  }

  export type Winery_our_storyMinAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    description: string | null
  }

  export type Winery_our_storyMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    description: string | null
  }

  export type Winery_our_storyCountAggregateOutputType = {
    id: number
    lang: number
    title: number
    description: number
    _all: number
  }


  export type Winery_our_storyMinAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    description?: true
  }

  export type Winery_our_storyMaxAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    description?: true
  }

  export type Winery_our_storyCountAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    description?: true
    _all?: true
  }

  export type Winery_our_storyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Winery_our_story to aggregate.
     */
    where?: Winery_our_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_our_stories to fetch.
     */
    orderBy?: Winery_our_storyOrderByWithRelationInput | Winery_our_storyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Winery_our_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_our_stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_our_stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Winery_our_stories
    **/
    _count?: true | Winery_our_storyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Winery_our_storyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Winery_our_storyMaxAggregateInputType
  }

  export type GetWinery_our_storyAggregateType<T extends Winery_our_storyAggregateArgs> = {
        [P in keyof T & keyof AggregateWinery_our_story]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWinery_our_story[P]>
      : GetScalarType<T[P], AggregateWinery_our_story[P]>
  }




  export type Winery_our_storyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Winery_our_storyWhereInput
    orderBy?: Winery_our_storyOrderByWithAggregationInput | Winery_our_storyOrderByWithAggregationInput[]
    by: Winery_our_storyScalarFieldEnum[] | Winery_our_storyScalarFieldEnum
    having?: Winery_our_storyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Winery_our_storyCountAggregateInputType | true
    _min?: Winery_our_storyMinAggregateInputType
    _max?: Winery_our_storyMaxAggregateInputType
  }

  export type Winery_our_storyGroupByOutputType = {
    id: string
    lang: string
    title: string
    description: string
    _count: Winery_our_storyCountAggregateOutputType | null
    _min: Winery_our_storyMinAggregateOutputType | null
    _max: Winery_our_storyMaxAggregateOutputType | null
  }

  type GetWinery_our_storyGroupByPayload<T extends Winery_our_storyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Winery_our_storyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Winery_our_storyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Winery_our_storyGroupByOutputType[P]>
            : GetScalarType<T[P], Winery_our_storyGroupByOutputType[P]>
        }
      >
    >


  export type Winery_our_storySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    description?: boolean
  }, ExtArgs["result"]["winery_our_story"]>

  export type Winery_our_storySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    description?: boolean
  }, ExtArgs["result"]["winery_our_story"]>

  export type Winery_our_storySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    description?: boolean
  }, ExtArgs["result"]["winery_our_story"]>

  export type Winery_our_storySelectScalar = {
    id?: boolean
    lang?: boolean
    title?: boolean
    description?: boolean
  }

  export type Winery_our_storyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "title" | "description", ExtArgs["result"]["winery_our_story"]>

  export type $Winery_our_storyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Winery_our_story"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      title: string
      description: string
    }, ExtArgs["result"]["winery_our_story"]>
    composites: {}
  }

  type Winery_our_storyGetPayload<S extends boolean | null | undefined | Winery_our_storyDefaultArgs> = $Result.GetResult<Prisma.$Winery_our_storyPayload, S>

  type Winery_our_storyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Winery_our_storyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Winery_our_storyCountAggregateInputType | true
    }

  export interface Winery_our_storyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Winery_our_story'], meta: { name: 'Winery_our_story' } }
    /**
     * Find zero or one Winery_our_story that matches the filter.
     * @param {Winery_our_storyFindUniqueArgs} args - Arguments to find a Winery_our_story
     * @example
     * // Get one Winery_our_story
     * const winery_our_story = await prisma.winery_our_story.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Winery_our_storyFindUniqueArgs>(args: SelectSubset<T, Winery_our_storyFindUniqueArgs<ExtArgs>>): Prisma__Winery_our_storyClient<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Winery_our_story that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Winery_our_storyFindUniqueOrThrowArgs} args - Arguments to find a Winery_our_story
     * @example
     * // Get one Winery_our_story
     * const winery_our_story = await prisma.winery_our_story.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Winery_our_storyFindUniqueOrThrowArgs>(args: SelectSubset<T, Winery_our_storyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Winery_our_storyClient<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Winery_our_story that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_our_storyFindFirstArgs} args - Arguments to find a Winery_our_story
     * @example
     * // Get one Winery_our_story
     * const winery_our_story = await prisma.winery_our_story.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Winery_our_storyFindFirstArgs>(args?: SelectSubset<T, Winery_our_storyFindFirstArgs<ExtArgs>>): Prisma__Winery_our_storyClient<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Winery_our_story that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_our_storyFindFirstOrThrowArgs} args - Arguments to find a Winery_our_story
     * @example
     * // Get one Winery_our_story
     * const winery_our_story = await prisma.winery_our_story.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Winery_our_storyFindFirstOrThrowArgs>(args?: SelectSubset<T, Winery_our_storyFindFirstOrThrowArgs<ExtArgs>>): Prisma__Winery_our_storyClient<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Winery_our_stories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_our_storyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Winery_our_stories
     * const winery_our_stories = await prisma.winery_our_story.findMany()
     * 
     * // Get first 10 Winery_our_stories
     * const winery_our_stories = await prisma.winery_our_story.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const winery_our_storyWithIdOnly = await prisma.winery_our_story.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Winery_our_storyFindManyArgs>(args?: SelectSubset<T, Winery_our_storyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Winery_our_story.
     * @param {Winery_our_storyCreateArgs} args - Arguments to create a Winery_our_story.
     * @example
     * // Create one Winery_our_story
     * const Winery_our_story = await prisma.winery_our_story.create({
     *   data: {
     *     // ... data to create a Winery_our_story
     *   }
     * })
     * 
     */
    create<T extends Winery_our_storyCreateArgs>(args: SelectSubset<T, Winery_our_storyCreateArgs<ExtArgs>>): Prisma__Winery_our_storyClient<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Winery_our_stories.
     * @param {Winery_our_storyCreateManyArgs} args - Arguments to create many Winery_our_stories.
     * @example
     * // Create many Winery_our_stories
     * const winery_our_story = await prisma.winery_our_story.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Winery_our_storyCreateManyArgs>(args?: SelectSubset<T, Winery_our_storyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Winery_our_stories and returns the data saved in the database.
     * @param {Winery_our_storyCreateManyAndReturnArgs} args - Arguments to create many Winery_our_stories.
     * @example
     * // Create many Winery_our_stories
     * const winery_our_story = await prisma.winery_our_story.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Winery_our_stories and only return the `id`
     * const winery_our_storyWithIdOnly = await prisma.winery_our_story.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Winery_our_storyCreateManyAndReturnArgs>(args?: SelectSubset<T, Winery_our_storyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Winery_our_story.
     * @param {Winery_our_storyDeleteArgs} args - Arguments to delete one Winery_our_story.
     * @example
     * // Delete one Winery_our_story
     * const Winery_our_story = await prisma.winery_our_story.delete({
     *   where: {
     *     // ... filter to delete one Winery_our_story
     *   }
     * })
     * 
     */
    delete<T extends Winery_our_storyDeleteArgs>(args: SelectSubset<T, Winery_our_storyDeleteArgs<ExtArgs>>): Prisma__Winery_our_storyClient<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Winery_our_story.
     * @param {Winery_our_storyUpdateArgs} args - Arguments to update one Winery_our_story.
     * @example
     * // Update one Winery_our_story
     * const winery_our_story = await prisma.winery_our_story.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Winery_our_storyUpdateArgs>(args: SelectSubset<T, Winery_our_storyUpdateArgs<ExtArgs>>): Prisma__Winery_our_storyClient<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Winery_our_stories.
     * @param {Winery_our_storyDeleteManyArgs} args - Arguments to filter Winery_our_stories to delete.
     * @example
     * // Delete a few Winery_our_stories
     * const { count } = await prisma.winery_our_story.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Winery_our_storyDeleteManyArgs>(args?: SelectSubset<T, Winery_our_storyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Winery_our_stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_our_storyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Winery_our_stories
     * const winery_our_story = await prisma.winery_our_story.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Winery_our_storyUpdateManyArgs>(args: SelectSubset<T, Winery_our_storyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Winery_our_stories and returns the data updated in the database.
     * @param {Winery_our_storyUpdateManyAndReturnArgs} args - Arguments to update many Winery_our_stories.
     * @example
     * // Update many Winery_our_stories
     * const winery_our_story = await prisma.winery_our_story.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Winery_our_stories and only return the `id`
     * const winery_our_storyWithIdOnly = await prisma.winery_our_story.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Winery_our_storyUpdateManyAndReturnArgs>(args: SelectSubset<T, Winery_our_storyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Winery_our_story.
     * @param {Winery_our_storyUpsertArgs} args - Arguments to update or create a Winery_our_story.
     * @example
     * // Update or create a Winery_our_story
     * const winery_our_story = await prisma.winery_our_story.upsert({
     *   create: {
     *     // ... data to create a Winery_our_story
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Winery_our_story we want to update
     *   }
     * })
     */
    upsert<T extends Winery_our_storyUpsertArgs>(args: SelectSubset<T, Winery_our_storyUpsertArgs<ExtArgs>>): Prisma__Winery_our_storyClient<$Result.GetResult<Prisma.$Winery_our_storyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Winery_our_stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_our_storyCountArgs} args - Arguments to filter Winery_our_stories to count.
     * @example
     * // Count the number of Winery_our_stories
     * const count = await prisma.winery_our_story.count({
     *   where: {
     *     // ... the filter for the Winery_our_stories we want to count
     *   }
     * })
    **/
    count<T extends Winery_our_storyCountArgs>(
      args?: Subset<T, Winery_our_storyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Winery_our_storyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Winery_our_story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_our_storyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Winery_our_storyAggregateArgs>(args: Subset<T, Winery_our_storyAggregateArgs>): Prisma.PrismaPromise<GetWinery_our_storyAggregateType<T>>

    /**
     * Group by Winery_our_story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Winery_our_storyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Winery_our_storyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Winery_our_storyGroupByArgs['orderBy'] }
        : { orderBy?: Winery_our_storyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Winery_our_storyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWinery_our_storyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Winery_our_story model
   */
  readonly fields: Winery_our_storyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Winery_our_story.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Winery_our_storyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Winery_our_story model
   */
  interface Winery_our_storyFieldRefs {
    readonly id: FieldRef<"Winery_our_story", 'String'>
    readonly lang: FieldRef<"Winery_our_story", 'String'>
    readonly title: FieldRef<"Winery_our_story", 'String'>
    readonly description: FieldRef<"Winery_our_story", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Winery_our_story findUnique
   */
  export type Winery_our_storyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * Filter, which Winery_our_story to fetch.
     */
    where: Winery_our_storyWhereUniqueInput
  }

  /**
   * Winery_our_story findUniqueOrThrow
   */
  export type Winery_our_storyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * Filter, which Winery_our_story to fetch.
     */
    where: Winery_our_storyWhereUniqueInput
  }

  /**
   * Winery_our_story findFirst
   */
  export type Winery_our_storyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * Filter, which Winery_our_story to fetch.
     */
    where?: Winery_our_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_our_stories to fetch.
     */
    orderBy?: Winery_our_storyOrderByWithRelationInput | Winery_our_storyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Winery_our_stories.
     */
    cursor?: Winery_our_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_our_stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_our_stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Winery_our_stories.
     */
    distinct?: Winery_our_storyScalarFieldEnum | Winery_our_storyScalarFieldEnum[]
  }

  /**
   * Winery_our_story findFirstOrThrow
   */
  export type Winery_our_storyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * Filter, which Winery_our_story to fetch.
     */
    where?: Winery_our_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_our_stories to fetch.
     */
    orderBy?: Winery_our_storyOrderByWithRelationInput | Winery_our_storyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Winery_our_stories.
     */
    cursor?: Winery_our_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_our_stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_our_stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Winery_our_stories.
     */
    distinct?: Winery_our_storyScalarFieldEnum | Winery_our_storyScalarFieldEnum[]
  }

  /**
   * Winery_our_story findMany
   */
  export type Winery_our_storyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * Filter, which Winery_our_stories to fetch.
     */
    where?: Winery_our_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Winery_our_stories to fetch.
     */
    orderBy?: Winery_our_storyOrderByWithRelationInput | Winery_our_storyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Winery_our_stories.
     */
    cursor?: Winery_our_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Winery_our_stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Winery_our_stories.
     */
    skip?: number
    distinct?: Winery_our_storyScalarFieldEnum | Winery_our_storyScalarFieldEnum[]
  }

  /**
   * Winery_our_story create
   */
  export type Winery_our_storyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * The data needed to create a Winery_our_story.
     */
    data: XOR<Winery_our_storyCreateInput, Winery_our_storyUncheckedCreateInput>
  }

  /**
   * Winery_our_story createMany
   */
  export type Winery_our_storyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Winery_our_stories.
     */
    data: Winery_our_storyCreateManyInput | Winery_our_storyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Winery_our_story createManyAndReturn
   */
  export type Winery_our_storyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * The data used to create many Winery_our_stories.
     */
    data: Winery_our_storyCreateManyInput | Winery_our_storyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Winery_our_story update
   */
  export type Winery_our_storyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * The data needed to update a Winery_our_story.
     */
    data: XOR<Winery_our_storyUpdateInput, Winery_our_storyUncheckedUpdateInput>
    /**
     * Choose, which Winery_our_story to update.
     */
    where: Winery_our_storyWhereUniqueInput
  }

  /**
   * Winery_our_story updateMany
   */
  export type Winery_our_storyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Winery_our_stories.
     */
    data: XOR<Winery_our_storyUpdateManyMutationInput, Winery_our_storyUncheckedUpdateManyInput>
    /**
     * Filter which Winery_our_stories to update
     */
    where?: Winery_our_storyWhereInput
    /**
     * Limit how many Winery_our_stories to update.
     */
    limit?: number
  }

  /**
   * Winery_our_story updateManyAndReturn
   */
  export type Winery_our_storyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * The data used to update Winery_our_stories.
     */
    data: XOR<Winery_our_storyUpdateManyMutationInput, Winery_our_storyUncheckedUpdateManyInput>
    /**
     * Filter which Winery_our_stories to update
     */
    where?: Winery_our_storyWhereInput
    /**
     * Limit how many Winery_our_stories to update.
     */
    limit?: number
  }

  /**
   * Winery_our_story upsert
   */
  export type Winery_our_storyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * The filter to search for the Winery_our_story to update in case it exists.
     */
    where: Winery_our_storyWhereUniqueInput
    /**
     * In case the Winery_our_story found by the `where` argument doesn't exist, create a new Winery_our_story with this data.
     */
    create: XOR<Winery_our_storyCreateInput, Winery_our_storyUncheckedCreateInput>
    /**
     * In case the Winery_our_story was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Winery_our_storyUpdateInput, Winery_our_storyUncheckedUpdateInput>
  }

  /**
   * Winery_our_story delete
   */
  export type Winery_our_storyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
    /**
     * Filter which Winery_our_story to delete.
     */
    where: Winery_our_storyWhereUniqueInput
  }

  /**
   * Winery_our_story deleteMany
   */
  export type Winery_our_storyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Winery_our_stories to delete
     */
    where?: Winery_our_storyWhereInput
    /**
     * Limit how many Winery_our_stories to delete.
     */
    limit?: number
  }

  /**
   * Winery_our_story without action
   */
  export type Winery_our_storyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Winery_our_story
     */
    select?: Winery_our_storySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Winery_our_story
     */
    omit?: Winery_our_storyOmit<ExtArgs> | null
  }


  /**
   * Model Gallery_product
   */

  export type AggregateGallery_product = {
    _count: Gallery_productCountAggregateOutputType | null
    _min: Gallery_productMinAggregateOutputType | null
    _max: Gallery_productMaxAggregateOutputType | null
  }

  export type Gallery_productMinAggregateOutputType = {
    id: string | null
    img_url: string | null
  }

  export type Gallery_productMaxAggregateOutputType = {
    id: string | null
    img_url: string | null
  }

  export type Gallery_productCountAggregateOutputType = {
    id: number
    img_url: number
    _all: number
  }


  export type Gallery_productMinAggregateInputType = {
    id?: true
    img_url?: true
  }

  export type Gallery_productMaxAggregateInputType = {
    id?: true
    img_url?: true
  }

  export type Gallery_productCountAggregateInputType = {
    id?: true
    img_url?: true
    _all?: true
  }

  export type Gallery_productAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gallery_product to aggregate.
     */
    where?: Gallery_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_products to fetch.
     */
    orderBy?: Gallery_productOrderByWithRelationInput | Gallery_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Gallery_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gallery_products
    **/
    _count?: true | Gallery_productCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gallery_productMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gallery_productMaxAggregateInputType
  }

  export type GetGallery_productAggregateType<T extends Gallery_productAggregateArgs> = {
        [P in keyof T & keyof AggregateGallery_product]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGallery_product[P]>
      : GetScalarType<T[P], AggregateGallery_product[P]>
  }




  export type Gallery_productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Gallery_productWhereInput
    orderBy?: Gallery_productOrderByWithAggregationInput | Gallery_productOrderByWithAggregationInput[]
    by: Gallery_productScalarFieldEnum[] | Gallery_productScalarFieldEnum
    having?: Gallery_productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gallery_productCountAggregateInputType | true
    _min?: Gallery_productMinAggregateInputType
    _max?: Gallery_productMaxAggregateInputType
  }

  export type Gallery_productGroupByOutputType = {
    id: string
    img_url: string
    _count: Gallery_productCountAggregateOutputType | null
    _min: Gallery_productMinAggregateOutputType | null
    _max: Gallery_productMaxAggregateOutputType | null
  }

  type GetGallery_productGroupByPayload<T extends Gallery_productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gallery_productGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gallery_productGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gallery_productGroupByOutputType[P]>
            : GetScalarType<T[P], Gallery_productGroupByOutputType[P]>
        }
      >
    >


  export type Gallery_productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["gallery_product"]>

  export type Gallery_productSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["gallery_product"]>

  export type Gallery_productSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    img_url?: boolean
  }, ExtArgs["result"]["gallery_product"]>

  export type Gallery_productSelectScalar = {
    id?: boolean
    img_url?: boolean
  }

  export type Gallery_productOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "img_url", ExtArgs["result"]["gallery_product"]>

  export type $Gallery_productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gallery_product"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      img_url: string
    }, ExtArgs["result"]["gallery_product"]>
    composites: {}
  }

  type Gallery_productGetPayload<S extends boolean | null | undefined | Gallery_productDefaultArgs> = $Result.GetResult<Prisma.$Gallery_productPayload, S>

  type Gallery_productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Gallery_productFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Gallery_productCountAggregateInputType | true
    }

  export interface Gallery_productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gallery_product'], meta: { name: 'Gallery_product' } }
    /**
     * Find zero or one Gallery_product that matches the filter.
     * @param {Gallery_productFindUniqueArgs} args - Arguments to find a Gallery_product
     * @example
     * // Get one Gallery_product
     * const gallery_product = await prisma.gallery_product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Gallery_productFindUniqueArgs>(args: SelectSubset<T, Gallery_productFindUniqueArgs<ExtArgs>>): Prisma__Gallery_productClient<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gallery_product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Gallery_productFindUniqueOrThrowArgs} args - Arguments to find a Gallery_product
     * @example
     * // Get one Gallery_product
     * const gallery_product = await prisma.gallery_product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Gallery_productFindUniqueOrThrowArgs>(args: SelectSubset<T, Gallery_productFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Gallery_productClient<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gallery_product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_productFindFirstArgs} args - Arguments to find a Gallery_product
     * @example
     * // Get one Gallery_product
     * const gallery_product = await prisma.gallery_product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Gallery_productFindFirstArgs>(args?: SelectSubset<T, Gallery_productFindFirstArgs<ExtArgs>>): Prisma__Gallery_productClient<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gallery_product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_productFindFirstOrThrowArgs} args - Arguments to find a Gallery_product
     * @example
     * // Get one Gallery_product
     * const gallery_product = await prisma.gallery_product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Gallery_productFindFirstOrThrowArgs>(args?: SelectSubset<T, Gallery_productFindFirstOrThrowArgs<ExtArgs>>): Prisma__Gallery_productClient<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gallery_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_productFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gallery_products
     * const gallery_products = await prisma.gallery_product.findMany()
     * 
     * // Get first 10 Gallery_products
     * const gallery_products = await prisma.gallery_product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gallery_productWithIdOnly = await prisma.gallery_product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Gallery_productFindManyArgs>(args?: SelectSubset<T, Gallery_productFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gallery_product.
     * @param {Gallery_productCreateArgs} args - Arguments to create a Gallery_product.
     * @example
     * // Create one Gallery_product
     * const Gallery_product = await prisma.gallery_product.create({
     *   data: {
     *     // ... data to create a Gallery_product
     *   }
     * })
     * 
     */
    create<T extends Gallery_productCreateArgs>(args: SelectSubset<T, Gallery_productCreateArgs<ExtArgs>>): Prisma__Gallery_productClient<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gallery_products.
     * @param {Gallery_productCreateManyArgs} args - Arguments to create many Gallery_products.
     * @example
     * // Create many Gallery_products
     * const gallery_product = await prisma.gallery_product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Gallery_productCreateManyArgs>(args?: SelectSubset<T, Gallery_productCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gallery_products and returns the data saved in the database.
     * @param {Gallery_productCreateManyAndReturnArgs} args - Arguments to create many Gallery_products.
     * @example
     * // Create many Gallery_products
     * const gallery_product = await prisma.gallery_product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gallery_products and only return the `id`
     * const gallery_productWithIdOnly = await prisma.gallery_product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Gallery_productCreateManyAndReturnArgs>(args?: SelectSubset<T, Gallery_productCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gallery_product.
     * @param {Gallery_productDeleteArgs} args - Arguments to delete one Gallery_product.
     * @example
     * // Delete one Gallery_product
     * const Gallery_product = await prisma.gallery_product.delete({
     *   where: {
     *     // ... filter to delete one Gallery_product
     *   }
     * })
     * 
     */
    delete<T extends Gallery_productDeleteArgs>(args: SelectSubset<T, Gallery_productDeleteArgs<ExtArgs>>): Prisma__Gallery_productClient<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gallery_product.
     * @param {Gallery_productUpdateArgs} args - Arguments to update one Gallery_product.
     * @example
     * // Update one Gallery_product
     * const gallery_product = await prisma.gallery_product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Gallery_productUpdateArgs>(args: SelectSubset<T, Gallery_productUpdateArgs<ExtArgs>>): Prisma__Gallery_productClient<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gallery_products.
     * @param {Gallery_productDeleteManyArgs} args - Arguments to filter Gallery_products to delete.
     * @example
     * // Delete a few Gallery_products
     * const { count } = await prisma.gallery_product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Gallery_productDeleteManyArgs>(args?: SelectSubset<T, Gallery_productDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gallery_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gallery_products
     * const gallery_product = await prisma.gallery_product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Gallery_productUpdateManyArgs>(args: SelectSubset<T, Gallery_productUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gallery_products and returns the data updated in the database.
     * @param {Gallery_productUpdateManyAndReturnArgs} args - Arguments to update many Gallery_products.
     * @example
     * // Update many Gallery_products
     * const gallery_product = await prisma.gallery_product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gallery_products and only return the `id`
     * const gallery_productWithIdOnly = await prisma.gallery_product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Gallery_productUpdateManyAndReturnArgs>(args: SelectSubset<T, Gallery_productUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gallery_product.
     * @param {Gallery_productUpsertArgs} args - Arguments to update or create a Gallery_product.
     * @example
     * // Update or create a Gallery_product
     * const gallery_product = await prisma.gallery_product.upsert({
     *   create: {
     *     // ... data to create a Gallery_product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gallery_product we want to update
     *   }
     * })
     */
    upsert<T extends Gallery_productUpsertArgs>(args: SelectSubset<T, Gallery_productUpsertArgs<ExtArgs>>): Prisma__Gallery_productClient<$Result.GetResult<Prisma.$Gallery_productPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gallery_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_productCountArgs} args - Arguments to filter Gallery_products to count.
     * @example
     * // Count the number of Gallery_products
     * const count = await prisma.gallery_product.count({
     *   where: {
     *     // ... the filter for the Gallery_products we want to count
     *   }
     * })
    **/
    count<T extends Gallery_productCountArgs>(
      args?: Subset<T, Gallery_productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gallery_productCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gallery_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_productAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gallery_productAggregateArgs>(args: Subset<T, Gallery_productAggregateArgs>): Prisma.PrismaPromise<GetGallery_productAggregateType<T>>

    /**
     * Group by Gallery_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gallery_productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gallery_productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gallery_productGroupByArgs['orderBy'] }
        : { orderBy?: Gallery_productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gallery_productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGallery_productGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gallery_product model
   */
  readonly fields: Gallery_productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gallery_product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Gallery_productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gallery_product model
   */
  interface Gallery_productFieldRefs {
    readonly id: FieldRef<"Gallery_product", 'String'>
    readonly img_url: FieldRef<"Gallery_product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Gallery_product findUnique
   */
  export type Gallery_productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_product to fetch.
     */
    where: Gallery_productWhereUniqueInput
  }

  /**
   * Gallery_product findUniqueOrThrow
   */
  export type Gallery_productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_product to fetch.
     */
    where: Gallery_productWhereUniqueInput
  }

  /**
   * Gallery_product findFirst
   */
  export type Gallery_productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_product to fetch.
     */
    where?: Gallery_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_products to fetch.
     */
    orderBy?: Gallery_productOrderByWithRelationInput | Gallery_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gallery_products.
     */
    cursor?: Gallery_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gallery_products.
     */
    distinct?: Gallery_productScalarFieldEnum | Gallery_productScalarFieldEnum[]
  }

  /**
   * Gallery_product findFirstOrThrow
   */
  export type Gallery_productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_product to fetch.
     */
    where?: Gallery_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_products to fetch.
     */
    orderBy?: Gallery_productOrderByWithRelationInput | Gallery_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gallery_products.
     */
    cursor?: Gallery_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gallery_products.
     */
    distinct?: Gallery_productScalarFieldEnum | Gallery_productScalarFieldEnum[]
  }

  /**
   * Gallery_product findMany
   */
  export type Gallery_productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * Filter, which Gallery_products to fetch.
     */
    where?: Gallery_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gallery_products to fetch.
     */
    orderBy?: Gallery_productOrderByWithRelationInput | Gallery_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gallery_products.
     */
    cursor?: Gallery_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gallery_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gallery_products.
     */
    skip?: number
    distinct?: Gallery_productScalarFieldEnum | Gallery_productScalarFieldEnum[]
  }

  /**
   * Gallery_product create
   */
  export type Gallery_productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * The data needed to create a Gallery_product.
     */
    data: XOR<Gallery_productCreateInput, Gallery_productUncheckedCreateInput>
  }

  /**
   * Gallery_product createMany
   */
  export type Gallery_productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gallery_products.
     */
    data: Gallery_productCreateManyInput | Gallery_productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gallery_product createManyAndReturn
   */
  export type Gallery_productCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * The data used to create many Gallery_products.
     */
    data: Gallery_productCreateManyInput | Gallery_productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gallery_product update
   */
  export type Gallery_productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * The data needed to update a Gallery_product.
     */
    data: XOR<Gallery_productUpdateInput, Gallery_productUncheckedUpdateInput>
    /**
     * Choose, which Gallery_product to update.
     */
    where: Gallery_productWhereUniqueInput
  }

  /**
   * Gallery_product updateMany
   */
  export type Gallery_productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gallery_products.
     */
    data: XOR<Gallery_productUpdateManyMutationInput, Gallery_productUncheckedUpdateManyInput>
    /**
     * Filter which Gallery_products to update
     */
    where?: Gallery_productWhereInput
    /**
     * Limit how many Gallery_products to update.
     */
    limit?: number
  }

  /**
   * Gallery_product updateManyAndReturn
   */
  export type Gallery_productUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * The data used to update Gallery_products.
     */
    data: XOR<Gallery_productUpdateManyMutationInput, Gallery_productUncheckedUpdateManyInput>
    /**
     * Filter which Gallery_products to update
     */
    where?: Gallery_productWhereInput
    /**
     * Limit how many Gallery_products to update.
     */
    limit?: number
  }

  /**
   * Gallery_product upsert
   */
  export type Gallery_productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * The filter to search for the Gallery_product to update in case it exists.
     */
    where: Gallery_productWhereUniqueInput
    /**
     * In case the Gallery_product found by the `where` argument doesn't exist, create a new Gallery_product with this data.
     */
    create: XOR<Gallery_productCreateInput, Gallery_productUncheckedCreateInput>
    /**
     * In case the Gallery_product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Gallery_productUpdateInput, Gallery_productUncheckedUpdateInput>
  }

  /**
   * Gallery_product delete
   */
  export type Gallery_productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
    /**
     * Filter which Gallery_product to delete.
     */
    where: Gallery_productWhereUniqueInput
  }

  /**
   * Gallery_product deleteMany
   */
  export type Gallery_productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gallery_products to delete
     */
    where?: Gallery_productWhereInput
    /**
     * Limit how many Gallery_products to delete.
     */
    limit?: number
  }

  /**
   * Gallery_product without action
   */
  export type Gallery_productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gallery_product
     */
    select?: Gallery_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gallery_product
     */
    omit?: Gallery_productOmit<ExtArgs> | null
  }


  /**
   * Model Contact_us
   */

  export type AggregateContact_us = {
    _count: Contact_usCountAggregateOutputType | null
    _min: Contact_usMinAggregateOutputType | null
    _max: Contact_usMaxAggregateOutputType | null
  }

  export type Contact_usMinAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    span: string | null
    description: string | null
    image: string | null
  }

  export type Contact_usMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    title: string | null
    span: string | null
    description: string | null
    image: string | null
  }

  export type Contact_usCountAggregateOutputType = {
    id: number
    lang: number
    title: number
    span: number
    description: number
    image: number
    _all: number
  }


  export type Contact_usMinAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    span?: true
    description?: true
    image?: true
  }

  export type Contact_usMaxAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    span?: true
    description?: true
    image?: true
  }

  export type Contact_usCountAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    span?: true
    description?: true
    image?: true
    _all?: true
  }

  export type Contact_usAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_us to aggregate.
     */
    where?: Contact_usWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_uses to fetch.
     */
    orderBy?: Contact_usOrderByWithRelationInput | Contact_usOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Contact_usWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_uses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_uses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contact_uses
    **/
    _count?: true | Contact_usCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_usMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_usMaxAggregateInputType
  }

  export type GetContact_usAggregateType<T extends Contact_usAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_us]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_us[P]>
      : GetScalarType<T[P], AggregateContact_us[P]>
  }




  export type Contact_usGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Contact_usWhereInput
    orderBy?: Contact_usOrderByWithAggregationInput | Contact_usOrderByWithAggregationInput[]
    by: Contact_usScalarFieldEnum[] | Contact_usScalarFieldEnum
    having?: Contact_usScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_usCountAggregateInputType | true
    _min?: Contact_usMinAggregateInputType
    _max?: Contact_usMaxAggregateInputType
  }

  export type Contact_usGroupByOutputType = {
    id: string
    lang: string
    title: string
    span: string
    description: string
    image: string
    _count: Contact_usCountAggregateOutputType | null
    _min: Contact_usMinAggregateOutputType | null
    _max: Contact_usMaxAggregateOutputType | null
  }

  type GetContact_usGroupByPayload<T extends Contact_usGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_usGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_usGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_usGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_usGroupByOutputType[P]>
        }
      >
    >


  export type Contact_usSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    span?: boolean
    description?: boolean
    image?: boolean
  }, ExtArgs["result"]["contact_us"]>

  export type Contact_usSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    span?: boolean
    description?: boolean
    image?: boolean
  }, ExtArgs["result"]["contact_us"]>

  export type Contact_usSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    span?: boolean
    description?: boolean
    image?: boolean
  }, ExtArgs["result"]["contact_us"]>

  export type Contact_usSelectScalar = {
    id?: boolean
    lang?: boolean
    title?: boolean
    span?: boolean
    description?: boolean
    image?: boolean
  }

  export type Contact_usOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "title" | "span" | "description" | "image", ExtArgs["result"]["contact_us"]>

  export type $Contact_usPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact_us"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      title: string
      span: string
      description: string
      image: string
    }, ExtArgs["result"]["contact_us"]>
    composites: {}
  }

  type Contact_usGetPayload<S extends boolean | null | undefined | Contact_usDefaultArgs> = $Result.GetResult<Prisma.$Contact_usPayload, S>

  type Contact_usCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Contact_usFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Contact_usCountAggregateInputType | true
    }

  export interface Contact_usDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact_us'], meta: { name: 'Contact_us' } }
    /**
     * Find zero or one Contact_us that matches the filter.
     * @param {Contact_usFindUniqueArgs} args - Arguments to find a Contact_us
     * @example
     * // Get one Contact_us
     * const contact_us = await prisma.contact_us.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Contact_usFindUniqueArgs>(args: SelectSubset<T, Contact_usFindUniqueArgs<ExtArgs>>): Prisma__Contact_usClient<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact_us that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Contact_usFindUniqueOrThrowArgs} args - Arguments to find a Contact_us
     * @example
     * // Get one Contact_us
     * const contact_us = await prisma.contact_us.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Contact_usFindUniqueOrThrowArgs>(args: SelectSubset<T, Contact_usFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Contact_usClient<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_us that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_usFindFirstArgs} args - Arguments to find a Contact_us
     * @example
     * // Get one Contact_us
     * const contact_us = await prisma.contact_us.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Contact_usFindFirstArgs>(args?: SelectSubset<T, Contact_usFindFirstArgs<ExtArgs>>): Prisma__Contact_usClient<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_us that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_usFindFirstOrThrowArgs} args - Arguments to find a Contact_us
     * @example
     * // Get one Contact_us
     * const contact_us = await prisma.contact_us.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Contact_usFindFirstOrThrowArgs>(args?: SelectSubset<T, Contact_usFindFirstOrThrowArgs<ExtArgs>>): Prisma__Contact_usClient<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contact_uses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_usFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_uses
     * const contact_uses = await prisma.contact_us.findMany()
     * 
     * // Get first 10 Contact_uses
     * const contact_uses = await prisma.contact_us.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_usWithIdOnly = await prisma.contact_us.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Contact_usFindManyArgs>(args?: SelectSubset<T, Contact_usFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact_us.
     * @param {Contact_usCreateArgs} args - Arguments to create a Contact_us.
     * @example
     * // Create one Contact_us
     * const Contact_us = await prisma.contact_us.create({
     *   data: {
     *     // ... data to create a Contact_us
     *   }
     * })
     * 
     */
    create<T extends Contact_usCreateArgs>(args: SelectSubset<T, Contact_usCreateArgs<ExtArgs>>): Prisma__Contact_usClient<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contact_uses.
     * @param {Contact_usCreateManyArgs} args - Arguments to create many Contact_uses.
     * @example
     * // Create many Contact_uses
     * const contact_us = await prisma.contact_us.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Contact_usCreateManyArgs>(args?: SelectSubset<T, Contact_usCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_uses and returns the data saved in the database.
     * @param {Contact_usCreateManyAndReturnArgs} args - Arguments to create many Contact_uses.
     * @example
     * // Create many Contact_uses
     * const contact_us = await prisma.contact_us.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_uses and only return the `id`
     * const contact_usWithIdOnly = await prisma.contact_us.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Contact_usCreateManyAndReturnArgs>(args?: SelectSubset<T, Contact_usCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact_us.
     * @param {Contact_usDeleteArgs} args - Arguments to delete one Contact_us.
     * @example
     * // Delete one Contact_us
     * const Contact_us = await prisma.contact_us.delete({
     *   where: {
     *     // ... filter to delete one Contact_us
     *   }
     * })
     * 
     */
    delete<T extends Contact_usDeleteArgs>(args: SelectSubset<T, Contact_usDeleteArgs<ExtArgs>>): Prisma__Contact_usClient<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact_us.
     * @param {Contact_usUpdateArgs} args - Arguments to update one Contact_us.
     * @example
     * // Update one Contact_us
     * const contact_us = await prisma.contact_us.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Contact_usUpdateArgs>(args: SelectSubset<T, Contact_usUpdateArgs<ExtArgs>>): Prisma__Contact_usClient<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contact_uses.
     * @param {Contact_usDeleteManyArgs} args - Arguments to filter Contact_uses to delete.
     * @example
     * // Delete a few Contact_uses
     * const { count } = await prisma.contact_us.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Contact_usDeleteManyArgs>(args?: SelectSubset<T, Contact_usDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_uses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_usUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_uses
     * const contact_us = await prisma.contact_us.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Contact_usUpdateManyArgs>(args: SelectSubset<T, Contact_usUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_uses and returns the data updated in the database.
     * @param {Contact_usUpdateManyAndReturnArgs} args - Arguments to update many Contact_uses.
     * @example
     * // Update many Contact_uses
     * const contact_us = await prisma.contact_us.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contact_uses and only return the `id`
     * const contact_usWithIdOnly = await prisma.contact_us.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Contact_usUpdateManyAndReturnArgs>(args: SelectSubset<T, Contact_usUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact_us.
     * @param {Contact_usUpsertArgs} args - Arguments to update or create a Contact_us.
     * @example
     * // Update or create a Contact_us
     * const contact_us = await prisma.contact_us.upsert({
     *   create: {
     *     // ... data to create a Contact_us
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_us we want to update
     *   }
     * })
     */
    upsert<T extends Contact_usUpsertArgs>(args: SelectSubset<T, Contact_usUpsertArgs<ExtArgs>>): Prisma__Contact_usClient<$Result.GetResult<Prisma.$Contact_usPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contact_uses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_usCountArgs} args - Arguments to filter Contact_uses to count.
     * @example
     * // Count the number of Contact_uses
     * const count = await prisma.contact_us.count({
     *   where: {
     *     // ... the filter for the Contact_uses we want to count
     *   }
     * })
    **/
    count<T extends Contact_usCountArgs>(
      args?: Subset<T, Contact_usCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_usCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_us.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_usAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_usAggregateArgs>(args: Subset<T, Contact_usAggregateArgs>): Prisma.PrismaPromise<GetContact_usAggregateType<T>>

    /**
     * Group by Contact_us.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_usGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_usGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_usGroupByArgs['orderBy'] }
        : { orderBy?: Contact_usGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_usGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_usGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact_us model
   */
  readonly fields: Contact_usFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact_us.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Contact_usClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact_us model
   */
  interface Contact_usFieldRefs {
    readonly id: FieldRef<"Contact_us", 'String'>
    readonly lang: FieldRef<"Contact_us", 'String'>
    readonly title: FieldRef<"Contact_us", 'String'>
    readonly span: FieldRef<"Contact_us", 'String'>
    readonly description: FieldRef<"Contact_us", 'String'>
    readonly image: FieldRef<"Contact_us", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact_us findUnique
   */
  export type Contact_usFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * Filter, which Contact_us to fetch.
     */
    where: Contact_usWhereUniqueInput
  }

  /**
   * Contact_us findUniqueOrThrow
   */
  export type Contact_usFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * Filter, which Contact_us to fetch.
     */
    where: Contact_usWhereUniqueInput
  }

  /**
   * Contact_us findFirst
   */
  export type Contact_usFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * Filter, which Contact_us to fetch.
     */
    where?: Contact_usWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_uses to fetch.
     */
    orderBy?: Contact_usOrderByWithRelationInput | Contact_usOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_uses.
     */
    cursor?: Contact_usWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_uses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_uses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_uses.
     */
    distinct?: Contact_usScalarFieldEnum | Contact_usScalarFieldEnum[]
  }

  /**
   * Contact_us findFirstOrThrow
   */
  export type Contact_usFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * Filter, which Contact_us to fetch.
     */
    where?: Contact_usWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_uses to fetch.
     */
    orderBy?: Contact_usOrderByWithRelationInput | Contact_usOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_uses.
     */
    cursor?: Contact_usWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_uses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_uses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_uses.
     */
    distinct?: Contact_usScalarFieldEnum | Contact_usScalarFieldEnum[]
  }

  /**
   * Contact_us findMany
   */
  export type Contact_usFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * Filter, which Contact_uses to fetch.
     */
    where?: Contact_usWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_uses to fetch.
     */
    orderBy?: Contact_usOrderByWithRelationInput | Contact_usOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contact_uses.
     */
    cursor?: Contact_usWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_uses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_uses.
     */
    skip?: number
    distinct?: Contact_usScalarFieldEnum | Contact_usScalarFieldEnum[]
  }

  /**
   * Contact_us create
   */
  export type Contact_usCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * The data needed to create a Contact_us.
     */
    data: XOR<Contact_usCreateInput, Contact_usUncheckedCreateInput>
  }

  /**
   * Contact_us createMany
   */
  export type Contact_usCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contact_uses.
     */
    data: Contact_usCreateManyInput | Contact_usCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_us createManyAndReturn
   */
  export type Contact_usCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * The data used to create many Contact_uses.
     */
    data: Contact_usCreateManyInput | Contact_usCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_us update
   */
  export type Contact_usUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * The data needed to update a Contact_us.
     */
    data: XOR<Contact_usUpdateInput, Contact_usUncheckedUpdateInput>
    /**
     * Choose, which Contact_us to update.
     */
    where: Contact_usWhereUniqueInput
  }

  /**
   * Contact_us updateMany
   */
  export type Contact_usUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contact_uses.
     */
    data: XOR<Contact_usUpdateManyMutationInput, Contact_usUncheckedUpdateManyInput>
    /**
     * Filter which Contact_uses to update
     */
    where?: Contact_usWhereInput
    /**
     * Limit how many Contact_uses to update.
     */
    limit?: number
  }

  /**
   * Contact_us updateManyAndReturn
   */
  export type Contact_usUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * The data used to update Contact_uses.
     */
    data: XOR<Contact_usUpdateManyMutationInput, Contact_usUncheckedUpdateManyInput>
    /**
     * Filter which Contact_uses to update
     */
    where?: Contact_usWhereInput
    /**
     * Limit how many Contact_uses to update.
     */
    limit?: number
  }

  /**
   * Contact_us upsert
   */
  export type Contact_usUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * The filter to search for the Contact_us to update in case it exists.
     */
    where: Contact_usWhereUniqueInput
    /**
     * In case the Contact_us found by the `where` argument doesn't exist, create a new Contact_us with this data.
     */
    create: XOR<Contact_usCreateInput, Contact_usUncheckedCreateInput>
    /**
     * In case the Contact_us was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Contact_usUpdateInput, Contact_usUncheckedUpdateInput>
  }

  /**
   * Contact_us delete
   */
  export type Contact_usDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
    /**
     * Filter which Contact_us to delete.
     */
    where: Contact_usWhereUniqueInput
  }

  /**
   * Contact_us deleteMany
   */
  export type Contact_usDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_uses to delete
     */
    where?: Contact_usWhereInput
    /**
     * Limit how many Contact_uses to delete.
     */
    limit?: number
  }

  /**
   * Contact_us without action
   */
  export type Contact_usDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_us
     */
    select?: Contact_usSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_us
     */
    omit?: Contact_usOmit<ExtArgs> | null
  }


  /**
   * Model Contact_message
   */

  export type AggregateContact_message = {
    _count: Contact_messageCountAggregateOutputType | null
    _min: Contact_messageMinAggregateOutputType | null
    _max: Contact_messageMaxAggregateOutputType | null
  }

  export type Contact_messageMinAggregateOutputType = {
    id: string | null
    lang: string | null
    input_name_placeholder: string | null
    input_last_name_placeholder: string | null
    input_email_placeholder: string | null
    input_tel_placeholder: string | null
    textarea_placeholder: string | null
    btn_text: string | null
  }

  export type Contact_messageMaxAggregateOutputType = {
    id: string | null
    lang: string | null
    input_name_placeholder: string | null
    input_last_name_placeholder: string | null
    input_email_placeholder: string | null
    input_tel_placeholder: string | null
    textarea_placeholder: string | null
    btn_text: string | null
  }

  export type Contact_messageCountAggregateOutputType = {
    id: number
    lang: number
    input_name_placeholder: number
    input_last_name_placeholder: number
    input_email_placeholder: number
    input_tel_placeholder: number
    textarea_placeholder: number
    btn_text: number
    _all: number
  }


  export type Contact_messageMinAggregateInputType = {
    id?: true
    lang?: true
    input_name_placeholder?: true
    input_last_name_placeholder?: true
    input_email_placeholder?: true
    input_tel_placeholder?: true
    textarea_placeholder?: true
    btn_text?: true
  }

  export type Contact_messageMaxAggregateInputType = {
    id?: true
    lang?: true
    input_name_placeholder?: true
    input_last_name_placeholder?: true
    input_email_placeholder?: true
    input_tel_placeholder?: true
    textarea_placeholder?: true
    btn_text?: true
  }

  export type Contact_messageCountAggregateInputType = {
    id?: true
    lang?: true
    input_name_placeholder?: true
    input_last_name_placeholder?: true
    input_email_placeholder?: true
    input_tel_placeholder?: true
    textarea_placeholder?: true
    btn_text?: true
    _all?: true
  }

  export type Contact_messageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_message to aggregate.
     */
    where?: Contact_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_messages to fetch.
     */
    orderBy?: Contact_messageOrderByWithRelationInput | Contact_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Contact_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contact_messages
    **/
    _count?: true | Contact_messageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_messageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_messageMaxAggregateInputType
  }

  export type GetContact_messageAggregateType<T extends Contact_messageAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_message]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_message[P]>
      : GetScalarType<T[P], AggregateContact_message[P]>
  }




  export type Contact_messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Contact_messageWhereInput
    orderBy?: Contact_messageOrderByWithAggregationInput | Contact_messageOrderByWithAggregationInput[]
    by: Contact_messageScalarFieldEnum[] | Contact_messageScalarFieldEnum
    having?: Contact_messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_messageCountAggregateInputType | true
    _min?: Contact_messageMinAggregateInputType
    _max?: Contact_messageMaxAggregateInputType
  }

  export type Contact_messageGroupByOutputType = {
    id: string
    lang: string
    input_name_placeholder: string
    input_last_name_placeholder: string
    input_email_placeholder: string
    input_tel_placeholder: string
    textarea_placeholder: string
    btn_text: string
    _count: Contact_messageCountAggregateOutputType | null
    _min: Contact_messageMinAggregateOutputType | null
    _max: Contact_messageMaxAggregateOutputType | null
  }

  type GetContact_messageGroupByPayload<T extends Contact_messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_messageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_messageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_messageGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_messageGroupByOutputType[P]>
        }
      >
    >


  export type Contact_messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    input_name_placeholder?: boolean
    input_last_name_placeholder?: boolean
    input_email_placeholder?: boolean
    input_tel_placeholder?: boolean
    textarea_placeholder?: boolean
    btn_text?: boolean
  }, ExtArgs["result"]["contact_message"]>

  export type Contact_messageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    input_name_placeholder?: boolean
    input_last_name_placeholder?: boolean
    input_email_placeholder?: boolean
    input_tel_placeholder?: boolean
    textarea_placeholder?: boolean
    btn_text?: boolean
  }, ExtArgs["result"]["contact_message"]>

  export type Contact_messageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    input_name_placeholder?: boolean
    input_last_name_placeholder?: boolean
    input_email_placeholder?: boolean
    input_tel_placeholder?: boolean
    textarea_placeholder?: boolean
    btn_text?: boolean
  }, ExtArgs["result"]["contact_message"]>

  export type Contact_messageSelectScalar = {
    id?: boolean
    lang?: boolean
    input_name_placeholder?: boolean
    input_last_name_placeholder?: boolean
    input_email_placeholder?: boolean
    input_tel_placeholder?: boolean
    textarea_placeholder?: boolean
    btn_text?: boolean
  }

  export type Contact_messageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lang" | "input_name_placeholder" | "input_last_name_placeholder" | "input_email_placeholder" | "input_tel_placeholder" | "textarea_placeholder" | "btn_text", ExtArgs["result"]["contact_message"]>

  export type $Contact_messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact_message"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lang: string
      input_name_placeholder: string
      input_last_name_placeholder: string
      input_email_placeholder: string
      input_tel_placeholder: string
      textarea_placeholder: string
      btn_text: string
    }, ExtArgs["result"]["contact_message"]>
    composites: {}
  }

  type Contact_messageGetPayload<S extends boolean | null | undefined | Contact_messageDefaultArgs> = $Result.GetResult<Prisma.$Contact_messagePayload, S>

  type Contact_messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Contact_messageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Contact_messageCountAggregateInputType | true
    }

  export interface Contact_messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact_message'], meta: { name: 'Contact_message' } }
    /**
     * Find zero or one Contact_message that matches the filter.
     * @param {Contact_messageFindUniqueArgs} args - Arguments to find a Contact_message
     * @example
     * // Get one Contact_message
     * const contact_message = await prisma.contact_message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Contact_messageFindUniqueArgs>(args: SelectSubset<T, Contact_messageFindUniqueArgs<ExtArgs>>): Prisma__Contact_messageClient<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact_message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Contact_messageFindUniqueOrThrowArgs} args - Arguments to find a Contact_message
     * @example
     * // Get one Contact_message
     * const contact_message = await prisma.contact_message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Contact_messageFindUniqueOrThrowArgs>(args: SelectSubset<T, Contact_messageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Contact_messageClient<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_messageFindFirstArgs} args - Arguments to find a Contact_message
     * @example
     * // Get one Contact_message
     * const contact_message = await prisma.contact_message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Contact_messageFindFirstArgs>(args?: SelectSubset<T, Contact_messageFindFirstArgs<ExtArgs>>): Prisma__Contact_messageClient<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_messageFindFirstOrThrowArgs} args - Arguments to find a Contact_message
     * @example
     * // Get one Contact_message
     * const contact_message = await prisma.contact_message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Contact_messageFindFirstOrThrowArgs>(args?: SelectSubset<T, Contact_messageFindFirstOrThrowArgs<ExtArgs>>): Prisma__Contact_messageClient<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contact_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_messageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_messages
     * const contact_messages = await prisma.contact_message.findMany()
     * 
     * // Get first 10 Contact_messages
     * const contact_messages = await prisma.contact_message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_messageWithIdOnly = await prisma.contact_message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Contact_messageFindManyArgs>(args?: SelectSubset<T, Contact_messageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact_message.
     * @param {Contact_messageCreateArgs} args - Arguments to create a Contact_message.
     * @example
     * // Create one Contact_message
     * const Contact_message = await prisma.contact_message.create({
     *   data: {
     *     // ... data to create a Contact_message
     *   }
     * })
     * 
     */
    create<T extends Contact_messageCreateArgs>(args: SelectSubset<T, Contact_messageCreateArgs<ExtArgs>>): Prisma__Contact_messageClient<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contact_messages.
     * @param {Contact_messageCreateManyArgs} args - Arguments to create many Contact_messages.
     * @example
     * // Create many Contact_messages
     * const contact_message = await prisma.contact_message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Contact_messageCreateManyArgs>(args?: SelectSubset<T, Contact_messageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_messages and returns the data saved in the database.
     * @param {Contact_messageCreateManyAndReturnArgs} args - Arguments to create many Contact_messages.
     * @example
     * // Create many Contact_messages
     * const contact_message = await prisma.contact_message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_messages and only return the `id`
     * const contact_messageWithIdOnly = await prisma.contact_message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Contact_messageCreateManyAndReturnArgs>(args?: SelectSubset<T, Contact_messageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact_message.
     * @param {Contact_messageDeleteArgs} args - Arguments to delete one Contact_message.
     * @example
     * // Delete one Contact_message
     * const Contact_message = await prisma.contact_message.delete({
     *   where: {
     *     // ... filter to delete one Contact_message
     *   }
     * })
     * 
     */
    delete<T extends Contact_messageDeleteArgs>(args: SelectSubset<T, Contact_messageDeleteArgs<ExtArgs>>): Prisma__Contact_messageClient<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact_message.
     * @param {Contact_messageUpdateArgs} args - Arguments to update one Contact_message.
     * @example
     * // Update one Contact_message
     * const contact_message = await prisma.contact_message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Contact_messageUpdateArgs>(args: SelectSubset<T, Contact_messageUpdateArgs<ExtArgs>>): Prisma__Contact_messageClient<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contact_messages.
     * @param {Contact_messageDeleteManyArgs} args - Arguments to filter Contact_messages to delete.
     * @example
     * // Delete a few Contact_messages
     * const { count } = await prisma.contact_message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Contact_messageDeleteManyArgs>(args?: SelectSubset<T, Contact_messageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_messages
     * const contact_message = await prisma.contact_message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Contact_messageUpdateManyArgs>(args: SelectSubset<T, Contact_messageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_messages and returns the data updated in the database.
     * @param {Contact_messageUpdateManyAndReturnArgs} args - Arguments to update many Contact_messages.
     * @example
     * // Update many Contact_messages
     * const contact_message = await prisma.contact_message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contact_messages and only return the `id`
     * const contact_messageWithIdOnly = await prisma.contact_message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Contact_messageUpdateManyAndReturnArgs>(args: SelectSubset<T, Contact_messageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact_message.
     * @param {Contact_messageUpsertArgs} args - Arguments to update or create a Contact_message.
     * @example
     * // Update or create a Contact_message
     * const contact_message = await prisma.contact_message.upsert({
     *   create: {
     *     // ... data to create a Contact_message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_message we want to update
     *   }
     * })
     */
    upsert<T extends Contact_messageUpsertArgs>(args: SelectSubset<T, Contact_messageUpsertArgs<ExtArgs>>): Prisma__Contact_messageClient<$Result.GetResult<Prisma.$Contact_messagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_messageCountArgs} args - Arguments to filter Contact_messages to count.
     * @example
     * // Count the number of Contact_messages
     * const count = await prisma.contact_message.count({
     *   where: {
     *     // ... the filter for the Contact_messages we want to count
     *   }
     * })
    **/
    count<T extends Contact_messageCountArgs>(
      args?: Subset<T, Contact_messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_messageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_messageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_messageAggregateArgs>(args: Subset<T, Contact_messageAggregateArgs>): Prisma.PrismaPromise<GetContact_messageAggregateType<T>>

    /**
     * Group by Contact_message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_messageGroupByArgs['orderBy'] }
        : { orderBy?: Contact_messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_messageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact_message model
   */
  readonly fields: Contact_messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact_message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Contact_messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact_message model
   */
  interface Contact_messageFieldRefs {
    readonly id: FieldRef<"Contact_message", 'String'>
    readonly lang: FieldRef<"Contact_message", 'String'>
    readonly input_name_placeholder: FieldRef<"Contact_message", 'String'>
    readonly input_last_name_placeholder: FieldRef<"Contact_message", 'String'>
    readonly input_email_placeholder: FieldRef<"Contact_message", 'String'>
    readonly input_tel_placeholder: FieldRef<"Contact_message", 'String'>
    readonly textarea_placeholder: FieldRef<"Contact_message", 'String'>
    readonly btn_text: FieldRef<"Contact_message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact_message findUnique
   */
  export type Contact_messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * Filter, which Contact_message to fetch.
     */
    where: Contact_messageWhereUniqueInput
  }

  /**
   * Contact_message findUniqueOrThrow
   */
  export type Contact_messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * Filter, which Contact_message to fetch.
     */
    where: Contact_messageWhereUniqueInput
  }

  /**
   * Contact_message findFirst
   */
  export type Contact_messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * Filter, which Contact_message to fetch.
     */
    where?: Contact_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_messages to fetch.
     */
    orderBy?: Contact_messageOrderByWithRelationInput | Contact_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_messages.
     */
    cursor?: Contact_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_messages.
     */
    distinct?: Contact_messageScalarFieldEnum | Contact_messageScalarFieldEnum[]
  }

  /**
   * Contact_message findFirstOrThrow
   */
  export type Contact_messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * Filter, which Contact_message to fetch.
     */
    where?: Contact_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_messages to fetch.
     */
    orderBy?: Contact_messageOrderByWithRelationInput | Contact_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_messages.
     */
    cursor?: Contact_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_messages.
     */
    distinct?: Contact_messageScalarFieldEnum | Contact_messageScalarFieldEnum[]
  }

  /**
   * Contact_message findMany
   */
  export type Contact_messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * Filter, which Contact_messages to fetch.
     */
    where?: Contact_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_messages to fetch.
     */
    orderBy?: Contact_messageOrderByWithRelationInput | Contact_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contact_messages.
     */
    cursor?: Contact_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_messages.
     */
    skip?: number
    distinct?: Contact_messageScalarFieldEnum | Contact_messageScalarFieldEnum[]
  }

  /**
   * Contact_message create
   */
  export type Contact_messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * The data needed to create a Contact_message.
     */
    data: XOR<Contact_messageCreateInput, Contact_messageUncheckedCreateInput>
  }

  /**
   * Contact_message createMany
   */
  export type Contact_messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contact_messages.
     */
    data: Contact_messageCreateManyInput | Contact_messageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_message createManyAndReturn
   */
  export type Contact_messageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * The data used to create many Contact_messages.
     */
    data: Contact_messageCreateManyInput | Contact_messageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_message update
   */
  export type Contact_messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * The data needed to update a Contact_message.
     */
    data: XOR<Contact_messageUpdateInput, Contact_messageUncheckedUpdateInput>
    /**
     * Choose, which Contact_message to update.
     */
    where: Contact_messageWhereUniqueInput
  }

  /**
   * Contact_message updateMany
   */
  export type Contact_messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contact_messages.
     */
    data: XOR<Contact_messageUpdateManyMutationInput, Contact_messageUncheckedUpdateManyInput>
    /**
     * Filter which Contact_messages to update
     */
    where?: Contact_messageWhereInput
    /**
     * Limit how many Contact_messages to update.
     */
    limit?: number
  }

  /**
   * Contact_message updateManyAndReturn
   */
  export type Contact_messageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * The data used to update Contact_messages.
     */
    data: XOR<Contact_messageUpdateManyMutationInput, Contact_messageUncheckedUpdateManyInput>
    /**
     * Filter which Contact_messages to update
     */
    where?: Contact_messageWhereInput
    /**
     * Limit how many Contact_messages to update.
     */
    limit?: number
  }

  /**
   * Contact_message upsert
   */
  export type Contact_messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * The filter to search for the Contact_message to update in case it exists.
     */
    where: Contact_messageWhereUniqueInput
    /**
     * In case the Contact_message found by the `where` argument doesn't exist, create a new Contact_message with this data.
     */
    create: XOR<Contact_messageCreateInput, Contact_messageUncheckedCreateInput>
    /**
     * In case the Contact_message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Contact_messageUpdateInput, Contact_messageUncheckedUpdateInput>
  }

  /**
   * Contact_message delete
   */
  export type Contact_messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
    /**
     * Filter which Contact_message to delete.
     */
    where: Contact_messageWhereUniqueInput
  }

  /**
   * Contact_message deleteMany
   */
  export type Contact_messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_messages to delete
     */
    where?: Contact_messageWhereInput
    /**
     * Limit how many Contact_messages to delete.
     */
    limit?: number
  }

  /**
   * Contact_message without action
   */
  export type Contact_messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_message
     */
    select?: Contact_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact_message
     */
    omit?: Contact_messageOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Body_imageScalarFieldEnum: {
    id: 'id',
    background_img1: 'background_img1'
  };

  export type Body_imageScalarFieldEnum = (typeof Body_imageScalarFieldEnum)[keyof typeof Body_imageScalarFieldEnum]


  export const Header_main_logoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    img_url: 'img_url'
  };

  export type Header_main_logoScalarFieldEnum = (typeof Header_main_logoScalarFieldEnum)[keyof typeof Header_main_logoScalarFieldEnum]


  export const Header_navbarScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    title: 'title',
    route: 'route',
    url: 'url'
  };

  export type Header_navbarScalarFieldEnum = (typeof Header_navbarScalarFieldEnum)[keyof typeof Header_navbarScalarFieldEnum]


  export const Header_languageScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    title: 'title'
  };

  export type Header_languageScalarFieldEnum = (typeof Header_languageScalarFieldEnum)[keyof typeof Header_languageScalarFieldEnum]


  export const Home_introScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    videoUrl: 'videoUrl',
    mainHeading: 'mainHeading',
    subHeading: 'subHeading'
  };

  export type Home_introScalarFieldEnum = (typeof Home_introScalarFieldEnum)[keyof typeof Home_introScalarFieldEnum]


  export const About_titleScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    title: 'title'
  };

  export type About_titleScalarFieldEnum = (typeof About_titleScalarFieldEnum)[keyof typeof About_titleScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    image: 'image',
    btn_text: 'btn_text',
    title: 'title',
    description: 'description'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const Gallery_titleScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    title: 'title',
    subTitle: 'subTitle'
  };

  export type Gallery_titleScalarFieldEnum = (typeof Gallery_titleScalarFieldEnum)[keyof typeof Gallery_titleScalarFieldEnum]


  export const Gallery_contentScalarFieldEnum: {
    id: 'id',
    img_url: 'img_url'
  };

  export type Gallery_contentScalarFieldEnum = (typeof Gallery_contentScalarFieldEnum)[keyof typeof Gallery_contentScalarFieldEnum]


  export const Contact_titleScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    title: 'title',
    img_url: 'img_url'
  };

  export type Contact_titleScalarFieldEnum = (typeof Contact_titleScalarFieldEnum)[keyof typeof Contact_titleScalarFieldEnum]


  export const Contact_infoScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    name: 'name',
    icons1: 'icons1',
    href1: 'href1',
    icons2: 'icons2',
    phone1: 'phone1',
    phone2: 'phone2',
    icons3: 'icons3',
    mail1: 'mail1',
    mail2: 'mail2'
  };

  export type Contact_infoScalarFieldEnum = (typeof Contact_infoScalarFieldEnum)[keyof typeof Contact_infoScalarFieldEnum]


  export const FooterScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    background_img: 'background_img',
    logo_img: 'logo_img',
    title: 'title',
    address: 'address',
    email: 'email',
    phone1: 'phone1',
    phone2: 'phone2'
  };

  export type FooterScalarFieldEnum = (typeof FooterScalarFieldEnum)[keyof typeof FooterScalarFieldEnum]


  export const Winery_infoScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    title: 'title',
    description: 'description'
  };

  export type Winery_infoScalarFieldEnum = (typeof Winery_infoScalarFieldEnum)[keyof typeof Winery_infoScalarFieldEnum]


  export const Winery_imageScalarFieldEnum: {
    id: 'id',
    background_image: 'background_image',
    img_url1: 'img_url1',
    img_url2: 'img_url2',
    img_url3: 'img_url3'
  };

  export type Winery_imageScalarFieldEnum = (typeof Winery_imageScalarFieldEnum)[keyof typeof Winery_imageScalarFieldEnum]


  export const Winery_our_storyScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    title: 'title',
    description: 'description'
  };

  export type Winery_our_storyScalarFieldEnum = (typeof Winery_our_storyScalarFieldEnum)[keyof typeof Winery_our_storyScalarFieldEnum]


  export const Gallery_productScalarFieldEnum: {
    id: 'id',
    img_url: 'img_url'
  };

  export type Gallery_productScalarFieldEnum = (typeof Gallery_productScalarFieldEnum)[keyof typeof Gallery_productScalarFieldEnum]


  export const Contact_usScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    title: 'title',
    span: 'span',
    description: 'description',
    image: 'image'
  };

  export type Contact_usScalarFieldEnum = (typeof Contact_usScalarFieldEnum)[keyof typeof Contact_usScalarFieldEnum]


  export const Contact_messageScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    input_name_placeholder: 'input_name_placeholder',
    input_last_name_placeholder: 'input_last_name_placeholder',
    input_email_placeholder: 'input_email_placeholder',
    input_tel_placeholder: 'input_tel_placeholder',
    textarea_placeholder: 'textarea_placeholder',
    btn_text: 'btn_text'
  };

  export type Contact_messageScalarFieldEnum = (typeof Contact_messageScalarFieldEnum)[keyof typeof Contact_messageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type Body_imageWhereInput = {
    AND?: Body_imageWhereInput | Body_imageWhereInput[]
    OR?: Body_imageWhereInput[]
    NOT?: Body_imageWhereInput | Body_imageWhereInput[]
    id?: StringFilter<"Body_image"> | string
    background_img1?: StringFilter<"Body_image"> | string
  }

  export type Body_imageOrderByWithRelationInput = {
    id?: SortOrder
    background_img1?: SortOrder
  }

  export type Body_imageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Body_imageWhereInput | Body_imageWhereInput[]
    OR?: Body_imageWhereInput[]
    NOT?: Body_imageWhereInput | Body_imageWhereInput[]
    background_img1?: StringFilter<"Body_image"> | string
  }, "id">

  export type Body_imageOrderByWithAggregationInput = {
    id?: SortOrder
    background_img1?: SortOrder
    _count?: Body_imageCountOrderByAggregateInput
    _max?: Body_imageMaxOrderByAggregateInput
    _min?: Body_imageMinOrderByAggregateInput
  }

  export type Body_imageScalarWhereWithAggregatesInput = {
    AND?: Body_imageScalarWhereWithAggregatesInput | Body_imageScalarWhereWithAggregatesInput[]
    OR?: Body_imageScalarWhereWithAggregatesInput[]
    NOT?: Body_imageScalarWhereWithAggregatesInput | Body_imageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Body_image"> | string
    background_img1?: StringWithAggregatesFilter<"Body_image"> | string
  }

  export type Header_main_logoWhereInput = {
    AND?: Header_main_logoWhereInput | Header_main_logoWhereInput[]
    OR?: Header_main_logoWhereInput[]
    NOT?: Header_main_logoWhereInput | Header_main_logoWhereInput[]
    id?: StringFilter<"Header_main_logo"> | string
    url?: StringFilter<"Header_main_logo"> | string
    img_url?: StringFilter<"Header_main_logo"> | string
  }

  export type Header_main_logoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    img_url?: SortOrder
  }

  export type Header_main_logoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Header_main_logoWhereInput | Header_main_logoWhereInput[]
    OR?: Header_main_logoWhereInput[]
    NOT?: Header_main_logoWhereInput | Header_main_logoWhereInput[]
    url?: StringFilter<"Header_main_logo"> | string
    img_url?: StringFilter<"Header_main_logo"> | string
  }, "id">

  export type Header_main_logoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    img_url?: SortOrder
    _count?: Header_main_logoCountOrderByAggregateInput
    _max?: Header_main_logoMaxOrderByAggregateInput
    _min?: Header_main_logoMinOrderByAggregateInput
  }

  export type Header_main_logoScalarWhereWithAggregatesInput = {
    AND?: Header_main_logoScalarWhereWithAggregatesInput | Header_main_logoScalarWhereWithAggregatesInput[]
    OR?: Header_main_logoScalarWhereWithAggregatesInput[]
    NOT?: Header_main_logoScalarWhereWithAggregatesInput | Header_main_logoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Header_main_logo"> | string
    url?: StringWithAggregatesFilter<"Header_main_logo"> | string
    img_url?: StringWithAggregatesFilter<"Header_main_logo"> | string
  }

  export type Header_navbarWhereInput = {
    AND?: Header_navbarWhereInput | Header_navbarWhereInput[]
    OR?: Header_navbarWhereInput[]
    NOT?: Header_navbarWhereInput | Header_navbarWhereInput[]
    id?: StringFilter<"Header_navbar"> | string
    lang?: StringFilter<"Header_navbar"> | string
    title?: StringFilter<"Header_navbar"> | string
    route?: StringFilter<"Header_navbar"> | string
    url?: StringFilter<"Header_navbar"> | string
  }

  export type Header_navbarOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    route?: SortOrder
    url?: SortOrder
  }

  export type Header_navbarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Header_navbarWhereInput | Header_navbarWhereInput[]
    OR?: Header_navbarWhereInput[]
    NOT?: Header_navbarWhereInput | Header_navbarWhereInput[]
    lang?: StringFilter<"Header_navbar"> | string
    title?: StringFilter<"Header_navbar"> | string
    route?: StringFilter<"Header_navbar"> | string
    url?: StringFilter<"Header_navbar"> | string
  }, "id">

  export type Header_navbarOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    route?: SortOrder
    url?: SortOrder
    _count?: Header_navbarCountOrderByAggregateInput
    _max?: Header_navbarMaxOrderByAggregateInput
    _min?: Header_navbarMinOrderByAggregateInput
  }

  export type Header_navbarScalarWhereWithAggregatesInput = {
    AND?: Header_navbarScalarWhereWithAggregatesInput | Header_navbarScalarWhereWithAggregatesInput[]
    OR?: Header_navbarScalarWhereWithAggregatesInput[]
    NOT?: Header_navbarScalarWhereWithAggregatesInput | Header_navbarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Header_navbar"> | string
    lang?: StringWithAggregatesFilter<"Header_navbar"> | string
    title?: StringWithAggregatesFilter<"Header_navbar"> | string
    route?: StringWithAggregatesFilter<"Header_navbar"> | string
    url?: StringWithAggregatesFilter<"Header_navbar"> | string
  }

  export type Header_languageWhereInput = {
    AND?: Header_languageWhereInput | Header_languageWhereInput[]
    OR?: Header_languageWhereInput[]
    NOT?: Header_languageWhereInput | Header_languageWhereInput[]
    id?: StringFilter<"Header_language"> | string
    lang?: StringFilter<"Header_language"> | string
    title?: StringFilter<"Header_language"> | string
  }

  export type Header_languageOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
  }

  export type Header_languageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Header_languageWhereInput | Header_languageWhereInput[]
    OR?: Header_languageWhereInput[]
    NOT?: Header_languageWhereInput | Header_languageWhereInput[]
    lang?: StringFilter<"Header_language"> | string
    title?: StringFilter<"Header_language"> | string
  }, "id">

  export type Header_languageOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    _count?: Header_languageCountOrderByAggregateInput
    _max?: Header_languageMaxOrderByAggregateInput
    _min?: Header_languageMinOrderByAggregateInput
  }

  export type Header_languageScalarWhereWithAggregatesInput = {
    AND?: Header_languageScalarWhereWithAggregatesInput | Header_languageScalarWhereWithAggregatesInput[]
    OR?: Header_languageScalarWhereWithAggregatesInput[]
    NOT?: Header_languageScalarWhereWithAggregatesInput | Header_languageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Header_language"> | string
    lang?: StringWithAggregatesFilter<"Header_language"> | string
    title?: StringWithAggregatesFilter<"Header_language"> | string
  }

  export type Home_introWhereInput = {
    AND?: Home_introWhereInput | Home_introWhereInput[]
    OR?: Home_introWhereInput[]
    NOT?: Home_introWhereInput | Home_introWhereInput[]
    id?: StringFilter<"Home_intro"> | string
    lang?: StringFilter<"Home_intro"> | string
    videoUrl?: StringFilter<"Home_intro"> | string
    mainHeading?: StringFilter<"Home_intro"> | string
    subHeading?: StringFilter<"Home_intro"> | string
  }

  export type Home_introOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    videoUrl?: SortOrder
    mainHeading?: SortOrder
    subHeading?: SortOrder
  }

  export type Home_introWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Home_introWhereInput | Home_introWhereInput[]
    OR?: Home_introWhereInput[]
    NOT?: Home_introWhereInput | Home_introWhereInput[]
    lang?: StringFilter<"Home_intro"> | string
    videoUrl?: StringFilter<"Home_intro"> | string
    mainHeading?: StringFilter<"Home_intro"> | string
    subHeading?: StringFilter<"Home_intro"> | string
  }, "id">

  export type Home_introOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    videoUrl?: SortOrder
    mainHeading?: SortOrder
    subHeading?: SortOrder
    _count?: Home_introCountOrderByAggregateInput
    _max?: Home_introMaxOrderByAggregateInput
    _min?: Home_introMinOrderByAggregateInput
  }

  export type Home_introScalarWhereWithAggregatesInput = {
    AND?: Home_introScalarWhereWithAggregatesInput | Home_introScalarWhereWithAggregatesInput[]
    OR?: Home_introScalarWhereWithAggregatesInput[]
    NOT?: Home_introScalarWhereWithAggregatesInput | Home_introScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Home_intro"> | string
    lang?: StringWithAggregatesFilter<"Home_intro"> | string
    videoUrl?: StringWithAggregatesFilter<"Home_intro"> | string
    mainHeading?: StringWithAggregatesFilter<"Home_intro"> | string
    subHeading?: StringWithAggregatesFilter<"Home_intro"> | string
  }

  export type About_titleWhereInput = {
    AND?: About_titleWhereInput | About_titleWhereInput[]
    OR?: About_titleWhereInput[]
    NOT?: About_titleWhereInput | About_titleWhereInput[]
    id?: StringFilter<"About_title"> | string
    lang?: StringFilter<"About_title"> | string
    title?: StringFilter<"About_title"> | string
  }

  export type About_titleOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
  }

  export type About_titleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: About_titleWhereInput | About_titleWhereInput[]
    OR?: About_titleWhereInput[]
    NOT?: About_titleWhereInput | About_titleWhereInput[]
    lang?: StringFilter<"About_title"> | string
    title?: StringFilter<"About_title"> | string
  }, "id">

  export type About_titleOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    _count?: About_titleCountOrderByAggregateInput
    _max?: About_titleMaxOrderByAggregateInput
    _min?: About_titleMinOrderByAggregateInput
  }

  export type About_titleScalarWhereWithAggregatesInput = {
    AND?: About_titleScalarWhereWithAggregatesInput | About_titleScalarWhereWithAggregatesInput[]
    OR?: About_titleScalarWhereWithAggregatesInput[]
    NOT?: About_titleScalarWhereWithAggregatesInput | About_titleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"About_title"> | string
    lang?: StringWithAggregatesFilter<"About_title"> | string
    title?: StringWithAggregatesFilter<"About_title"> | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    lang?: StringFilter<"Product"> | string
    image?: StringFilter<"Product"> | string
    btn_text?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    image?: SortOrder
    btn_text?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    lang?: StringFilter<"Product"> | string
    image?: StringFilter<"Product"> | string
    btn_text?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    image?: SortOrder
    btn_text?: SortOrder
    title?: SortOrder
    description?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    lang?: StringWithAggregatesFilter<"Product"> | string
    image?: StringWithAggregatesFilter<"Product"> | string
    btn_text?: StringWithAggregatesFilter<"Product"> | string
    title?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
  }

  export type Gallery_titleWhereInput = {
    AND?: Gallery_titleWhereInput | Gallery_titleWhereInput[]
    OR?: Gallery_titleWhereInput[]
    NOT?: Gallery_titleWhereInput | Gallery_titleWhereInput[]
    id?: StringFilter<"Gallery_title"> | string
    lang?: StringFilter<"Gallery_title"> | string
    title?: StringFilter<"Gallery_title"> | string
    subTitle?: StringFilter<"Gallery_title"> | string
  }

  export type Gallery_titleOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
  }

  export type Gallery_titleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Gallery_titleWhereInput | Gallery_titleWhereInput[]
    OR?: Gallery_titleWhereInput[]
    NOT?: Gallery_titleWhereInput | Gallery_titleWhereInput[]
    lang?: StringFilter<"Gallery_title"> | string
    title?: StringFilter<"Gallery_title"> | string
    subTitle?: StringFilter<"Gallery_title"> | string
  }, "id">

  export type Gallery_titleOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    _count?: Gallery_titleCountOrderByAggregateInput
    _max?: Gallery_titleMaxOrderByAggregateInput
    _min?: Gallery_titleMinOrderByAggregateInput
  }

  export type Gallery_titleScalarWhereWithAggregatesInput = {
    AND?: Gallery_titleScalarWhereWithAggregatesInput | Gallery_titleScalarWhereWithAggregatesInput[]
    OR?: Gallery_titleScalarWhereWithAggregatesInput[]
    NOT?: Gallery_titleScalarWhereWithAggregatesInput | Gallery_titleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gallery_title"> | string
    lang?: StringWithAggregatesFilter<"Gallery_title"> | string
    title?: StringWithAggregatesFilter<"Gallery_title"> | string
    subTitle?: StringWithAggregatesFilter<"Gallery_title"> | string
  }

  export type Gallery_contentWhereInput = {
    AND?: Gallery_contentWhereInput | Gallery_contentWhereInput[]
    OR?: Gallery_contentWhereInput[]
    NOT?: Gallery_contentWhereInput | Gallery_contentWhereInput[]
    id?: StringFilter<"Gallery_content"> | string
    img_url?: StringFilter<"Gallery_content"> | string
  }

  export type Gallery_contentOrderByWithRelationInput = {
    id?: SortOrder
    img_url?: SortOrder
  }

  export type Gallery_contentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Gallery_contentWhereInput | Gallery_contentWhereInput[]
    OR?: Gallery_contentWhereInput[]
    NOT?: Gallery_contentWhereInput | Gallery_contentWhereInput[]
    img_url?: StringFilter<"Gallery_content"> | string
  }, "id">

  export type Gallery_contentOrderByWithAggregationInput = {
    id?: SortOrder
    img_url?: SortOrder
    _count?: Gallery_contentCountOrderByAggregateInput
    _max?: Gallery_contentMaxOrderByAggregateInput
    _min?: Gallery_contentMinOrderByAggregateInput
  }

  export type Gallery_contentScalarWhereWithAggregatesInput = {
    AND?: Gallery_contentScalarWhereWithAggregatesInput | Gallery_contentScalarWhereWithAggregatesInput[]
    OR?: Gallery_contentScalarWhereWithAggregatesInput[]
    NOT?: Gallery_contentScalarWhereWithAggregatesInput | Gallery_contentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gallery_content"> | string
    img_url?: StringWithAggregatesFilter<"Gallery_content"> | string
  }

  export type Contact_titleWhereInput = {
    AND?: Contact_titleWhereInput | Contact_titleWhereInput[]
    OR?: Contact_titleWhereInput[]
    NOT?: Contact_titleWhereInput | Contact_titleWhereInput[]
    id?: StringFilter<"Contact_title"> | string
    lang?: StringFilter<"Contact_title"> | string
    title?: StringFilter<"Contact_title"> | string
    img_url?: StringFilter<"Contact_title"> | string
  }

  export type Contact_titleOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    img_url?: SortOrder
  }

  export type Contact_titleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Contact_titleWhereInput | Contact_titleWhereInput[]
    OR?: Contact_titleWhereInput[]
    NOT?: Contact_titleWhereInput | Contact_titleWhereInput[]
    lang?: StringFilter<"Contact_title"> | string
    title?: StringFilter<"Contact_title"> | string
    img_url?: StringFilter<"Contact_title"> | string
  }, "id">

  export type Contact_titleOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    img_url?: SortOrder
    _count?: Contact_titleCountOrderByAggregateInput
    _max?: Contact_titleMaxOrderByAggregateInput
    _min?: Contact_titleMinOrderByAggregateInput
  }

  export type Contact_titleScalarWhereWithAggregatesInput = {
    AND?: Contact_titleScalarWhereWithAggregatesInput | Contact_titleScalarWhereWithAggregatesInput[]
    OR?: Contact_titleScalarWhereWithAggregatesInput[]
    NOT?: Contact_titleScalarWhereWithAggregatesInput | Contact_titleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact_title"> | string
    lang?: StringWithAggregatesFilter<"Contact_title"> | string
    title?: StringWithAggregatesFilter<"Contact_title"> | string
    img_url?: StringWithAggregatesFilter<"Contact_title"> | string
  }

  export type Contact_infoWhereInput = {
    AND?: Contact_infoWhereInput | Contact_infoWhereInput[]
    OR?: Contact_infoWhereInput[]
    NOT?: Contact_infoWhereInput | Contact_infoWhereInput[]
    id?: StringFilter<"Contact_info"> | string
    lang?: StringFilter<"Contact_info"> | string
    name?: StringFilter<"Contact_info"> | string
    icons1?: StringFilter<"Contact_info"> | string
    href1?: StringFilter<"Contact_info"> | string
    icons2?: StringFilter<"Contact_info"> | string
    phone1?: StringFilter<"Contact_info"> | string
    phone2?: StringFilter<"Contact_info"> | string
    icons3?: StringFilter<"Contact_info"> | string
    mail1?: StringFilter<"Contact_info"> | string
    mail2?: StringFilter<"Contact_info"> | string
  }

  export type Contact_infoOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    icons1?: SortOrder
    href1?: SortOrder
    icons2?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
    icons3?: SortOrder
    mail1?: SortOrder
    mail2?: SortOrder
  }

  export type Contact_infoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Contact_infoWhereInput | Contact_infoWhereInput[]
    OR?: Contact_infoWhereInput[]
    NOT?: Contact_infoWhereInput | Contact_infoWhereInput[]
    lang?: StringFilter<"Contact_info"> | string
    name?: StringFilter<"Contact_info"> | string
    icons1?: StringFilter<"Contact_info"> | string
    href1?: StringFilter<"Contact_info"> | string
    icons2?: StringFilter<"Contact_info"> | string
    phone1?: StringFilter<"Contact_info"> | string
    phone2?: StringFilter<"Contact_info"> | string
    icons3?: StringFilter<"Contact_info"> | string
    mail1?: StringFilter<"Contact_info"> | string
    mail2?: StringFilter<"Contact_info"> | string
  }, "id">

  export type Contact_infoOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    icons1?: SortOrder
    href1?: SortOrder
    icons2?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
    icons3?: SortOrder
    mail1?: SortOrder
    mail2?: SortOrder
    _count?: Contact_infoCountOrderByAggregateInput
    _max?: Contact_infoMaxOrderByAggregateInput
    _min?: Contact_infoMinOrderByAggregateInput
  }

  export type Contact_infoScalarWhereWithAggregatesInput = {
    AND?: Contact_infoScalarWhereWithAggregatesInput | Contact_infoScalarWhereWithAggregatesInput[]
    OR?: Contact_infoScalarWhereWithAggregatesInput[]
    NOT?: Contact_infoScalarWhereWithAggregatesInput | Contact_infoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact_info"> | string
    lang?: StringWithAggregatesFilter<"Contact_info"> | string
    name?: StringWithAggregatesFilter<"Contact_info"> | string
    icons1?: StringWithAggregatesFilter<"Contact_info"> | string
    href1?: StringWithAggregatesFilter<"Contact_info"> | string
    icons2?: StringWithAggregatesFilter<"Contact_info"> | string
    phone1?: StringWithAggregatesFilter<"Contact_info"> | string
    phone2?: StringWithAggregatesFilter<"Contact_info"> | string
    icons3?: StringWithAggregatesFilter<"Contact_info"> | string
    mail1?: StringWithAggregatesFilter<"Contact_info"> | string
    mail2?: StringWithAggregatesFilter<"Contact_info"> | string
  }

  export type FooterWhereInput = {
    AND?: FooterWhereInput | FooterWhereInput[]
    OR?: FooterWhereInput[]
    NOT?: FooterWhereInput | FooterWhereInput[]
    id?: StringFilter<"Footer"> | string
    lang?: StringFilter<"Footer"> | string
    background_img?: StringFilter<"Footer"> | string
    logo_img?: StringFilter<"Footer"> | string
    title?: StringFilter<"Footer"> | string
    address?: StringFilter<"Footer"> | string
    email?: StringFilter<"Footer"> | string
    phone1?: StringFilter<"Footer"> | string
    phone2?: StringFilter<"Footer"> | string
  }

  export type FooterOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    background_img?: SortOrder
    logo_img?: SortOrder
    title?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
  }

  export type FooterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FooterWhereInput | FooterWhereInput[]
    OR?: FooterWhereInput[]
    NOT?: FooterWhereInput | FooterWhereInput[]
    lang?: StringFilter<"Footer"> | string
    background_img?: StringFilter<"Footer"> | string
    logo_img?: StringFilter<"Footer"> | string
    title?: StringFilter<"Footer"> | string
    address?: StringFilter<"Footer"> | string
    email?: StringFilter<"Footer"> | string
    phone1?: StringFilter<"Footer"> | string
    phone2?: StringFilter<"Footer"> | string
  }, "id">

  export type FooterOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    background_img?: SortOrder
    logo_img?: SortOrder
    title?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
    _count?: FooterCountOrderByAggregateInput
    _max?: FooterMaxOrderByAggregateInput
    _min?: FooterMinOrderByAggregateInput
  }

  export type FooterScalarWhereWithAggregatesInput = {
    AND?: FooterScalarWhereWithAggregatesInput | FooterScalarWhereWithAggregatesInput[]
    OR?: FooterScalarWhereWithAggregatesInput[]
    NOT?: FooterScalarWhereWithAggregatesInput | FooterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Footer"> | string
    lang?: StringWithAggregatesFilter<"Footer"> | string
    background_img?: StringWithAggregatesFilter<"Footer"> | string
    logo_img?: StringWithAggregatesFilter<"Footer"> | string
    title?: StringWithAggregatesFilter<"Footer"> | string
    address?: StringWithAggregatesFilter<"Footer"> | string
    email?: StringWithAggregatesFilter<"Footer"> | string
    phone1?: StringWithAggregatesFilter<"Footer"> | string
    phone2?: StringWithAggregatesFilter<"Footer"> | string
  }

  export type Winery_infoWhereInput = {
    AND?: Winery_infoWhereInput | Winery_infoWhereInput[]
    OR?: Winery_infoWhereInput[]
    NOT?: Winery_infoWhereInput | Winery_infoWhereInput[]
    id?: StringFilter<"Winery_info"> | string
    lang?: StringFilter<"Winery_info"> | string
    title?: StringFilter<"Winery_info"> | string
    description?: StringFilter<"Winery_info"> | string
  }

  export type Winery_infoOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type Winery_infoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Winery_infoWhereInput | Winery_infoWhereInput[]
    OR?: Winery_infoWhereInput[]
    NOT?: Winery_infoWhereInput | Winery_infoWhereInput[]
    lang?: StringFilter<"Winery_info"> | string
    title?: StringFilter<"Winery_info"> | string
    description?: StringFilter<"Winery_info"> | string
  }, "id">

  export type Winery_infoOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
    _count?: Winery_infoCountOrderByAggregateInput
    _max?: Winery_infoMaxOrderByAggregateInput
    _min?: Winery_infoMinOrderByAggregateInput
  }

  export type Winery_infoScalarWhereWithAggregatesInput = {
    AND?: Winery_infoScalarWhereWithAggregatesInput | Winery_infoScalarWhereWithAggregatesInput[]
    OR?: Winery_infoScalarWhereWithAggregatesInput[]
    NOT?: Winery_infoScalarWhereWithAggregatesInput | Winery_infoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Winery_info"> | string
    lang?: StringWithAggregatesFilter<"Winery_info"> | string
    title?: StringWithAggregatesFilter<"Winery_info"> | string
    description?: StringWithAggregatesFilter<"Winery_info"> | string
  }

  export type Winery_imageWhereInput = {
    AND?: Winery_imageWhereInput | Winery_imageWhereInput[]
    OR?: Winery_imageWhereInput[]
    NOT?: Winery_imageWhereInput | Winery_imageWhereInput[]
    id?: StringFilter<"Winery_image"> | string
    background_image?: StringFilter<"Winery_image"> | string
    img_url1?: StringFilter<"Winery_image"> | string
    img_url2?: StringFilter<"Winery_image"> | string
    img_url3?: StringFilter<"Winery_image"> | string
  }

  export type Winery_imageOrderByWithRelationInput = {
    id?: SortOrder
    background_image?: SortOrder
    img_url1?: SortOrder
    img_url2?: SortOrder
    img_url3?: SortOrder
  }

  export type Winery_imageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Winery_imageWhereInput | Winery_imageWhereInput[]
    OR?: Winery_imageWhereInput[]
    NOT?: Winery_imageWhereInput | Winery_imageWhereInput[]
    background_image?: StringFilter<"Winery_image"> | string
    img_url1?: StringFilter<"Winery_image"> | string
    img_url2?: StringFilter<"Winery_image"> | string
    img_url3?: StringFilter<"Winery_image"> | string
  }, "id">

  export type Winery_imageOrderByWithAggregationInput = {
    id?: SortOrder
    background_image?: SortOrder
    img_url1?: SortOrder
    img_url2?: SortOrder
    img_url3?: SortOrder
    _count?: Winery_imageCountOrderByAggregateInput
    _max?: Winery_imageMaxOrderByAggregateInput
    _min?: Winery_imageMinOrderByAggregateInput
  }

  export type Winery_imageScalarWhereWithAggregatesInput = {
    AND?: Winery_imageScalarWhereWithAggregatesInput | Winery_imageScalarWhereWithAggregatesInput[]
    OR?: Winery_imageScalarWhereWithAggregatesInput[]
    NOT?: Winery_imageScalarWhereWithAggregatesInput | Winery_imageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Winery_image"> | string
    background_image?: StringWithAggregatesFilter<"Winery_image"> | string
    img_url1?: StringWithAggregatesFilter<"Winery_image"> | string
    img_url2?: StringWithAggregatesFilter<"Winery_image"> | string
    img_url3?: StringWithAggregatesFilter<"Winery_image"> | string
  }

  export type Winery_our_storyWhereInput = {
    AND?: Winery_our_storyWhereInput | Winery_our_storyWhereInput[]
    OR?: Winery_our_storyWhereInput[]
    NOT?: Winery_our_storyWhereInput | Winery_our_storyWhereInput[]
    id?: StringFilter<"Winery_our_story"> | string
    lang?: StringFilter<"Winery_our_story"> | string
    title?: StringFilter<"Winery_our_story"> | string
    description?: StringFilter<"Winery_our_story"> | string
  }

  export type Winery_our_storyOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type Winery_our_storyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Winery_our_storyWhereInput | Winery_our_storyWhereInput[]
    OR?: Winery_our_storyWhereInput[]
    NOT?: Winery_our_storyWhereInput | Winery_our_storyWhereInput[]
    lang?: StringFilter<"Winery_our_story"> | string
    title?: StringFilter<"Winery_our_story"> | string
    description?: StringFilter<"Winery_our_story"> | string
  }, "id">

  export type Winery_our_storyOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
    _count?: Winery_our_storyCountOrderByAggregateInput
    _max?: Winery_our_storyMaxOrderByAggregateInput
    _min?: Winery_our_storyMinOrderByAggregateInput
  }

  export type Winery_our_storyScalarWhereWithAggregatesInput = {
    AND?: Winery_our_storyScalarWhereWithAggregatesInput | Winery_our_storyScalarWhereWithAggregatesInput[]
    OR?: Winery_our_storyScalarWhereWithAggregatesInput[]
    NOT?: Winery_our_storyScalarWhereWithAggregatesInput | Winery_our_storyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Winery_our_story"> | string
    lang?: StringWithAggregatesFilter<"Winery_our_story"> | string
    title?: StringWithAggregatesFilter<"Winery_our_story"> | string
    description?: StringWithAggregatesFilter<"Winery_our_story"> | string
  }

  export type Gallery_productWhereInput = {
    AND?: Gallery_productWhereInput | Gallery_productWhereInput[]
    OR?: Gallery_productWhereInput[]
    NOT?: Gallery_productWhereInput | Gallery_productWhereInput[]
    id?: StringFilter<"Gallery_product"> | string
    img_url?: StringFilter<"Gallery_product"> | string
  }

  export type Gallery_productOrderByWithRelationInput = {
    id?: SortOrder
    img_url?: SortOrder
  }

  export type Gallery_productWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Gallery_productWhereInput | Gallery_productWhereInput[]
    OR?: Gallery_productWhereInput[]
    NOT?: Gallery_productWhereInput | Gallery_productWhereInput[]
    img_url?: StringFilter<"Gallery_product"> | string
  }, "id">

  export type Gallery_productOrderByWithAggregationInput = {
    id?: SortOrder
    img_url?: SortOrder
    _count?: Gallery_productCountOrderByAggregateInput
    _max?: Gallery_productMaxOrderByAggregateInput
    _min?: Gallery_productMinOrderByAggregateInput
  }

  export type Gallery_productScalarWhereWithAggregatesInput = {
    AND?: Gallery_productScalarWhereWithAggregatesInput | Gallery_productScalarWhereWithAggregatesInput[]
    OR?: Gallery_productScalarWhereWithAggregatesInput[]
    NOT?: Gallery_productScalarWhereWithAggregatesInput | Gallery_productScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gallery_product"> | string
    img_url?: StringWithAggregatesFilter<"Gallery_product"> | string
  }

  export type Contact_usWhereInput = {
    AND?: Contact_usWhereInput | Contact_usWhereInput[]
    OR?: Contact_usWhereInput[]
    NOT?: Contact_usWhereInput | Contact_usWhereInput[]
    id?: StringFilter<"Contact_us"> | string
    lang?: StringFilter<"Contact_us"> | string
    title?: StringFilter<"Contact_us"> | string
    span?: StringFilter<"Contact_us"> | string
    description?: StringFilter<"Contact_us"> | string
    image?: StringFilter<"Contact_us"> | string
  }

  export type Contact_usOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    span?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type Contact_usWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Contact_usWhereInput | Contact_usWhereInput[]
    OR?: Contact_usWhereInput[]
    NOT?: Contact_usWhereInput | Contact_usWhereInput[]
    lang?: StringFilter<"Contact_us"> | string
    title?: StringFilter<"Contact_us"> | string
    span?: StringFilter<"Contact_us"> | string
    description?: StringFilter<"Contact_us"> | string
    image?: StringFilter<"Contact_us"> | string
  }, "id">

  export type Contact_usOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    span?: SortOrder
    description?: SortOrder
    image?: SortOrder
    _count?: Contact_usCountOrderByAggregateInput
    _max?: Contact_usMaxOrderByAggregateInput
    _min?: Contact_usMinOrderByAggregateInput
  }

  export type Contact_usScalarWhereWithAggregatesInput = {
    AND?: Contact_usScalarWhereWithAggregatesInput | Contact_usScalarWhereWithAggregatesInput[]
    OR?: Contact_usScalarWhereWithAggregatesInput[]
    NOT?: Contact_usScalarWhereWithAggregatesInput | Contact_usScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact_us"> | string
    lang?: StringWithAggregatesFilter<"Contact_us"> | string
    title?: StringWithAggregatesFilter<"Contact_us"> | string
    span?: StringWithAggregatesFilter<"Contact_us"> | string
    description?: StringWithAggregatesFilter<"Contact_us"> | string
    image?: StringWithAggregatesFilter<"Contact_us"> | string
  }

  export type Contact_messageWhereInput = {
    AND?: Contact_messageWhereInput | Contact_messageWhereInput[]
    OR?: Contact_messageWhereInput[]
    NOT?: Contact_messageWhereInput | Contact_messageWhereInput[]
    id?: StringFilter<"Contact_message"> | string
    lang?: StringFilter<"Contact_message"> | string
    input_name_placeholder?: StringFilter<"Contact_message"> | string
    input_last_name_placeholder?: StringFilter<"Contact_message"> | string
    input_email_placeholder?: StringFilter<"Contact_message"> | string
    input_tel_placeholder?: StringFilter<"Contact_message"> | string
    textarea_placeholder?: StringFilter<"Contact_message"> | string
    btn_text?: StringFilter<"Contact_message"> | string
  }

  export type Contact_messageOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    input_name_placeholder?: SortOrder
    input_last_name_placeholder?: SortOrder
    input_email_placeholder?: SortOrder
    input_tel_placeholder?: SortOrder
    textarea_placeholder?: SortOrder
    btn_text?: SortOrder
  }

  export type Contact_messageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Contact_messageWhereInput | Contact_messageWhereInput[]
    OR?: Contact_messageWhereInput[]
    NOT?: Contact_messageWhereInput | Contact_messageWhereInput[]
    lang?: StringFilter<"Contact_message"> | string
    input_name_placeholder?: StringFilter<"Contact_message"> | string
    input_last_name_placeholder?: StringFilter<"Contact_message"> | string
    input_email_placeholder?: StringFilter<"Contact_message"> | string
    input_tel_placeholder?: StringFilter<"Contact_message"> | string
    textarea_placeholder?: StringFilter<"Contact_message"> | string
    btn_text?: StringFilter<"Contact_message"> | string
  }, "id">

  export type Contact_messageOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    input_name_placeholder?: SortOrder
    input_last_name_placeholder?: SortOrder
    input_email_placeholder?: SortOrder
    input_tel_placeholder?: SortOrder
    textarea_placeholder?: SortOrder
    btn_text?: SortOrder
    _count?: Contact_messageCountOrderByAggregateInput
    _max?: Contact_messageMaxOrderByAggregateInput
    _min?: Contact_messageMinOrderByAggregateInput
  }

  export type Contact_messageScalarWhereWithAggregatesInput = {
    AND?: Contact_messageScalarWhereWithAggregatesInput | Contact_messageScalarWhereWithAggregatesInput[]
    OR?: Contact_messageScalarWhereWithAggregatesInput[]
    NOT?: Contact_messageScalarWhereWithAggregatesInput | Contact_messageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact_message"> | string
    lang?: StringWithAggregatesFilter<"Contact_message"> | string
    input_name_placeholder?: StringWithAggregatesFilter<"Contact_message"> | string
    input_last_name_placeholder?: StringWithAggregatesFilter<"Contact_message"> | string
    input_email_placeholder?: StringWithAggregatesFilter<"Contact_message"> | string
    input_tel_placeholder?: StringWithAggregatesFilter<"Contact_message"> | string
    textarea_placeholder?: StringWithAggregatesFilter<"Contact_message"> | string
    btn_text?: StringWithAggregatesFilter<"Contact_message"> | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    password: string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    password: string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type Body_imageCreateInput = {
    id?: string
    background_img1: string
  }

  export type Body_imageUncheckedCreateInput = {
    id?: string
    background_img1: string
  }

  export type Body_imageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    background_img1?: StringFieldUpdateOperationsInput | string
  }

  export type Body_imageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    background_img1?: StringFieldUpdateOperationsInput | string
  }

  export type Body_imageCreateManyInput = {
    id?: string
    background_img1: string
  }

  export type Body_imageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    background_img1?: StringFieldUpdateOperationsInput | string
  }

  export type Body_imageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    background_img1?: StringFieldUpdateOperationsInput | string
  }

  export type Header_main_logoCreateInput = {
    id?: string
    url: string
    img_url: string
  }

  export type Header_main_logoUncheckedCreateInput = {
    id?: string
    url: string
    img_url: string
  }

  export type Header_main_logoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Header_main_logoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Header_main_logoCreateManyInput = {
    id?: string
    url: string
    img_url: string
  }

  export type Header_main_logoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Header_main_logoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Header_navbarCreateInput = {
    id?: string
    lang: string
    title: string
    route: string
    url: string
  }

  export type Header_navbarUncheckedCreateInput = {
    id?: string
    lang: string
    title: string
    route: string
    url: string
  }

  export type Header_navbarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Header_navbarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Header_navbarCreateManyInput = {
    id?: string
    lang: string
    title: string
    route: string
    url: string
  }

  export type Header_navbarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Header_navbarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Header_languageCreateInput = {
    id?: string
    lang: string
    title: string
  }

  export type Header_languageUncheckedCreateInput = {
    id?: string
    lang: string
    title: string
  }

  export type Header_languageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Header_languageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Header_languageCreateManyInput = {
    id?: string
    lang: string
    title: string
  }

  export type Header_languageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Header_languageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Home_introCreateInput = {
    id?: string
    lang: string
    videoUrl: string
    mainHeading: string
    subHeading: string
  }

  export type Home_introUncheckedCreateInput = {
    id?: string
    lang: string
    videoUrl: string
    mainHeading: string
    subHeading: string
  }

  export type Home_introUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    mainHeading?: StringFieldUpdateOperationsInput | string
    subHeading?: StringFieldUpdateOperationsInput | string
  }

  export type Home_introUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    mainHeading?: StringFieldUpdateOperationsInput | string
    subHeading?: StringFieldUpdateOperationsInput | string
  }

  export type Home_introCreateManyInput = {
    id?: string
    lang: string
    videoUrl: string
    mainHeading: string
    subHeading: string
  }

  export type Home_introUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    mainHeading?: StringFieldUpdateOperationsInput | string
    subHeading?: StringFieldUpdateOperationsInput | string
  }

  export type Home_introUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    mainHeading?: StringFieldUpdateOperationsInput | string
    subHeading?: StringFieldUpdateOperationsInput | string
  }

  export type About_titleCreateInput = {
    id?: string
    lang: string
    title: string
  }

  export type About_titleUncheckedCreateInput = {
    id?: string
    lang: string
    title: string
  }

  export type About_titleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type About_titleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type About_titleCreateManyInput = {
    id?: string
    lang: string
    title: string
  }

  export type About_titleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type About_titleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    lang: string
    image: string
    btn_text: string
    title: string
    description: string
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    lang: string
    image: string
    btn_text: string
    title: string
    description: string
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    btn_text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    btn_text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManyInput = {
    id?: string
    lang: string
    image: string
    btn_text: string
    title: string
    description: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    btn_text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    btn_text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_titleCreateInput = {
    id?: string
    lang: string
    title: string
    subTitle: string
  }

  export type Gallery_titleUncheckedCreateInput = {
    id?: string
    lang: string
    title: string
    subTitle: string
  }

  export type Gallery_titleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_titleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_titleCreateManyInput = {
    id?: string
    lang: string
    title: string
    subTitle: string
  }

  export type Gallery_titleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_titleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_contentCreateInput = {
    id?: string
    img_url: string
  }

  export type Gallery_contentUncheckedCreateInput = {
    id?: string
    img_url: string
  }

  export type Gallery_contentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_contentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_contentCreateManyInput = {
    id?: string
    img_url: string
  }

  export type Gallery_contentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_contentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_titleCreateInput = {
    id?: string
    lang: string
    title: string
    img_url: string
  }

  export type Contact_titleUncheckedCreateInput = {
    id?: string
    lang: string
    title: string
    img_url: string
  }

  export type Contact_titleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_titleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_titleCreateManyInput = {
    id?: string
    lang: string
    title: string
    img_url: string
  }

  export type Contact_titleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_titleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_infoCreateInput = {
    id?: string
    lang: string
    name: string
    icons1: string
    href1: string
    icons2: string
    phone1: string
    phone2: string
    icons3: string
    mail1: string
    mail2: string
  }

  export type Contact_infoUncheckedCreateInput = {
    id?: string
    lang: string
    name: string
    icons1: string
    href1: string
    icons2: string
    phone1: string
    phone2: string
    icons3: string
    mail1: string
    mail2: string
  }

  export type Contact_infoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icons1?: StringFieldUpdateOperationsInput | string
    href1?: StringFieldUpdateOperationsInput | string
    icons2?: StringFieldUpdateOperationsInput | string
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: StringFieldUpdateOperationsInput | string
    icons3?: StringFieldUpdateOperationsInput | string
    mail1?: StringFieldUpdateOperationsInput | string
    mail2?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_infoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icons1?: StringFieldUpdateOperationsInput | string
    href1?: StringFieldUpdateOperationsInput | string
    icons2?: StringFieldUpdateOperationsInput | string
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: StringFieldUpdateOperationsInput | string
    icons3?: StringFieldUpdateOperationsInput | string
    mail1?: StringFieldUpdateOperationsInput | string
    mail2?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_infoCreateManyInput = {
    id?: string
    lang: string
    name: string
    icons1: string
    href1: string
    icons2: string
    phone1: string
    phone2: string
    icons3: string
    mail1: string
    mail2: string
  }

  export type Contact_infoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icons1?: StringFieldUpdateOperationsInput | string
    href1?: StringFieldUpdateOperationsInput | string
    icons2?: StringFieldUpdateOperationsInput | string
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: StringFieldUpdateOperationsInput | string
    icons3?: StringFieldUpdateOperationsInput | string
    mail1?: StringFieldUpdateOperationsInput | string
    mail2?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_infoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icons1?: StringFieldUpdateOperationsInput | string
    href1?: StringFieldUpdateOperationsInput | string
    icons2?: StringFieldUpdateOperationsInput | string
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: StringFieldUpdateOperationsInput | string
    icons3?: StringFieldUpdateOperationsInput | string
    mail1?: StringFieldUpdateOperationsInput | string
    mail2?: StringFieldUpdateOperationsInput | string
  }

  export type FooterCreateInput = {
    id?: string
    lang: string
    background_img: string
    logo_img: string
    title: string
    address: string
    email: string
    phone1: string
    phone2: string
  }

  export type FooterUncheckedCreateInput = {
    id?: string
    lang: string
    background_img: string
    logo_img: string
    title: string
    address: string
    email: string
    phone1: string
    phone2: string
  }

  export type FooterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    background_img?: StringFieldUpdateOperationsInput | string
    logo_img?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: StringFieldUpdateOperationsInput | string
  }

  export type FooterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    background_img?: StringFieldUpdateOperationsInput | string
    logo_img?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: StringFieldUpdateOperationsInput | string
  }

  export type FooterCreateManyInput = {
    id?: string
    lang: string
    background_img: string
    logo_img: string
    title: string
    address: string
    email: string
    phone1: string
    phone2: string
  }

  export type FooterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    background_img?: StringFieldUpdateOperationsInput | string
    logo_img?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: StringFieldUpdateOperationsInput | string
  }

  export type FooterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    background_img?: StringFieldUpdateOperationsInput | string
    logo_img?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone1?: StringFieldUpdateOperationsInput | string
    phone2?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_infoCreateInput = {
    id?: string
    lang: string
    title: string
    description: string
  }

  export type Winery_infoUncheckedCreateInput = {
    id?: string
    lang: string
    title: string
    description: string
  }

  export type Winery_infoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_infoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_infoCreateManyInput = {
    id?: string
    lang: string
    title: string
    description: string
  }

  export type Winery_infoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_infoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_imageCreateInput = {
    id?: string
    background_image: string
    img_url1: string
    img_url2: string
    img_url3: string
  }

  export type Winery_imageUncheckedCreateInput = {
    id?: string
    background_image: string
    img_url1: string
    img_url2: string
    img_url3: string
  }

  export type Winery_imageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    background_image?: StringFieldUpdateOperationsInput | string
    img_url1?: StringFieldUpdateOperationsInput | string
    img_url2?: StringFieldUpdateOperationsInput | string
    img_url3?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_imageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    background_image?: StringFieldUpdateOperationsInput | string
    img_url1?: StringFieldUpdateOperationsInput | string
    img_url2?: StringFieldUpdateOperationsInput | string
    img_url3?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_imageCreateManyInput = {
    id?: string
    background_image: string
    img_url1: string
    img_url2: string
    img_url3: string
  }

  export type Winery_imageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    background_image?: StringFieldUpdateOperationsInput | string
    img_url1?: StringFieldUpdateOperationsInput | string
    img_url2?: StringFieldUpdateOperationsInput | string
    img_url3?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_imageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    background_image?: StringFieldUpdateOperationsInput | string
    img_url1?: StringFieldUpdateOperationsInput | string
    img_url2?: StringFieldUpdateOperationsInput | string
    img_url3?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_our_storyCreateInput = {
    id?: string
    lang: string
    title: string
    description: string
  }

  export type Winery_our_storyUncheckedCreateInput = {
    id?: string
    lang: string
    title: string
    description: string
  }

  export type Winery_our_storyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_our_storyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_our_storyCreateManyInput = {
    id?: string
    lang: string
    title: string
    description: string
  }

  export type Winery_our_storyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Winery_our_storyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_productCreateInput = {
    id?: string
    img_url: string
  }

  export type Gallery_productUncheckedCreateInput = {
    id?: string
    img_url: string
  }

  export type Gallery_productUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_productUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_productCreateManyInput = {
    id?: string
    img_url: string
  }

  export type Gallery_productUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Gallery_productUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_usCreateInput = {
    id?: string
    lang: string
    title: string
    span: string
    description: string
    image: string
  }

  export type Contact_usUncheckedCreateInput = {
    id?: string
    lang: string
    title: string
    span: string
    description: string
    image: string
  }

  export type Contact_usUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    span?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_usUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    span?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_usCreateManyInput = {
    id?: string
    lang: string
    title: string
    span: string
    description: string
    image: string
  }

  export type Contact_usUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    span?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_usUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    span?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_messageCreateInput = {
    id?: string
    lang: string
    input_name_placeholder: string
    input_last_name_placeholder: string
    input_email_placeholder: string
    input_tel_placeholder: string
    textarea_placeholder: string
    btn_text: string
  }

  export type Contact_messageUncheckedCreateInput = {
    id?: string
    lang: string
    input_name_placeholder: string
    input_last_name_placeholder: string
    input_email_placeholder: string
    input_tel_placeholder: string
    textarea_placeholder: string
    btn_text: string
  }

  export type Contact_messageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    input_name_placeholder?: StringFieldUpdateOperationsInput | string
    input_last_name_placeholder?: StringFieldUpdateOperationsInput | string
    input_email_placeholder?: StringFieldUpdateOperationsInput | string
    input_tel_placeholder?: StringFieldUpdateOperationsInput | string
    textarea_placeholder?: StringFieldUpdateOperationsInput | string
    btn_text?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_messageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    input_name_placeholder?: StringFieldUpdateOperationsInput | string
    input_last_name_placeholder?: StringFieldUpdateOperationsInput | string
    input_email_placeholder?: StringFieldUpdateOperationsInput | string
    input_tel_placeholder?: StringFieldUpdateOperationsInput | string
    textarea_placeholder?: StringFieldUpdateOperationsInput | string
    btn_text?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_messageCreateManyInput = {
    id?: string
    lang: string
    input_name_placeholder: string
    input_last_name_placeholder: string
    input_email_placeholder: string
    input_tel_placeholder: string
    textarea_placeholder: string
    btn_text: string
  }

  export type Contact_messageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    input_name_placeholder?: StringFieldUpdateOperationsInput | string
    input_last_name_placeholder?: StringFieldUpdateOperationsInput | string
    input_email_placeholder?: StringFieldUpdateOperationsInput | string
    input_tel_placeholder?: StringFieldUpdateOperationsInput | string
    textarea_placeholder?: StringFieldUpdateOperationsInput | string
    btn_text?: StringFieldUpdateOperationsInput | string
  }

  export type Contact_messageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    input_name_placeholder?: StringFieldUpdateOperationsInput | string
    input_last_name_placeholder?: StringFieldUpdateOperationsInput | string
    input_email_placeholder?: StringFieldUpdateOperationsInput | string
    input_tel_placeholder?: StringFieldUpdateOperationsInput | string
    textarea_placeholder?: StringFieldUpdateOperationsInput | string
    btn_text?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Body_imageCountOrderByAggregateInput = {
    id?: SortOrder
    background_img1?: SortOrder
  }

  export type Body_imageMaxOrderByAggregateInput = {
    id?: SortOrder
    background_img1?: SortOrder
  }

  export type Body_imageMinOrderByAggregateInput = {
    id?: SortOrder
    background_img1?: SortOrder
  }

  export type Header_main_logoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    img_url?: SortOrder
  }

  export type Header_main_logoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    img_url?: SortOrder
  }

  export type Header_main_logoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    img_url?: SortOrder
  }

  export type Header_navbarCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    route?: SortOrder
    url?: SortOrder
  }

  export type Header_navbarMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    route?: SortOrder
    url?: SortOrder
  }

  export type Header_navbarMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    route?: SortOrder
    url?: SortOrder
  }

  export type Header_languageCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
  }

  export type Header_languageMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
  }

  export type Header_languageMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
  }

  export type Home_introCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    videoUrl?: SortOrder
    mainHeading?: SortOrder
    subHeading?: SortOrder
  }

  export type Home_introMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    videoUrl?: SortOrder
    mainHeading?: SortOrder
    subHeading?: SortOrder
  }

  export type Home_introMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    videoUrl?: SortOrder
    mainHeading?: SortOrder
    subHeading?: SortOrder
  }

  export type About_titleCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
  }

  export type About_titleMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
  }

  export type About_titleMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    image?: SortOrder
    btn_text?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    image?: SortOrder
    btn_text?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    image?: SortOrder
    btn_text?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type Gallery_titleCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
  }

  export type Gallery_titleMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
  }

  export type Gallery_titleMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
  }

  export type Gallery_contentCountOrderByAggregateInput = {
    id?: SortOrder
    img_url?: SortOrder
  }

  export type Gallery_contentMaxOrderByAggregateInput = {
    id?: SortOrder
    img_url?: SortOrder
  }

  export type Gallery_contentMinOrderByAggregateInput = {
    id?: SortOrder
    img_url?: SortOrder
  }

  export type Contact_titleCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    img_url?: SortOrder
  }

  export type Contact_titleMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    img_url?: SortOrder
  }

  export type Contact_titleMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    img_url?: SortOrder
  }

  export type Contact_infoCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    icons1?: SortOrder
    href1?: SortOrder
    icons2?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
    icons3?: SortOrder
    mail1?: SortOrder
    mail2?: SortOrder
  }

  export type Contact_infoMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    icons1?: SortOrder
    href1?: SortOrder
    icons2?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
    icons3?: SortOrder
    mail1?: SortOrder
    mail2?: SortOrder
  }

  export type Contact_infoMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    icons1?: SortOrder
    href1?: SortOrder
    icons2?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
    icons3?: SortOrder
    mail1?: SortOrder
    mail2?: SortOrder
  }

  export type FooterCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    background_img?: SortOrder
    logo_img?: SortOrder
    title?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
  }

  export type FooterMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    background_img?: SortOrder
    logo_img?: SortOrder
    title?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
  }

  export type FooterMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    background_img?: SortOrder
    logo_img?: SortOrder
    title?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phone1?: SortOrder
    phone2?: SortOrder
  }

  export type Winery_infoCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type Winery_infoMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type Winery_infoMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type Winery_imageCountOrderByAggregateInput = {
    id?: SortOrder
    background_image?: SortOrder
    img_url1?: SortOrder
    img_url2?: SortOrder
    img_url3?: SortOrder
  }

  export type Winery_imageMaxOrderByAggregateInput = {
    id?: SortOrder
    background_image?: SortOrder
    img_url1?: SortOrder
    img_url2?: SortOrder
    img_url3?: SortOrder
  }

  export type Winery_imageMinOrderByAggregateInput = {
    id?: SortOrder
    background_image?: SortOrder
    img_url1?: SortOrder
    img_url2?: SortOrder
    img_url3?: SortOrder
  }

  export type Winery_our_storyCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type Winery_our_storyMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type Winery_our_storyMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type Gallery_productCountOrderByAggregateInput = {
    id?: SortOrder
    img_url?: SortOrder
  }

  export type Gallery_productMaxOrderByAggregateInput = {
    id?: SortOrder
    img_url?: SortOrder
  }

  export type Gallery_productMinOrderByAggregateInput = {
    id?: SortOrder
    img_url?: SortOrder
  }

  export type Contact_usCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    span?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type Contact_usMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    span?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type Contact_usMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    span?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type Contact_messageCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    input_name_placeholder?: SortOrder
    input_last_name_placeholder?: SortOrder
    input_email_placeholder?: SortOrder
    input_tel_placeholder?: SortOrder
    textarea_placeholder?: SortOrder
    btn_text?: SortOrder
  }

  export type Contact_messageMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    input_name_placeholder?: SortOrder
    input_last_name_placeholder?: SortOrder
    input_email_placeholder?: SortOrder
    input_tel_placeholder?: SortOrder
    textarea_placeholder?: SortOrder
    btn_text?: SortOrder
  }

  export type Contact_messageMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    input_name_placeholder?: SortOrder
    input_last_name_placeholder?: SortOrder
    input_email_placeholder?: SortOrder
    input_tel_placeholder?: SortOrder
    textarea_placeholder?: SortOrder
    btn_text?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}